### 세마포
`세마포(semapore)`는 뮤텍스 락과 비슷하지만, 조금 더 일반화된 방식의 동기화 도구이다. 뮤텍스 락은 하나의 공유 자원에 접근하는 프로세스를 상정한 방식이다. 즉 탈의실이 하나 있는 경우를 가정하고 만든 동기화 도구인 것이다. 하지만 탈의실이 여러 개 있는 상황처럼 공유 자원이 여러 개 있을 경우 (각 공유 자원에는 하나의 프로세스만 진입이 가능할지라도) 여러 개의 프로세스가 각각 공유 자원에 접근이 가능해야 한다.

예를 들어 옷가게에 탈의실이 세 개 있다고 생각해보자. 여전히 하나의 탈의실에는 한 사람만 들어 갈 수 있지만 이 경우에는 세 명이 동시에 탈의실을 이용할 수 있다. 또 가령, 한 번에 하나의 프로세스만 이용할 수 있는 프린터 세 대가 있는 상황을 보자. 하나의 프린터를 사용할 수 있는 프로세스는 하나이지만, 총 세 개의 프로세스가 공유 자원(세 대의 프린터)을 이용할 수 있다.

이처럼 세마포는 공유 자원이 여러 개 있는 상황에서도 적용이 가능한 동기화 도구이다.

엄밀히 말하면 세마포의 종류에도 `이진 세마포 (binary semaphore)`와 `카운팅 세마포(counting semaphore)`가 있지만, 이진 세마포는 뮤텍스 락과 비슷한 개념이므로 카운팅 세마포를 알아보자.

세마포는 아래 그림과 같은 철도 신호기에서 유래한 단어이다. 기차는 신호기가 내려가 있을 때는 '멈춤' 신호로 간주하고 잠시 멈춘다. 반대로 신호기가 올라와 있을 때는 '가도 좋다'는 신호로 간주하고 다시 움직이기 시작한다. 세마포는 이와 같이 '멈춤' 신호와 '가도 좋다'는 신호로서 임계 구역을 관리한다. 즉, 프로세스는 임계 구역 앞에서 멈춤 신호를 받으면 잠시 기다리고, 가도 좋다는 신호를 받으면 그제서야 임계 구역으로 들어가게 된다.

![세마포](https://e7.pngegg.com/pngimages/149/753/png-clipart-flag-semaphore-international-maritime-signal-flags-semaphore-line-international-maritime-signal-flags-angle-flag.png)

세마포가 어떻게 구현되는지 간략하게 살펴보자. 세마포는 뮤텍스 락과 비슷하게 하나의 변수와 두 개의 함수로 단순하게 구현할 수 있다.

- 임계 구역에 진입할 수 있는 프로세스의 개수 (사용 가능한 공유 자원의 개수)를 나타내는 `전역 변수 S`
- 임계 구역에 들어가도 좋은지, 기다려야 할지를 알려주는 `wait 함수`
- 임계 구역 앞에서 기다리는 프로세스에 '이제 가도 좋다'고 신호를 주는 `signal 함수`

뮤텍스 락을 사용할 때 임계 구역 진입 전후로 acquire()와 release()를 호출했듯이 세마포도 임계 구역 전후로 wait()와 signal()을 호출한다.

```js
wait()
// 임계 구역
signal()
```

변수 S는 임계 구역에 진입할 수 있는 프로세스의 개수, 혹은 사용 가능한 공유 자우너의 개수라고 했다. 이를 토대로 생각해 보았을 때 wait 함수는 아래와 같이 만든다.

```js
while(S <= 0){    // 1번
	;             // 2번
}
S--;              // 3번
```

1. 만일 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하라면
2. 사용할 수 있는 자원이 있는지 반복적으로 확인하고,
3. 임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이면 S를 1 감소시키고 임계 구역 진입한다.

signal 함수는 다음과 같이 만든다.

```js
signal(){
	S++;           // 1번
}
```

1. 임계 구역에서의 작업을 마친 뒤 S를 1 증가시킨다.

가령 세 개의 프로세스 P1, P2, P3가 두 개의 공유 자원에 P1, P2, P3 순서로 접근한다고 가정해보자. 공유 자원이 두 개 있으니 변수 S는 2가 된다. 그렇다면 아래와 같은 순서로 실행된다.

![세마포.001.jpeg](<images/세마포.001.jpeg>)

1. 프로세스 P1 wait 호출, S는 현재 2이므로 S를 1 감소시키고 임계 구역 진입
2. 프로세스 P2 wait 호출, S는 현재 1이므로 S를 1 감소시키고 임계 구역 진입
3. 프로세스 P3 wait 호출, S는 현재 0이므로 무한히 반복하며 S 확인
4. 프로세스 P1 임계 구역 작업 종료, signal() 호출, S를 1 증가
5. 프로세스 P3 S가 1이 됨을 확인, S는 현재 1이므로 S를 1 감소시키고 임계 구역 진입

여기서 한 가지 문제가 있다. 이는 앞서 알아본 뮤텍스 락에도 해당되는 문제인데, 사용할 수 있는 공유 자원이 없는 경우 프로세스는 무작정 무한히 반복하며 S를 확인해야 한다. 이는 마치 탈의 실 문이 잠겨 있는지 아닌지 계속 반복해서 확인하는 것과 같다. 이렇게 바쁜 대기를 반복하며 확인할 시간에 CPU는 더 생산성 있는 작업을 할 수 있을 텐데, CPU 주기를 낭비한다는 점에서 손해이다.

그래서 실제로 세마포는 다른 더 좋은 방법을 사용한다. wait 함수는 만일 사용할 수 있는 자원이 없을 경우 해당 프로세스 상태를 대기 상태로 만들고, 그 프로세스의 PCB를 세마포를 위한 대기 큐에 집어넣는다. 그리고 다른 프로세스가 임계 구역에서의 작업이 끝나고 signal 함수를 호출하면 signal 함수는 대기 중인 프로세스를 대기 큐에서 제거하고, 프로세스 상태를 준비 상태로 변경한 뒤 준비 큐로 옮겨준다.

이를 간단한 코드로 나타내면 아래와 같다.

```js
wait(){
	S--;
	if(S < 0){
		//add this process to Queue; // 1번
		sleep();                     // 2번
	}
}
```

1. 해당 프로세스 PCB를 대기 큐에 삽입한다.
2. 대기 상태로 접어든다.

```js
signal(){
	S++;
	if(S <= 0){
		//remove a process p from Queue; // 1번
		wakeup(p);                       // 2번
	}
}
```

1. 대기 큐에 있는 프로세스 p를 제거한다.
2. 프로세스 p를 대기 상태에서 준비 상태로 만든다.

예시를 통해 알아보자. 앞선 예시와 마찬가지로 공유 자원은 두 개 , 접근하려는 프로세스는 P1, P2, P3 세 개이고, P1, P2, P3 순서로 임계 구역에 접근한다고 가정해 보자. 공유 자원이 두 개이니 S는 2이다.

![세마포.001.jpeg](<images/세마포.001.jpeg>)

1. 프로세스 P1 wait 호출, S를 1 감소시키면 S는 1이므로 임계 구역 진입
2. 프로세스 P2 wait 호출, S를 1 감소시키면 S는 0이므로 임계 구역 진입
3. 프로세스 P1 wait 호출, S를 1 감소시키면 S는 -1이므로 본인의 PCB를 대기 큐에 넣고 대기 상태로 전환
4. 프로세스 P1 임계 구역 작업 종료, signal() 호출, S를 1 증가하면 0이므로 대기 상태였던 P3를 대기 큐에서 꺼내 준비 큐로 옮겨줌
5. 깨어난 프로세스 P3 임계 구역 진입
6. 프로세스 P2 임계 구역 작업 종료, signal() 호출, S가 1 증가하면 1
7. 프로세스 P3 임계 구역 작업 종료, signal() 호출, S가 1 증가하면 2

위 과정을 외울 필요는 없다. 변수 S가 무엇을 의미하는지, wait, signal 함수의 코드가 무엇을 의미하는지만 안다면 위 과정과 그림은 충분히 그릴 수 있다.

지난 글에서 동기화의 정의에 대해 알아봤을 때 '동시에 접근해서는 안 되는 자원에 동시에 접근하지 않도록 제어하는 것'도 동기화 (상호 배제를 위한 동기화) 이지만, '특정 조건이 만족되어야만 실행할 수 있는 상황에서 올바른 순서대로 실행하게 하는 것' 또한 동기화 (실행 순서 제어를 위한 동기화) 라고 했다. 지금까지 설명한 내용은 세마포를 이용한 상호 배제를 위한 동기화 기법이었다면 이번에는 세마포를 이용해 프로세스의 순서를 제어하는 방법에 대해 알아보자. 세마포를 이용하면 동시에 실행되는 프로세스의 실행 순서도 원하는 대로 제어할 수 있다.

방법은 간단하다. 세마포의 변수 S를 0으로 두고 먼저 실행할 프로세스 뒤에 signal 함수, 다음에 실행할 프로세스 앞에 wait 함수를 붙이면 된다.

![세마포.002.jpeg](<images/세마포.002.jpeg>)

이 경우 P1이 먼저 실행되면 P1이 임계 구역에 먼저 진입하는 것은 자명한 일이고, P2가 먼저 실행 되더라도 P2는 wait 함수를 만나므로 P1이 임계 구역에 진입한다. 그리고 P1이 임계 구역의 실행을 끝내고 signal을 호출하면 그제서야 P2가 임계 구역에 진입한다. 즉, P1이 먼저 실행되든 P2가 먼저 실행되든 반드시 P1, P2 순서대로 실행된다.