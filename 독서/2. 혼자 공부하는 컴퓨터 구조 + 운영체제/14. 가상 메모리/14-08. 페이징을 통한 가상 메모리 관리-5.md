### 페이징의 이점 - 쓰기 시 복사
외부 단편화 문제를 해결한다는 점 이외에도 페이징이 제공하는 이점은 다양하다. 대표적인 것이 프로세스 간에 페이지를 공유할 수 있다는 점이다. 프로세스 간 페이지를 공유하는 사례로는 공유 라이브러리 등 다양하지만, 대표적인 예시로 `쓰기 시 복사 (copy on write)`가 있다.

이전에 멀티프로세스를 설명했을 때 '프로세스를 fork하여 동일한 프로세스 두 개가 복제되면 코드 및 데이터 영역을 비롯한 모든 자원이 복제되어 메모리에 적재된다'라고 했다. 그러고는 '프로세스를 통째로 메모리에 중복 저장하지 않으면서 프로세스끼리 자원을 공유하지 않는 방법도 있다'는 말도 했다.

유닉스나 리눅스와 같은 운영체제에서 fork 시스템 호출을 하면 부모 프로세스의 복사본이 자식 프로세스로서 만들어진다. '프로세스 간에는 기본적으로 자원을 공유하지 않는다'는 프로세스의 전통적인 개념에 입각하면 새롭게 생성된 자식 프로세스의 코드 및 데이터 영역은 부모 프로세스가 적재된 메모리 공간과는 전혀 다른 메모리 공간에 생성된다. 한 마디로 부모 프로세스의 메모리 영역이 다른 영역에 자식 프로세스로서 복제되고, 각 프로세스의 페이지 테이블은 자신의 고유한 페이지가 할당된 프레임을 가리킨다. 하지만 이 복사 작업은 프로세스 생성 시간을 늦출 뿐만 아니라 불필요한 메모리 낭비를 야기한다.

![페이징 이점 - 쓰기 시 복사.001.jpeg](<images/페이징 이점 - 쓰기 시 복사.001.jpeg>)

반면 쓰기 시 복사에서는 부모 프로세스와 동일한 자식 프로세스가 생성되면 다음 그림과 같이 자식 프로세스로 하여금 부모 프로세스와 동일한 프레임을 가리킨다. 이로써 굳이 부모 프로세스의 메모리 공간을 복사하지 않고도 동일한 코드 및 데이터 영역을 가리킬 수 있다. 만일 부모 프로세스와 자식 프로세스가 메모리에 어떠한 데이터도 쓰지 않고 그저 읽기 작업만 이어 나간다면 이 상태가 지속된다.

![페이징 이점 - 쓰기 시 복사.002.jpeg](<images/페이징 이점 - 쓰기 시 복사.002.jpeg>)

그런데 프로세스 간에는 자원을 공유하지 않는다고 했다. 부모 프로세스 혹은 자식 프로세스 둘 중 하나가 페이지에 쓰기 작업을 하면 그 순간 해당 페이지가 별도의 공간으로 복제된다. 각 프로세스는 자신의 고유한 페이지가 할당된 프레임을 가리킨다. 이것이 `쓰기 시 복사`이다. 이러한 쓰기 시 복사를 통해 프로세스 생성 시간을 줄이는 것은 물론 메모리 공간 절약도 가능하다.

![페이징 이점 - 쓰기 시 복사.003.jpeg](<images/페이징 이점 - 쓰기 시 복사.003.jpeg>)

