### 계층적 페이징
페이지 테이블의 크기는 생각보다 작지 않다. 프로세스의 크기가 커지면 자연히 프로세스 테이블의 크기도 커지기 때문에 프로세스를 이루는 모든 페이지 테이블 엔트리를 메모리에 두는 것은 큰 메모리 낭비이다. 이에 프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않을 수 있는 방법이 등장했는데, 이것이 `계층적 페이징 (hierarchical paging)`이다. 

계층적 페이징은 페이지 테이블을 페이징하여 여러 단계의 페이지를 두는 방식이다. 여러 단계의 페이지를 둔다는 점에서 `다단계 페이지 테이블 (multilevel page table)`기법이라고도 부른다. 프로세스의 페이지 테이블을 여러 개의 페이지로 자르고, 바깥쪽에 페이지 테이블을 하나 더 두어 잘린 페이지 테이블의 페이지들을 가리키게 하는 방식이다. 간단하다. 한 프로세스의 페이지 테이블이 다음과 같다고 가정하자. 계층적 페이징 기법을 사용하지 않으면 이 프로세스 테이블은 전체가 메모리에 있어야 한다.

![계층적 페이징.001.jpeg](<images/계층적 페이징.001.jpeg>)

이 페이지 테이블을 여러 개의 페이지로 쪼개고, 이 페이지들을 가리키는 페이지 테이블 (그림속 Outer 페이지 테이블)을 두는 방식이 계층적 페이징이다.

![계층적 페이징.002.jpeg](<images/계층적 페이징.002.jpeg>)

페이지 테이블을 이렇게 계층적으로 구성하면 모든 페이지 테이블을 항상 메모리에 유지할 필요가 없다. 페이지 테이블들 중 몇 개는 보조기억장치에 있어도 무방하며, 추후 해당 페이지 테이블을 참조해야 할 때가 있으면 그때 메모리에 적재하면 그만이다. 막대한 크기의 페이지 테이블로 인해 낭비되는 공간을 줄일 수 있다. 다만 CPU와 가장 가까이 위치한 페이지 테이블(Outer 페이지 테이블)은 항상 메모리에 유지해야 한다.

계층적 페이징을 사용하는 경우 CPU가 발생하는 논리 주소도 달라진다. 계층적 페이징을 사용하지 않을 경우 논리 주소는 앞서 살펴봤듯이 다음과 같은 형태로 만들어진다.

![계층적 페이징.003.jpeg](<images/계층적 페이징.003.jpeg>)

하지만 계층적 페이징을 이용하는 환경에서의 논리 주소는 아래와 같은 형태로 만들어진다. `바깥 페이지 번호`에 해당하는 항목은 CPU와 근접한 곳에 위치한(바깥에 위치한) 페이지 테이블 엔트리를 가리키고, `안쪽 페이지 번호`는 첫 번째 페이지 바깥에 위치한 두 번째 페이지 테이블, 즉 페이지 테이블의 페이지 번호를 가리킨다.

![계층적 페이징.004.jpeg](<images/계층적 페이징.004.jpeg>)

어러한 논리 주소를 토대로 주소 변환은 다음과 같이 이루어진다.

1. 바깥 페이지 번호를 통해 `페이지 테이블의 페이지`를 찾기
2. `페이지 테이블의 페이지`를 통해 `프레임 번호`를 찾고 변위를 더함으로서 물리 주소 얻기

![계층적 페이징.005.jpeg](<images/계층적 페이징.005.jpeg>)

위에서는 두 개의 계층으로 페이지 테이블을 구성하는 (2단계 페이징) 예시를 들었으나 페이지 테이블의 계층은 세 개, 네 개, 그 이상의 계층으로도 구성될 수 있다. 다만 페이지 테이블의 계층이 늘어날수록 페이지 폴트가 발생했을 경우 메모리 참조 횟수가 많아지므로 계층이 많다고 해서 반드시 좋다고 볼 수는 없다.