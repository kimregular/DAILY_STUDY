### 페이지 테이블
그런데 여기서 문제가 있다. 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행할 수가 없다. 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 모두 알고 있기란 어렵기 때문이다. 즉, 프로세스가 메모리에 불연속적으로 배치되면 CPU 입장에서 '다음에 실행할 명령어 위치'를 찾기가 어려워진다.

이를 해결하기 위해 페이징 시스템은 프로세스가 비록 (실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라도 (CPU가 바라보는 주소인) 논리 주소에는 연속적으로 배치되도록 `페이지 테이블 (page table)`을 이용한다.

페이지 테이블은 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표이다. CPU로 하여금 페이지 번호만 보고 해당 페이지가 적재된 프레임을 찾을 수 있게 한다. 다시 말해 페이지 테이블은 현재 어떤 페이지가 어떤 프레임에 할당되었는지를 알려준다.

프로세스마다 각자의 프로세스 테이블이 있다. 가령 프로세스 A의 페이지 테이블이 아래와 같다면 CPU는 이를 보고 '0번 페이지는 3번 프레임에, 1번 페이지는 5번 프레임에, 2번 페이지는 2번 프레임에 할당되어 있다'라는 사실을 알 수 있다.

![페이지 테이블.001.jpeg](<images/페이지 테이블.001.jpeg>)

위와 같은 방식으로 비록 물리 주소상에서는 프로세스들이 분산되어 저장되어 있더라도 CPU 입장에서 바라본 논리 주소는 연속적으로 보일 수 있다. 즉 프로세스들이 메모리에 분산되어 저장되어 있더라도 CPU는 논리 주소를 그저 순차적으로 실행하면 된다.

![페이지 테이블.002.jpeg](<images/페이지 테이블.002.jpeg>)

#### 내부 단편화
페이징은 외부 단편화 문제를 해결할 수 있지만, `내부 단편화 (internal fragmentation)`라는 문제를 야기할 수 있다. 페이징은 프로세스의 논리 주소 공간을 페이지라는 일정한 크기 단위로 자른다. 그런데 모든 프로세스가 페이지 크기에 딱 맞게 잘리는 것은 아니다. 다시 말해 모든 프로세스 크기가 페이지의 배수는 아니다. 가령 페이지 크기가 10KB인데, 프로세스의 크기가 108KB라고 해보자. 이 경우 마지막 페이지는 2KB만큼의 크기가 남는다. 이러한 메모리 낭비를 내부 단편화라고 한다.

내부 단편화는 하나의 페이지 크기보다 작은 크기로 발생한다. 그렇기에 하나의 페이지 크기가 작다면 발생하는 내부 단편화의 크기는 작아질 것으로 기대할 수 있다. 하지만 하나의 페이지 크기를 너무 작게 설정하면 그만큼 페이지 테이블의 크기도 커지기 때문에 페이지 테이블이 차지하는 공간이 낭비된다. 그렇기에 내부 단편화를 적당히 방지하면서 너무 크지 않은 페이지 테이블이 만들어지도록 페이지의 크기를 조정하는 것이 중요하다. 참고로, 리눅스의 경우 아래와 같이 간단한 명령으로 페이지 크기를 알아낼 수 있다.

```linux
[root@localhost ~]# getconf PAGESIZE
4096
```

참고로 리눅스를 포함한 일부 운영체제에서는 위와 같이 기본적으로 설정된 페이지 크기보다 더 큰 크기의 페이지도 일부 허용하여 메모리에 유지하는 경우도 있다. 기본적으로 설정된 페이지보다 큰 페이지를 대형 페이지(huge page)라고 한다.

### 

프로세스마다 각자의 프로세스 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적대되어 있다. 그리고 CPU 내의 `페이지 테이블 베이스 레지스터 (PTBR : Page Table Base Register)`는 각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있다.

예를 들어 프로세스 A가 실행될 때 PTBR은 프로세스 A의 페이지 테이블을 가리키고, CPU는 프로세스 A의 페이지 테이블을 통해 프로세스 A의 페이지가 적재된 프레임을 알 수 있다. 마찬가지로 프로세스 B가 실행될 때는 PTBR이 프로세스 B의 페이지 테이블을 가리키고 CPU는 프로세스 B의 페이지 테이블을 통해 프로세스 B의 페이지가 적재된 프레임을 알 수 있다. 이러한 각 프로세스들의 페이지 테이블 정보들은 각 프로세스의 PCB에 기록된다. 그리고 프로세스의 문맥 교환이 일어날 때 다른 레지스터와 마찬가지로 함께 변경된다.

![페이지 테이블.003.jpeg](<images/페이지 테이블.003.jpeg>)

그런데 이렇게 페이지 테이블을 메모리에 두면 문제가 있다. 메모리 접근 시간이 두 배로 늘어난다는 점이다. 메모리에 있는 페이지 테이블을 보기 위해 한 번, 그렇게 알게 된 프레임에 접근하기 위해 한 번, 이렇게 총 두 번의 메모리 접근이 필요하기 때문이다.

![페이지 테이블.004.jpeg](<images/페이지 테이블.004.jpeg>)

이와 같은 문제를 해결하기 위해 CPU 곁에 (일반적으로 MMU 내에) `TLB (Translation Lookaside Buffer)`라는 페이지 테이블의 캐시 메모리를 둔다. 컴퓨터의 CPU 곁에는 TLB가 있다. TLB는 페이지 테이블의 캐시이기 때문에 페이지 테이블의 일부 내용을 저장한다. 참조 지역성에 근거해 주로 최근에 사용된 페이지 위주로 가져와 저장한다.

![페이지 테이블.005.jpeg](<images/페이지 테이블.005.jpeg>)

CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우 이를 `TLB히트`라고 한다. 이 경우에는 페이지가 적재된 프레임을 알기 위해 메모리에 접근할 필요가 없다. 그렇기에 메모리 접근을 한 번만 하면 된다. 하지만 만일 페이지 번호가 TLB에 없을 경우 어쩔 수 없이 페이지가 적재된 프레임을 알기 위해 메모리 내의 페이지 테이블에 접근하는 수밖에 없다. 이를 `TLB 미스`라고 한다.

![페이지 테이블.006.jpeg](<images/페이지 테이블.006.jpeg>)

