### 페이지 교체 알고리즘
좋은 페이지 교체 알고리즘은 무엇일까? 일반적으로 페이지 포트를 가장 적게 일으키는 알고리즘을 좋은 알고리즘으로 평가한다. 페이지 폴트가 일어나면 보조기억장치로부터 필요한 페이지를 가져와야 하기 때문에 메모리에 적재된 페이지를 가져오는 것보다 느려지기 때문이다. 

가령 한 알고리즘을 통해 고른 페이지를 스왑 아웃시켰을 때 페이지 폴트가 자주 발생하면 이는 좋은 알고리즘이 아니다. "한 페이지 교체 알고리즘을 선택했더니 페이지 폴트가 자주 발생했다"는 말은 "보조기억장치로 내쫓을 페이지를 잘못 골랐다"는 뜻으로, 내보내면 안 되는 페이지를 보조기억장치로 내보냈다는 의미와 같기 때문이다. 이는 당연히 컴퓨터의 성능을 저해하는 나쁜 알고리즘일 것이다. 반면 어떤 알고리즘을 통해 고른 페이지를 스왑 아웃시켜도 페이지 폴트가 자주 발생하지 않는다면 이는 컴퓨터의 성능 저하를 방지하는 좋은 알고리즘으로 평가할 수 있다.

그렇기에 페이지 교체 알고리즘을 제대로 이해하려면 `페이지 폴트 횟수`를 알 수 있어야 한다. 그리고 페이지 폴트 횟수는 `페이지 참조열 (page reference string)`을 통해 알 수 있다. 페이지 참조열의 개념은 간단하다. CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열을 의미한다. 가령 CPU가 아래와 같은 순서로 페이지에 접근했다고 가정한다.

> 2 2 2 3 5 5 5 3 3 7

여기서 연속된 페이지를 생략한 페이지열, 다시 말해 아래 숫자열이 페이지 참조열이다.

> 2 3 5 3 7

연속된 페이지를 생략하는 이유는 중복된 페이지를 참조하는 행위는 페이지 폴트를 발생시키지 않기 때문이다. CPU가 특정 페이지에 열 번 연속으로 접근한다고 해서 한 번 접근하는 것보다 페이지 폴트가 많이 발생하지 않는 것처럼 말이다. 페이지 교체 알고리즘을 평가할 때 관심있게 고려할 것은 오직 페이지 폴트의 발생 횟수이기 때문에 어차피 페이지 폴트가 일어나지 않을 연속된 페이지에 대한 참조는 고려하지 않는다. 자, 이제 대표적인 페이지 교체 알고리즘에 대해 하나씩 알아보고 페이지 참조열을 바탕으로 각 알고리즘들의 성능을 평가해 보자.

#### FIFO 페이지 교체 알고리즘
첫 번째로 소개할 알고리즘은 `FIFO 페이지 교체 알고리즘 (First-In First-Out Page Replacement Algorithm)`이다. 이는 가장 단순한 방법이다. 이름 그대로 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식으로, 쉽게 말해 "오래 머물렀다면 나가라"는 알고리즘이다.

예제를 통해 조금 더 자세히 알아보자. 가령 프로세스가 사용할 수 있는 프레임이 세 개 있다고 가정하고 페이지 참조열이 아래와 같다고 해보자.

> 2 3 1 3 5 2 3 4 2 3

그렇다면 FIFO 페이지 교체 알고리즘은 아래와 같은 순서대로 진행되어 총 네 번의 페이지 폴트가 발생한다. 페이지가 초기에 적재될 때 발생할 수 있는 페이지 폴트는 고려하지 않고, 적재된 페이지를 교체하기 위해 발생한 페이지 폴트만을 페이지 폴트로 간주했다.

![페이지 교체 알고리즘.001.jpeg](<images/페이지 교체 알고리즘.001.jpeg>)

FIFO 페이지 교체 알고리즘은 아이디어와 구현이 간단하지만, 마냥 좋은 것은 아니다. 프로그램 실행 초기에 적재된 페이지 속에는 프로그램 실행 초기에 잠깐 실행되다가 이후에 사용되지 않을 페이지도 있겠지만, 프로그램 실행 내내 사용될 내용을 포함하고 있을 수도 있다. 이런 페이지는 메모리에 먼저 적재되었다고 해서 내쫓아서는 안 된다.

#### 2차 기회 페이지 교체 알고리즘
FIFO 페이지 교체 알고리즘은 자칫 자주 참조되는 페이지가 먼저 적재되었다는 이유만으로 내쫓길 수 있다는 문제가 있었다. `2차 기회 페이지 교체 알고리즘 (second chance page replacement algorithm)`은 이러한 부작용을 어느 정도 개선한 FIFO 페이지 교체 알고리즘의 변형이다. 이름 그대로 한 번 더 기회를 주는 알고리즘이다.

2차 기회 페이지 교체 알고리즘은 FIFO 페이지 교체 알고리즘과 같이 기본적으로 메모리에서 가장 오래 머물었던 페이지를 대상으로 내보낼 페이지를 선별한다. 차이가 있다면 만일 페이지의 참조 비트가 1일 경우, 당장 내쫓지 않고 참조 비트를 0으로 만든 뒤 현재 시간을 적재 시간으로 설정한다. 메모리에 가장 오래 머물렀다고 할지라도 참조 비트가 1이라는 의미는 CPU가 접근한 적이 있다는 의미이므로 한 번의 기회를 더 주는 셈이다. 메모리에 가장 오래 머무른 페이지의 참조 비트가 0일 경우 이 페이지는 가장 오래된 페이지이면서 동시에 사용되지 않은 페이지라고 볼 수 있으므로 보조기억장치로 내보내면 된다.

예를 들어보자. 다섯 개의 프레임을 가진 메모리에 페이지가 3, 1, 5, 2, 4 순으로 적재되었고, 각각의 참조 비트가 아래 그림과 같다고 가정한다.

![페이지 교체 알고리즘.002.jpeg](<images/페이지 교체 알고리즘.002.jpeg>)

이런 상황에서 페이지 6이 새롭게 적재되어야 한다고 하자. 기존 FIFO 페이지 교체 알고리즘대로였다면 보조기억장치로 내보낼 페이지는 페이지 3이다. 하지만 2차 기화 페이지 교체 알고리즘은 페이지 3의 참조 비트를 보고, 1일 경우 이를 0으로 변경한 뒤 최근에 적재된 페이지로 간주한다. 한 번의 기회를 더 주는 것이다.

![페이지 교체 알고리즘.003.jpeg](<images/페이지 교체 알고리즘.003.jpeg>)

위 그림에 따르면 다음으로 가장 오랫동안 메모리에 머물렀던 페이지는 페이지 1이다. 참조 비트가 0임을 볼 수 있다. 즉, 페이지 1은 오랫동안 메모리에 머물러 있었으면서 동시에 CPU가 접근하지 않은 페이지인 셈이다. 이 경우 페이지 1을 내보내고 페이지 1이 적재되었던 프레임에 페이지 6을 적재하면 된다.

#### 최적 페이지 교체 알고리즘
최적 페이지 교체 알고리즘은 CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘이다. 잘 생각해 보면 메모리에 오랫동안 남아야 할 페이지는 자주 사용될 페이지고, 반대로 메모리에 없어도 될 페이지는 오랫동안 사용되지 않을 페이지인데, 오랜 기간 메모리에 있었던 페이지라고 해서 보조기억장치로 내쫓는 건 비합리적이라고 볼 수 있다. 

따라서 보조기억장치로 내보내야 할 페이지는 앞으로 사용 빈도가 가장 낮은 페이지이므로, 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘을 페이지 교체 알고리즘으로 삼는 것이 가장 합리적이다. 이 알고리즘이 `최적 페이지 교체 알고리즘 (optimal page replacement algorithm)`이다. 

위의 예시를 다시 가져오자. 프로세스가 사용할 수 있는 프레임이 세 개 있고, 페이지 참조열이 아래와 같다.

> 2 3 1 3 5 2 3 4 2 3

최적 페이지 교체 알고리즘은 아래 그림과 같이 총 두 번의 페이지 폴트가 발생한다. FIFO 알고리즘에 비하면 페이지 폴트 빈도가 훨씬 낮아진 것을 확인할 수 있다.

![페이지 교체 알고리즘.004.jpeg](<images/페이지 교체 알고리즘.004.jpeg>)

최적 페이지 교체 알고리즘은 이름 그대로 가장 낮은 페이지 폴트율을 보장하는 알고리즘이다. 그렇기에 최적 페이지 교체 알고리즘은 위 예시뿐 아니라 다른 페이지 참조열을 바탕으로 실행해 보아도 타 페이지 교체 알고리즘에 비해 페이지 폴트 발생 빈도가 가장 낮다.

다만, 최적 페이지 교체 알고리즘은 실제 구현이 어렵다. 최적 페이지 교체 알고리즘은 앞으로 오랫동안 사용되지 않을 페이지를 내보내는 알고리즘이다. 하지만 '앞으로 오랫동안 사용되지 않을 페이지'를 예측하기란 어렵다. 프로세스가 앞으로 메모리 어느 부분을 어떻게 참조할지 미리 알아야 하는데, 이는 현실적으로 불가능에 가깝기 때문이다. 따라서 최적 페이지 교체 알고리즘은 그 자체를 운영체제에서 사용하기보다는, 주로 다른 페이지 교체 알고리즘의 이론상 성능을 평가하기 위한 목적으로 사용된다. 즉, 최적 페이지 교체 알고리즘을 실행했을 때 발생하는 페이지 폴트 횟수를 페이지 폴트의 하한선으로 간주하고, 최적 페이지 교체 알고리즘에 비해 얼만큼 페이지 폴트 횟수가 발생하느냐를 통해 페이지 교체 알고리즘을 평가하기 위해 사용한다.

#### LRU 페이지 교체 알고리즘
최적 페이지 교체 알고리즘은 구현하기 어려워도 이와 비슷한 알고리즘은 만들 수 있다. 가장 오랫동안 사용되지 '않을' 페이지를 교체하는 알고리즘을 구현하기 어렵다면, 이를 조금 변형한 가장 오랫동안 사용되지 '않은' 페이지를 교체하는 알고리즘은 구현이 가능하다. 이 알고리즘이 `LRU 페이지 교체 알고리즘 (LRU : Least Recently Used Page Replacement Algorithm)`이다.

LRU 페이지 교체 알고리즘은 '최근에 사용되지 않은 페이지는 앞으로도 사용도지 않을 것'이라는 아이디어로를 토대로 만들어진 알고리즘이다. 페이지마다 마지막으로 사용한 시간을 토대로 최근에 가장 사용이 적었던 페이지를 교체한다. 최적 페이지 교체 알고리즘에서 사용한 예시를 다시 사용하겠다. LRU 알고리즘은 다음과 같이 작동한다. 이 예시에서는 페이지 폴트가 3회 발생했다.

![페이지 교체 알고리즘.005.jpeg](<images/페이지 교체 알고리즘.005.jpeg>)

이외에도 페이지 교체 알고리즘의 종류는 매우 다양하다. 바로 위에서 설명한 LRU 페이지 교체 알고리즘만 하더라도 많은 파생 알고리즘이 있다. 다만 페이지 교체 알고리즘을 처음 접하면 페이지 교체 알고리즘을 단순 암기하기 보다는 페이지 교체 알고리즘을 왜 사용하는지, 무엇이 좋은 페이지 교체 알고리즘인지, 대표적인 페이지 교체 알고리즘들의 기본적인 아이디어는 무엇인지를 이해하는 데에 중점을 두자.

