### 외부 단편화
프로세스를 메모리에 연속적으로 배치하는 연속 메모리 할당은 언뜻 들으면 당연하게 느껴질 수 있지만, 사실 이는 메모리를 효율적으로 사용하는 방법이 아니다. 왜냐하면 연속 메모리 할당은 `외부 단편화 (external fragmentation)`라는 문제를 내포하고 있기 때문이다. 외부 단편화가 무엇이며 왜 발생하는지 알아보자.

아무런 프로세스도 적재되지 않은 상태의 메모리 전체를 그려보면 아래 그림과 같이 표현할 수 있다. 운영체제 영역에는 운영체제가 적재되어 있고, 사용자 영역에는 어떠한 프로세스도 적재되어 있지 않다.

![외부 단편화.001.jpeg](<images/외부 단편화.001.jpeg>)

이제 사용자 영역에 하나둘씩 프로세스들이 적재되는 상황을 상상해보자. 설명의 편의를 위해 사용자 영역의 크기는 200MB이라고 가정한다. 사용자 영역에 크기가 50MB인 프로세스 A, 30MB인 프로세스 B, 100MB인 프로세스 C, 20MB인 프로세스 D를 차례대로 적재해야 한다면 이 프로세스들을 메모리에 어떻게 배치하는 것이 좋을까? 간단히 생각해 보았을 때 아래와 같이 적재할 수 있다.

![외부 단편화.002.jpeg](<images/외부 단편화.002.jpeg>)

이제 프로세스 B와 D의 실행이 끝났다고 하자. 이 프로세스들은 더 이상 메모리에 남아 있을 필요가 없다. 프로세스 B와 D가 메모리를 떠나면 아래와 같이 프로세스 B와 D가 있던 자리에는 빈 공간이 생긴다.

![외부 단편화.003.jpeg](<images/외부 단편화.003.jpeg>)

현재 메모리에 남아 있는 빈 공간의 총합은 몇 MB일까? 너무 당연한 질문이다. 답은 50MB이다.

그렇다면 위 그림과 같은 상황에서 50MB 크기의 프로세스를 적재할 수 있을까? 불가능하다. 빈 공간의 총합은 50MB일지라도 어느 빈 공간에도 50MB 크기의 프로세스가 적재될 수 없기 때문이다. 

프로세스들이 메모리에 연속적으로 할당되는 환경에서는 위와 같이 프로세스들이 실행되고 종료되기를 반복하며 메모리 사이 사이에 빈 공간들이 생긴다. 프로세스 바깥에 생기는 이러한 빈 공간들은 분명 빈 공간이지만 그 공간보다 큰 프로세스를 적재하기 어려운 상황을 초래하고, 결국 메모리 낭비로 이어진다. 이러한 현상을 `외부 단편화 (external fragmentation)`라고 한다.

앞서 살펴본 스와핑과 메모리 할당을 설명한 예시에서도 외부 단편화는 발생했다. 프로세스 B가 스왑 아웃되고 프로세스 B보다 작은 프로세스 D가 적재되었을 때 외부 단편화가 발생하는 것을 볼 수 있다. 아래 그림에서 검은색으로 칠한 부분이 외부 단편화가 발생한 부분이다.

![외부 단편화.004.jpeg](<images/외부 단편화.004.jpeg>)

아래 그림을 보자. '적재할 프로세스' 바로 아래에 작은 빈 공간이 생겼다. 이또한 외부 단편화가 발생한 예라고 볼 수 있다.

![외부 단편화.005.jpeg](<images/외부 단편화.005.jpeg>)

앞 예시들에서는 메모리에 프로세스가 몇 개 없는 간단한 상황을 가정했기에 외부 단편화가 큰 문제가 아닌 것처럼 보일 수 있지만, 실제로는 이보다 메모리 용량도 크고 적재되는 프로세스도 많기 때문에 외부 단편화로 인해 낭비되는 공간은 더욱 크다. 그렇기에 외부 단편화 문제는 반드시 해결해야 할 문제이다. 

외부 단편화를 해결할 수 있는 대표적인 방안으로 메모리를 `압축 (compaction)`하는 방법이 있다. 메모리 조작 모음이라고도 부른다. 압축은 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식으로 메모리 내에 저장된 프로세스를 적당히 재배치시켜 여기저기 흩어져 있는 작은 빈 공간들을 하나의 큰 빈공간으로 만드는 방법이다.

![외부 단편화.006.jpeg](<images/외부 단편화.006.jpeg>)

다만 압축 방식은 여러 단점이 있다. 작은 빈 공간들을 하나로 모으는 동안 시스템은 하던 일을 중지해야 하고, 메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기하며, 어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화하며 압축할 수 있는지에 대한 명확한 방법을 결정하기 어렵다. 이에 외부 단편화를 없앨 수 있는 또 다른 해결 방안이 등장했는데, 이것이 오늘날까지도 사용되는 가상 메모리 기법, 그 중에서도 페이징 기법이다.