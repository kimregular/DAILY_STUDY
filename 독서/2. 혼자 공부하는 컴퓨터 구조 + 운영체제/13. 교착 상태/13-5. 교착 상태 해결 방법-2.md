### 교착 상태 회피
`교착 상태 회피`는 교착 상태가 발생하지 않을 정도로만 조심 조심 자원을 할당하는 방식이다. 교착 상태 회피 방식에서는 교착 상태를 한정된 자원의 무분별한 할당으로 인해 발생하는 문제로 간주한다.

프로세스들에 할당할 수 있는 자원이 충분한 상황에서 프로세스들이 한두 개의 적은 자원만을 요구한다면 교착 상태는 발생하지 않는다. 반면 프로세스들에 할당할 수 있는 자원이 한정된 상황에서 모든 프로세스들이 한 번에 많은 자원을 요구하면 교착 상태가 발생할 위험이 증가한다.

식사하는 철학자 문제를 생각해보자. 포크가 100개, 1000개 있는 상태에서 철학자들이 한두 개의 포크를 요구하면 교착 상태는 발생하지 않는다. 반면 포크의 양이 충분하지 않은 상태에서 철학자들이 모두 자신이 요구할 수 있는 최대의 포크(두 개)를 요구하면 교착 상태가 발생한다.

그렇기 때문에 프로세스들에 배분할 수 있는 자원의 양을 고려하여 교착 상태가 발생하지 않을 정도의 양만큼만 자원을 배분하는 방법이 교착 상태 회피이다.

교착 상태를 회피하는 방법을 학습하기 위해서는 안전 상태와 불안전 상태, 그리고 안전 순서열이라는 용어를 알아야 한다.교착 상태가 발생하지 않고 모든 프로세스가 정상적으로 자원을 할당받고 종료될 수 있는 상태를 `안전 상태 (safe state)`라고 부르고, 교착 상태가 발생할 수도 있는 상황을 `불안전 상태 (unsafe state)`라고 부른다.

`안전 순서열 (safe sequence)`은 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서를 의미한다. 예를 들어 웹 브라우저, 메모장, 게임 프로세스가 동시에 운영체제에 자원을 요청한 상황에서 웹 브라우저-메모장-게임 프로세스 순서대로 자원을 할당하면 교착 상태가 발생하지 않는다고 가정하자. 이 경우 웹 브라우저 -> 메모장 -> 게임이 안전 순서열이 된다. 안전 순서열이 있는 상태를 안전 상태라고 볼 수 있다.

이렇게 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서를 안전 순서열이라고 하고 안전 순서열대로 프로세스들에 자원을 배분하여 교착 상태가 발생하지 않는 상태를 `안전 상태`라고 한다.

반면 `불안전 상태`는 안전 순서열이 없는 상황이다. 시스템이 불안전 상태에 놓이면 교착 상태가 발생할 수 있는 위험이 있다.

안전 상태와 불안전 상태, 안전 순서열은 용어의 정의보다 예시를 통해 이해하는 것이 좋다. 가령 현재 컴퓨터 시스템에 총 열두 개의 어떠한 자원이 있고, P1, P2, P3 세 개의 프로세스가 실행 중이며, 각각 다섯 개, 두 개, 두 개의 자원을 할당받아 사용 중이라고 가정해 보자. 운영체제가 프로세스에 배분할 수 있는 자원을 세 개 남은 셈이다. 그리고 P1, P2, P3은 각각 최대 열 개, 네 개, 아홉 개의 자원을 요구할 수 있다고 가정해 보자.

프로세스와 스레드는 자원을 사용하기 위해 1. 우선 자원을 운영체제에게 요청하고, 2. 운영체제로부터 자원을 할당받아 사용하고, 3. 자원의 사용이 끝났다면 자원을 반환한다. 유의하자.

현재 상황은 아래와 같이 간단한 표로 표현할 수 있다.

|프로세스|요구량|현재 사용량|
|-----|-----|-----|
|P1|10|5|
|P2|4|2|
|P3|9|2|

- 할당 가능 자원 : 12
- 할당한 자원 (P1, P2, P3 현재 사용량의 총합) : 9
- 남은 자원 (할당 가능한 자원 - 할당한 자원) : 3

이 상태는 안전 상태이다. P2 -> P1 -> P3이라는 안전 순서열이 있기 때문이다.

프로세스 P1, P2, P3이 모두 최대로 자원을 요구한 최악의 상황(P1, P2, P3이 각각 다섯 개, 두 개, 일곱 개의 자원을 요구한 상황)을 가정해 보자.

P2는 이미 자원 두 개를 가지고 있으므로 남은 자원에서 두 개를 배분하면 된다.

|프로세스|요구량|현재 사용량|
|-----|-----|-----|
|P1|10|5|
|P2|4|2 + 2|
|P3|9|2|

- 할당 가능 자원 : 12
- 할당한 자원 (P1, P2, P3 현재 사용량의 총합) : 9 + 2 = 11
- 남은 자원 (할당 가능한 자원 - 할당한 자원) : 3 - 2 = 1

요구한 네 개의 자원을 할당받은 P2는 정상적으로 작업을 끝내고 가지고 있던 자원을 반환한다. 그러면 남은 자원은 다섯 개가 된다.

|프로세스|요구량|현재 사용량|
|-----|-----|-----|
|P1|10|5|
|~~P2~~|~~4~~|~~2 + 2~~|
|P3|9|2|

- 할당 가능 자원 : 12
- 할당한 자원 (P1, P2, P3 현재 사용량의 총합) : 11 - 4 = 7
- 남은 자원 (할당 가능한 자원 - 할당한 자원) : 1 + 4 = 5

이번에는 P1에 남은 자원 다섯 개를 할당하면 P1 또한 작업을 정상적으로 완료할 수 있다.

|프로세스|요구량|현재 사용량|
|-----|-----|-----|
|P1|10|5 + 5|
|~~P2~~|~~4~~|~~2 + 2~~|
|P3|9|2|

- 할당 가능 자원 : 12
- 할당한 자원 (P1, P2, P3 현재 사용량의 총합) : 7 + 5 = 12
- 남은 자원 (할당 가능한 자원 - 할당한 자원) : 5 - 5 = 0

P1이 작업을 정상적으로 마치고 자원을 반환하면 이제 P3에 자원을 할당하면 된다.

|프로세스|요구량|현재 사용량|
|-----|-----|-----|
|~~P1~~|~~10~~|~~5 + 5~~|
|~~P2~~|~~4~~|~~2 + 2~~|
|P3|9|2|

- 할당 가능 자원 : 12
- 할당한 자원 (P1, P2, P3 현재 사용량의 총합) : 12 - 10 = 2
- 남은 자원 (할당 가능한 자원 - 할당한 자원) : 0 + 10 = 10

즉, P2 -> P1 -> P3이라는 안전 순서열대로 자원을 배분하면 P1, P2, P3 모두 자원을 할당받고 교착 상태 없이 올바르게 작업을 마칠 수 있다.

이번에는 조금 다른 상황을 생각해보자. 앞서 언급했던 동일한 상황에서 이번에는 운영체제가 P3에 먼저 선뜻 자원을 하나 내주었다고 생각해 보자. 그러면 P1, P2, P3 세 개의 프로세스는 각각 다섯 개, 두 개, 세 개의 자원을 보유하게 되었고, 운영체제가 배분할 수 있는 자원은 두 개 남는다.

|프로세스|요구량|현재 사용량|
|-----|-----|-----|
|P1|10|5|
|P2|4|2|
|P3|9|3|

- 할당 가능 자원 : 12
- 할당한 자원 (P1, P2, P3 현재 사용량의 총합) : 10
- 남은 자원 (할당 가능한 자원 - 할당한 자원) : 2

이 상황은 불안정 상태이다. 즉, 교착 상태가 발생할 위험이 있다.

P1, P2, P3이 모두 최대로 자원을 요구한 최악의 상황(P1이 다섯 개, P2는 두 개, P3은 여섯 개의 자원을 요구한 상황)을 가정해 보자.

아래와 같이 P2에 두 개의 자원을 배분하여 P2 작업을 올바르게 끝낸다고 해도, P2 작업 이후 반환된 자원 네 개로는 P1의 요구도, P3의 요구도 들어줄 수 없다. P1과 P3은 서로가 보유하고 있는 자원만을 바라보며 무한정 기다릴 수밖에 없다. 불안전 상태로 교착 상태가 발생한 것이다.

|프로세스|요구량|현재 사용량|
|-----|-----|-----|
|P1|10|5|
|P2|4|2 + 2|
|P3|9|3|

- 할당 가능 자원 : 12
- 할당한 자원 (P1, P2, P3 현재 사용량의 총합) : 10 + 2 = 12
- 남은 자원 (할당 가능한 자원 - 할당한 자원) : 2 - 2 = 0


|프로세스|요구량|현재 사용량|
|-----|-----|-----|
|P1|10|5|
|~~P2~~|~~4~~|~~2 + 2~~|
|P3|9|2|

- 할당 가능 자원 : 12
- 할당한 자원 (P1, P2, P3 현재 사용량의 총합) : 12 - 4 = 8
- 남은 자원 (할당 가능한 자원 - 할당한 자원) : 0 + 4 = 4

즉, 운영체제가 교착 상태를 회피하기 위해서는 시스템 상태가 안전 상태에서 안전 상태로 움직이는 경우에만 자원을 할당하면 된다. 즉, 교착 상태 회피 방식은 항시 안전 상태를 유지하도록 자원을 할당하는 방식이라 보면 된다.