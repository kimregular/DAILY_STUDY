# 명령어의 구조 - 2

## 주소 지정 방식

명령어의 오퍼랜드 필드에 메모리나 레지스터의 주소를 담는 경우가 많다. 그래서 오퍼랜드 필드를 주소 필드라고도 부른다. 의문이 하나 든다.

> 왜 오퍼랜드 필드에 메모리나 레지스터의 주소를 담는거지? 그냥 <연산 코드, 연산 코드에 사용될 데이터> 형식으로 명령어를 구성하면 되지 않나?

굳이 주소를 넣는 이유는 명령어 길이 때문이다. 하나의 명령어가 n비트로 구성되고, 그중 연산 코드 필드가 m비트라고 가정해보자. 이때 오퍼랜드 필드에 가장 많은 공간을 할당할 수 있는 1-주소 명령어라 할지라도 오퍼랜드 필드의 길이는 연산 코드만큼의 길이를 뺀 n-m 비트가 된다. 2-주소 명령어, 3-주소 명령어라면 오퍼랜드 필드의 크기는 더욱 작아진다.

명령어의 크기가 16비트, 연산 코드 필드가 4비트인 2-주소 명령어에서는 오퍼랜드 필드당 6비트 정도밖에 남지 않는다. 즉, 하나의 오퍼랜드 필드로 표현할 수 있는 정보의 가짓수는 $2^6$ 개밖에 되지 않는다.

![명령어의 구조 1](<images/03-04. 명령어의 구조 - 2.001.jpeg>)

그리고 명령어의 크기가 16비트, 연산 코드 필드가 4비트인 3-주소 명령어에서는 오퍼랜드 필드당 4비트 정도밖에 남지 않는다. 이 경우 하나의 오퍼랜드 필드로 표현할 수 있는 정보의 가짓수는 2<sup>4</sup> 개밖에 없다.

![명령어의 구조 2](<images/03-04. 명령어의 구조 - 2.002.jpeg>)

하지만 만약 오퍼랜드 필드 안에 메모리 주소가 담긴다면 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다.

예를 들어 한 주소에 16비트를 저장할 수 있는 메모리가 있다. 이 메모리 안에 데이터를 저장하고, 오퍼랜드 필드 안에 해당 메모리 주소를 명시한다면 표현할 수 있는 정보의 가짓수가 2<sup>16</sup> 으로 확 커지게 된다.

![명령어의 구조 3](<images/03-04. 명령어의 구조 - 2.003.jpeg>)

오퍼랜드 필드에 메모리 주소가 아닌 레지스터 이름을 명시할 때도 마찬가지이다. 이 경우 표현할 수 있는 가짓수는 해당 레지스터가 저장할 수 있는 공간만큼 커진다.

![명령어의 구조 4](<images/03-04. 명령어의 구조 - 2.004.jpeg>)

연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치를 `유효 주소(effective address)` 라고 한다. 첫 번째 그림의 경우 유효 주소는 10번지, 두 번째 그림의 경우 유효 주소는 레지스터 R1이 된다.

오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법을 `주소 지정 방식(addressing mode)` 라고 한다. 주소 지정 방식은 유효 주소를 찾는 방법이다.

현대 CPU는 다양한 주소 지정 방식을 사용한다. 대표적인 주소 지정 방식 5개를 살펴보자.

### `즉시 주소 지정 방식(immediate addressing mode)`

연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식이다. 가장 간단한 형태의 주소 지정 방식이다. 이런 방식은 표현할 수 있는 데이터의 크기가 작아지는 단점이 있지만, 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 다른 방식들보다 빠르다.

### `직접 주소 지정 방식(direct addressing mode)`

오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식이다. 오퍼랜드 필드에서 표현할 수 있는 데이터의 크기는 즉시 주소 지정 방식보다 더 커졌지만, 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어들었다. 다시 말해 표현할 수 있는 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져 표현할 수 있는 유효 주소에 제한이 생길 수 있다.

### `간접 주소 지정 방식(indirect addressing mode)`

메모리의 주소를 메모리에 저장한다. 연산에 사용할 데이터를 저장한 메모리의 주소를 저장한 메모리의 주소를 오퍼랜드에 지정한다. 짧게 말해서 유효 주소의 주소를 오퍼랜드 필드에 명시한다. 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 더 넓어졌다. 다만 두 번의 메모리 접근이 필요하기 때문에 앞서 설명한 주소 지정 방식보다 일반적으로 느린 방식이다.

때때로 연산에 사용할 데이터가 레지스터에 저장된 경우도 있다. 이 경우 레지스터 주소 지정 방식 또는 레지스터 간접 주소 지정 방식을 사용할 수 있다.

### `레지스터 주소 지정 방식(register addressing mode)`

직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법이다.

일반적으로 CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르다. 그러므로 레지스터 주소 지정 방식은 직접 주소 지정 방식보다 빠르게 데이터에 접근할 수 있다. 다만, 레지스터 주소 지정 방식은 직접 주소 지정 방식과 비슷한 문제를 공유한다. 표현할 수 있는 레지스터 크기에 제한이 생길 수 있다.

### `레지스터 간접 주소 지정 방식(register indirect addressing mode)`

연산에 사용할 데이터를 메모리에 저장하고, 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법이다.

유효 주소를 찾는 과정이 간접 주소 지정 방식과 비슷하다. 하지만 메모리에 접근하는 횟수가 한 번으로 줄어든다는 차이점이자 장점이 있다. 메모리에 접근하는 것이 레지스터에 접근하는 것보다 더 느리다. 그래서 레지스터 간접 지정 방식은 간접 주소 지정 방식보다 빠르다.

### 정리해보자

연산에 사용할 데이터를 찾는 방법을 `주소 지정 방식` 이라고 한다. 연산에 사용할 데이터가 저장된 위치를 `유효 주소` 라고 한다. 그리고 대표적인 주소 지정 방식으로 5가지 방식을 알아봤다. 각각의 방식이 오퍼랜드 필드에 명시하는 값을 정리해 보면 아래와 같다.

- 즉시 주소 지정 방식 : 연산에 사용할 데이터
- 직접 주소 지정 방식 : 유효 주소 (메모리 주소)
- 간접 주소 지정 방식 : 유효 주소의 주소
- 레지스터 주소 지정 방식 : 유효 주소 (레지스터 이름)
- 레지스터 간접 주소 지정 방식 : 유효 주소를 저장한 레지스터