기계어나 어셈블리어를 이루는 하나하나가 명령어이다. 아직 각각의 명령어는 자세히 살펴보지 않았다. 이제 살펴보도록 하자.

## 연산 코드와 오퍼랜드

누군가에게 명령을 할 때는 대개 아래와 같다.

"다음주까지 과제를 제출해라"

컴퓨터 속 명령어도 마찬가지다. 명령어는 '무엇을 대상으로, 어떤 작동을 수행하라'는 구조로 되어 있다. 아래 표를 보면 가장 왼쪽 필드는 명령어의 '작동', 다시말해 '연산'을 담고있다. 그리고 중간과 오른쪽은 '연산에 사용할 데이터' 또는 '연산에 사용할 데이터가 저장된 위치' 를 담고 있다.

|더해라|100과|120을|
|---|---|---|
|빼라|메모리 32번지 안의 값과|메모리 33번지 안의 값을|
|저장해라|10을|메모리 128번지에|

`명령어` 는 `연산 코드`와 `오퍼랜드`로 구성된다. 가장 왼쪽 값, 즉 '명령어가 수행할 연산' 을 `연산코드(operation code)` 라 하고, 중간과 오른쪽 필드값, 즉 '연산에 사용할 데이터' 또는 '연산에 사용할 데이터가 저장된 위치' 를 `오퍼랜드(operand)` 라고 한다. 연산 코드는 `연산자`, 오퍼랜드는 `피연산자` 라고도 부른다.

간단하게 표현하면 아래의 표와 같다. 위 표와 마찬가지로 가장 왼쪽, 즉 연산 코드가 담기는 영역을 `연산 코드 필드` 라고 부르고, 오른쪽, 즉 오퍼랜드가 담기는 영역을 `오퍼랜드 필드` 라고 부른다.

|연산 코드|오퍼랜드|
|---|---|

기계어와 어셈블리어 또한 명령어이기 때문에 연산 코드와 오퍼랜드로 구성된다. 좌측 글씨가 연산 코드, 탭 이후 글씨가 오퍼랜드이다.

```
push    rbp  
​  
mov     rbp, rsp  
​  
mov     DWORD PTR [rbp-4], 1  
​  
mov     DWORD PTR [rbp-8], 2  
​  
mov     edx, DWORD PTR [rbp-4]  
​  
mov     eax, DWORD PTR [rbp-8]  
​  
add     eax, edx  
​  
mov     DWORD PTR [rbp-12], eax  
​  
mov     eax, 0  
​  
pop     rbp  
​  
ret
```

### 오퍼랜드

명령어를 이루는 연산 코드와 오러랜드 중 오퍼랜드부터 알아본다.

오퍼랜드는 '연산에 사용할 데이터' 또는 '연산에 사용할 데이터가 저장된 위치' 를 의미한다. 그래서 오퍼랜드 필드에는 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있다. 다만 오퍼랜드 필드에는 숫자나 문자와 같이 연산에 사용할 데이터를 직접 명시하기보다는, 많은 경우 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담긴다. 그래서 오퍼랜드 필드를 `주소 필드` 라고 부르기도 한다.

오퍼랜드는 명령어 안에 하나도 없을 수도 있고, 한 개만 있을 수도 있고, 두 개 또는 세 개 등 여러개가 있을 수도 있다.

```
push     rbp

오퍼랜드가 한 개인 경우

mov     rbp, rsp

오퍼랜드가 두 개인 경우

ret

오퍼랜드가 없는 경우
```
​

여기서 오퍼랜드가 하나도 없는 명령어를 `0-주소 명령어` 라고 하고, 오퍼랜드가 하나인 명령어를 `1-주소 명령어` , 두 개인 명령어를 `2-주소 명령어` , 3개인 명령어를 `3-주소 명령어` 라고 한다.

1. 오퍼랜드가 없는 경우 (0-주소 명령어)

|연산코드|
|---|

2. 오퍼랜드가 한 개인 경우 (1-주소 명령어)

|연산코드|오퍼랜드|
|---|---|

3. 오퍼랜드가 두 개인 경우 (2-주소 명령어)

|연산코드|오퍼랜드|오퍼랜드|
|---|---|---|

4. 오퍼랜드가 세 개인 경우 (3-주소 명령어)

|연산코드|오퍼랜드|오퍼랜드|오퍼랜드|
|---|---|---|---|
### 연산코드

연산 코드는 명령어가 수행할 연산을 의미한다. 연산 코드 종류는 매우 많지만, 가장 기본적인 연산 코드 유형은 크게 네 가지로 나눌 수 있다.

1. 데이터 전송
2. 산술/논리 연산
3. 제어 흐름 변경
4. 입출력 제어

이 네 가지 유형 각각에 해당하는 대표적인 연산 코드를 알아보자.

1. 데이터 전송
    - MOVE : 데이터를 옮겨라
    - STORE : 메모리에 저장해라
    - LOAD (FETCH) : 메모리에서 CPU로 데이터를 가져와라
    - PUSH : 스택에 데이터를 저장해라
    - POP : 스택의 최상단 데이터를 가져와라
2. 산술/논리 연산
    - ADD/SUBTRACT/MULTIPLY/DIVIDE : 덧셈/뺄셈/곱셈/나눗셈을 수행해라
    - INCREMENT/DECREMENT : 오퍼랜드에 1을 더해라 / 오퍼랜드에 1을 빼라
    - AND/OR/NOT: 'AND' 연산, 'OR' 연산, 'NOT' 연산을 수행해라
    - COMPARE : 두 개의 숫자 또는 TRUE/FALSE 값을 비교해라
3. 제어 흐름 변경
    - JUMP : 특정 주소로 실행 순서를 옮겨라
    - CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
    - HALT : 프로그램의 실행을 멈춰라
    - CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
    - RETURN : CALL을 호출 할 때 저장했던 주소로 돌아가라
4. 입출력 제어
    - READ (INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
    - WRITE (OUTPUT) : 특정 입출력 장치로 데이터를 써라
    - START IO : 입출력 장치를 시작해라
    - TEST IO : 입출력 장치의 상태를 확인해라

## 주소 지정 방식

명령어의 오퍼랜드 필드에 메모리나 레지스터의 주소를 담는 경우가 많다. 그래서 오퍼랜드 필드를 주소 필드라고도 부른다. 의문이 하나 든다.

> 왜 오퍼랜드 필드에 메모리나 레지스터의 주소를 담는거지? 그냥 <연산 코드, 연산 코드에 사용될 데이터> 형식으로 명령어를 구성하면 되지 않나?

굳이 주소를 넣는 이유는 명령어 길이 때문이다. 하나의 명령어가 n비트로 구성되고, 그중 연산 코드 필드가 m비트라고 가정해보자. 이때 오퍼랜드 필드에 가장 많은 공간을 할당할 수 있는 1-주소 명령어라 할지라도 오퍼랜드 필드의 길이는 연산 코드만큼의 길이를 뺀 n-m 비트가 된다. 2-주소 명령어, 3-주소 명령어라면 오퍼랜드 필드의 크기는 더욱 작아진다.

명령어의 크기가 16비트, 연산 코드 필드가 4비트인 2-주소 명령어에서는 오퍼랜드 필드당 6비트 정도밖에 남지 않는다. 즉, 하나의 오퍼랜드 필드로 표현할 수 있는 정보의 가짓수는 $2^6$ 개밖에 되지 않는다.

![‎명령어.‎001](file:///Users/regularkim/Library/Mobile%20Documents/com~apple~CloudDocs/Typora/%E1%84%82%E1%85%A9%E1%84%89%E1%85%A7%E1%86%AB%E1%84%8B%E1%85%A5%E1%86%B8%E1%84%85%E1%85%A9%E1%84%83%E1%85%B3%E1%84%8B%E1%85%AD%E1%86%BC/CS/%E2%80%8E%E1%84%86%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A5.%E2%80%8E001.jpeg?lastModify=1694359403)

그리고 명령어의 크기가 16비트, 연산 코드 필드가 4비트인 3-주소 명령어에서는 오퍼랜드 필드당 4비트 정도밖에 남지 않는다. 이 경우 하나의 오퍼랜드 필드로 표현할 수 있는 정보의 가짓수는 2<sup>4</sup> 개밖에 없다.

![‎명령어.‎002](file:///Users/regularkim/Library/Mobile%20Documents/com~apple~CloudDocs/Typora/%E1%84%82%E1%85%A9%E1%84%89%E1%85%A7%E1%86%AB%E1%84%8B%E1%85%A5%E1%86%B8%E1%84%85%E1%85%A9%E1%84%83%E1%85%B3%E1%84%8B%E1%85%AD%E1%86%BC/CS/%E2%80%8E%E1%84%86%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A5.%E2%80%8E002.jpeg?lastModify=1694359403)

하지만 만약 오퍼랜드 필드 안에 메모리 주소가 담긴다면 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다.

예를 들어 한 주소에 16비트를 저장할 수 있는 메모리가 있다. 이 메모리 안에 데이터를 저장하고, 오퍼랜드 필드 안에 해당 메모리 주소를 명시한다면 표현할 수 있는 정보의 가짓수가 2<sup>16</sup> 으로 확 커지게 된다.

![‎명령어.‎003](file:///Users/regularkim/Library/Mobile%20Documents/com~apple~CloudDocs/Typora/%E1%84%82%E1%85%A9%E1%84%89%E1%85%A7%E1%86%AB%E1%84%8B%E1%85%A5%E1%86%B8%E1%84%85%E1%85%A9%E1%84%83%E1%85%B3%E1%84%8B%E1%85%AD%E1%86%BC/CS/%E2%80%8E%E1%84%86%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A5.%E2%80%8E003.jpeg?lastModify=1694359403)

오퍼랜드 필드에 메모리 주소가 아닌 레지스터 이름을 명시할 때도 마찬가지이다. 이 경우 표현할 수 있는 가짓수는 해당 레지스터가 저장할 수 있는 공간만큼 커진다.

![‎명령어.‎004](file:///Users/regularkim/Library/Mobile%20Documents/com~apple~CloudDocs/Typora/%E1%84%82%E1%85%A9%E1%84%89%E1%85%A7%E1%86%AB%E1%84%8B%E1%85%A5%E1%86%B8%E1%84%85%E1%85%A9%E1%84%83%E1%85%B3%E1%84%8B%E1%85%AD%E1%86%BC/CS/%E2%80%8E%E1%84%86%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A5.%E2%80%8E004.jpeg?lastModify=1694359403)

연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치를 `유효 주소(effective address)` 라고 한다. 첫 번째 그림의 경우 유효 주소는 10번지, 두 번째 그림의 경우 유효 주소는 레지스터 R1이 된다.

오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법을 `주소 지정 방식(addressing mode)` 라고 한다. 주소 지정 방식은 유효 주소를 찾는 방법이다.

현대 CPU는 다양한 주소 지정 방식을 사용한다. 대표적인 주소 지정 방식 5개를 살펴보자.

### `즉시 주소 지정 방식(immediate addressing mode)`

연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식이다. 가장 간단한 형태의 주소 지정 방식이다. 이런 방식은 표현할 수 있는 데이터의 크기가 작아지는 단점이 있지만, 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 다른 방식들보다 빠르다.

### `직접 주소 지정 방식(direct addressing mode)`

오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식이다. 오퍼랜드 필드에서 표현할 수 있는 데이터의 크기는 즉시 주소 지정 방식보다 더 커졌지만, 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어들었다. 다시 말해 표현할 수 있는 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져 표현할 수 있는 유효 주소에 제한이 생길 수 있다.

### `간접 주소 지정 방식(indirect addressing mode)`

메모리의 주소를 메모리에 저장한다. 연산에 사용할 데이터를 저장한 메모리의 주소를 저장한 메모리의 주소를 오퍼랜드에 지정한다. 짧게 말해서 유효 주소의 주소를 오퍼랜드 필드에 명시한다. 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 더 넓어졌다. 다만 두 번의 메모리 접근이 필요하기 때문에 앞서 설명한 주소 지정 방식보다 일반적으로 느린 방식이다.

때때로 연산에 사용할 데이터가 레지스터에 저장된 경우도 있다. 이 경우 레지스터 주소 지정 방식 또는 레지스터 간접 주소 지정 방식을 사용할 수 있다.

### `레지스터 주소 지정 방식(register addressing mode)`

직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법이다.

일반적으로 CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르다. 그러므로 레지스터 주소 지정 방식은 직접 주소 지정 방식보다 빠르게 데이터에 접근할 수 있다. 다만, 레지스터 주소 지정 방식은 직접 주소 지정 방식과 비슷한 문제를 공유한다. 표현할 수 있는 레지스터 크기에 제한이 생길 수 있다.

### `레지스터 간접 주소 지정 방식(register indirect addressing mode)`

연산에 사용할 데이터를 메모리에 저장하고, 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법이다.

유효 주소를 찾는 과정이 간접 주소 지정 방식과 비슷하다. 하지만 메모리에 접근하는 횟수가 한 번으로 줄어든다는 차이점이자 장점이 있다. 메모리에 접근하는 것이 레지스터에 접근하는 것보다 더 느리다. 그래서 레지스터 간접 지정 방식은 간접 주소 지정 방식보다 빠르다.

### 정리해보자

연산에 사용할 데이터를 찾는 방법을 `주소 지정 방식` 이라고 한다. 연산에 사용할 데이터가 저장된 위치를 `유효 주소` 라고 한다. 그리고 대표적인 주소 지정 방식으로 5가지 방식을 알아봤다. 각각의 방식이 오퍼랜드 필드에 명시하는 값을 정리해 보면 아래와 같다.

- 즉시 주소 지정 방식 : 연산에 사용할 데이터
- 직접 주소 지정 방식 : 유효 주소 (메모리 주소)
- 간접 주소 지정 방식 : 유효 주소의 주소
- 레지스터 주소 지정 방식 : 유효 주소 (레지스터 이름)
- 레지스터 간접 주소 지정 방식 : 유효 주소를 저장한 레지스터