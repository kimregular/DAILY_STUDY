입출력 작업을 수행하려면 CPU와 장치 컨트롤러가 정보를 주고받아야 한다. 그렇다면 장치 컨트롤러는 CPU와 어떻게 정보를 주고받을까?

여기에는 크게 세 가지 방법이 있다. `프로그램 입출력`, `인터럽트 기반 입출력`, `DMA 입출력`이다.

### 프로그램 입출력
`프로그램 입출력 (programmed I/O)`은 기본적으로 프로그램 속 명령어로 입출력장치를 제어하는 방법이다. CPU가 프로그램 속 명령어를 실행하는 과정에서 입출력 명령어를 만나면 CPU는 입출력장치에 연결된 장치 컨트롤러와 상호작용하며 입출력 작업을 수행한다.

메모리에 저장된 정보를 하드 디스크에 백업하는 상황을 생각해보자. CPU는 대략 아래 과정으로 입출력 작업을 한다.

01. '메모리에 저장된 정보를 하드 디스크에 백업한다'는 말은 '하드 디스크에 새로운 정보를 쓴다'는 말과 같다. 우선 CPU는 하드 디스크 컨트롤러의 제어 레지스터에 쓰기 명령을 보낸다.
02. 하드 디스크 컨트롤러는 하드 디스크 상태를 확인한다. 하드 디스크가 준비된 상태라면 하드 디스크 컨트롤러는 상태 레지스터에 준비되었다고 표시한다.
03. 
	1. CPU는 상태 레지스터를 주기적으로 읽어보며 하드 디스크의 준비 여부를 확인한다.
	2. 하드 디스크가 준비됐음을 CPU가 알게 되면 백업할 메모리의 정보를 데이터 레지스터에 쓴다. 아직 백업 작업(쓰기 작업)이 끝나지 않았다면 큰 1번부터 반복하고, 쓰기가 끝났다면 작업을 종료한다.

이렇듯 프로그램 입출력 방식에서의 입출력 작업은 CPU가 장치 컨트롤러의 레지스터 값을 읽고 씀으로써 이루어진다. 그런데 CPU는 입출력장치들의 주소를 어떻게 알까? 정확히 말해 CPU는 장치 컨트롤러의 레지스터들을 어떻게 알까?

CPU 내부에 있는 레지스터들과는 달리 CPU는 여러 장치 컨트롤러 속 레지스터들을 모두 알고 있기란 어렵다. 그렇다면 아래와 같은 명령어들은 어떻게 명령어로 표현되고, 메모리에 어떻게 저장되어 있을까?

- 프린터 레지스터의 상태 레지스터를 읽어라.
- 프린터 컨트롤러의 데이터 레지스터에 100을 써라.
- 키보드 컨트롤러의 상태 레지스터를 읽어라.
- 하드 디스크 컨트롤러의 데이터 레지스터에 'a'를 써라.

여기에는 크게 두 가지 방식이 있다. 바로 `메모리 맵 입출력`과 `고립형 입출력`이다.

#### 메모리 맵 입출력
`메모리 맵 입출력 (memory-mapped I/O)`은 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법이다. 가령 1024개의 주소를 표현할 수 있는 컴퓨터가 있을 때 1024개 전부 메모리 주소를 표현하는 데 사용하지 않는다. 512개는 메모리 주소를, 512개는 장치 컨트롤러의 레지스터를 표현하기 위해 사용한다.

주소 공간 일부를 아래와 같이 약속했다고 가정한다.

- 516번지 : 프린터 레지스터의 상태 레지스터를 읽어라.
- 517번지 : 프린터 컨트롤러의 데이터 레지스터에 100을 써라.
- 518번지 : 키보드 컨트롤러의 상태 레지스터를 읽어라.
- 519번지 : 하드 디스크 컨트롤러의 데이터 레지스터에 'a'를 써라.

그렇다면 CPU는 '517번지를 읽어 들여라'라는 명령어로 키보드 상태를 읽을 수 있다. 그리고 '518번지에 a를 써라'라는 명령어로 하드 디스크 컨트롤러의 데이터 레지스터로 데이터를 보낼 수 있다.

이때 중요한 점은 메모리 맵 입출력 방식에서 CPU는 메모리의 주소들이나 장치 컨트롤러의 레지스터들이나 모두 똑같이 메모리 주소를 대하듯 하면 된다는 점이다. 그래서 메모리에 접근하는 명령어와 입출력장치에 접근하는 명령어는 굳이 다를 필요가 없다.

CPU가 '517번지를 읽어라'라는 명령어를 실행했을 때 517번지가 메모리상의 주소를 가리킨다면 CPU는메모리 517번지에 저장된 정보를 읽어 들일 것이고, 517번지가 프린터 컨트롤러의 상태 레지스터를 가리킨다면 CPU는 프린터의 상태를 확인할 수 있다.

#### 고립형 입출력
`고립형 입출력 (isolated I/O)`은 메모리를 위한 주소 공간과 입출력장치를 위한 주소 공간을 분리하는 방법이다. 가령 1024개의 주소 공간을 가진 컴퓨터가 있다고 가정해보자.

제어 버스에 '메모리 읽기/쓰기'선 이외에 '입출력장치 읽기/쓰기'선이 따로 있다면 메모리에도 1024개의 주소 공간을 활용하고, 입출력장치도 1024개의 주소 공간을 활용할 수 있다. CPU가 메모리 읽기/쓰기 선이 활성화되는 명령어를 실행할 때는 메모리에 접근하고, 입출력장치 읽기/쓰기 선이 활성화되는 명령어를 실행할 때는 장치 컨트롤러에 접근하기 때문이다.

고립형 입출력 방식에서 CPU는 입출력장치에 접근하기 위해 메모리에 접근하는 명령어와는 다른 (입출력 읽기/쓰기를 활성화 시키는) 입출력 명령어를 사용한다. 메모리에 접근하는 명령어와 입출력장치에 접근하는 명령어는 굳이 다를 필요가 없었던 메모리 맵 입출력과 대조적이다.

|메모리 맵 입출력|고립형 입출력|
|---|---|
|메모리와 입출력장치는 같은 주소 공간 사용|메모리와 입출력장치는 분리된 주소 공간 사용|
|메모리 주소 공간이 축소됨|메모리 주소 공간이 축소되지 않음|
|메모리와 입출력장치에 같은 명령어 사용|입출력 전용 명령어 사용|
