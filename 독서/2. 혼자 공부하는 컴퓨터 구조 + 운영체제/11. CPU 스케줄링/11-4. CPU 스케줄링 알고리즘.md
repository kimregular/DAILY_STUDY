이제부터 여러 스케줄링 알고리즘을 알아보자. CPU 스케줄링 알고리즘의 종류는 매우 다양하고 운영체제 저마다 서로 다른 스케줄링 알고리즘을 사용한다. 중요한 것은 각 스케줄링 알고리즘에서 사용된 '아이디어'이지, '용어'가 아니다. 

### 스케줄링 알고리즘의 종류
스케줄링 알고리즘의 종류는 매우 다양하다. 운영체제도 저마다 다른 스케줄링 알고리즘을 사용하고 있다. 

#### 선입 선처리 스케줄링
`선입 선처리 스케줄링`은 `FCFS 스케줄링 (First Come First Served Scheduling)`이라고도 부른다. 이는 단순히 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식이다. 즉, 선입 선처리 스케줄링은 CPU를 먼저 요청한 프로세스부터 CPU를 할당하는 스케줄링 방식이다. 선입 선처리 스케줄링은 언뜻 보기에는 가장 공정해 보이지만, 때때로 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 점에서 부작용이 있는 방식이다.

가령 CPU를 오래 사용하는 프로세스가 먼저 도착하면 다른 프로세스는 그 프로세스가 CPU를 사용하는 동안 무작정 기다리는 수밖에 없다. 예를 들어 17ms 동안 CPU를 이용하는 프로세스 A, 5ms 동안 CPU를 이용하는 프로세스 B, 2ms 동안 CPU를 이용하는 프로세스 C가 차례로 준비 큐에 삽입된다면 프로세스 C는 고작 2ms를 실행하기 위해 22ms라는 긴 시간을 기다려야만 한다. 이런 현상을 `호위 효과 (convoy effect)`라고 한다.

#### 최단 작업 우선 스케줄링
호위 효과를 방지하려면 어떻게 해야 할까? 단순하게 생각해 보면 CPU 사용 시간이 긴 프로세스는 나중에 실행하고, CPU 사용 시간이 짧은 간단한 프로세스를 먼저 실행한다.

앞서 보여준 예시에서는 프로세스 A의 CPU 사용 시간이 매우 길기 때문에 B와 C는 무작정 오래 기다릴 수밖에 없었다. 만약 CPU 사용 시간이 짧은 C와 B부터 실행한다면 C는 더 이상 기다릴 필요가 없고, B는 2ms, A는 7ms만 기다리면 된다.

이렇게 준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 스케줄링 방식을 `최단 작업 우선 스케줄링` 혹은 `SJF 스케줄링 (Shortest Job First Scheduling)`이라고 한다. 최단 작업 우선 스케줄링은 기본적으로 비선점형 스케줄링 알고리즘으로 분류되지만, 선점형으로 구현될 수도 있다. `선점형 최단 작업 우선 스케줄링`이 뒤에 언급할 최소 잔여 시간 우선 스케줄링이다.

#### 라운드 로빈 스케줄링
`라운드 로빈 스케줄링 (round robin scheduling)`은 선입 선처리 스케줄링에 타임 슬라이스라는 개념이 더해진 스케줄링 방식이다. `타임 슬라이스`란 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미한다. 즉, 라운드 로빈 스케줄링은 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링이다.

큐에 삽입된 프로세스들은 삽입된 순서대로 CPU를 이용하되 정해진 시간만큼만 PCU를 이용하고, 정해진 시간을 모두 사용하였음에도 아직 프로세스가 완료되지 않았다면 다시 큐의 맨 뒤에 삽입된다. 이때 문맥 교환이 발생한다.

만약 CPU 사용 시간이 11ms, 3ms, 7ms인 프로세스 A, B, C를 타임 슬라이스가 4ms인 라운드 로빈 스케줄링을 한다면 아래 그림과 같이 수행된다.

![라운드 로빈.001.jpeg](<images/라운드 로빈.001.jpeg>)

라운드 로빈 스케줄링에서는 타임 슬라이스 크기가 매우 중요하다. 타임 슬라이스가 지나치게 크면 사실상 선입 선처리 스케줄링과 다를 바 없어 호위 효과가 생길 여지가 있고, 타임 슬라이스가 지나치게 작으면 문맥 교환에 발생하는 비용이 커 CPU는 프로세스를 처리하는 일보다 프로세스를 전환하는 데에 온 힘을 다 쓸 여지가 있기 때문이다.

#### 최소 잔여 시간 우선 스케줄링
`최소 잔여 시간 우선 스케줄링` 혹은 `SRT (Shortest Remaining Time) 스케줄링`은 최단 작업 우선 스케줄링 알고리즘과 라운드 로빈 알고리즘을 합친 스케줄링 방식이다. 최단 작업 우선 스케줄링은 작업 시간이 짧은 프로세스부터 처리하는 스케줄링 알고리즘이고, 라운드 로빈 알고리즘은 정해진 타임 슬라이스 만큼 돌아가며 CPU를 사용하는 선점형 스케줄링 알고리즘이다. 최소 잔여 시간 우선 스케줄링 하에서 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택된다.

#### 우선 순위 스케줄링
`우선 순위 스케줄링 (priority scheduling)`은 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 알고리즘이다. 우선순위가 같은 프로세스들은 선입선처리로 스케줄링된다.

앞서 설명한 최단 작업 우선 스케줄링, 최소 잔여 시간 우선 스케줄링 알고리즘은 넓은 의미에서 우선순위 스케줄링의 일종으로 볼 수 있다. 최단 작업 우선 스케줄링은 작업 시간이 짧은 프로세스에 높은 우선순위를 부여하는 방식이고, 최소 잔여 시간 우선 스케줄링은 남은 시간이 짧은 프로세스에 높은 우선순위를 부여하는 방식이라 볼 수 있기 때문이다.

다만, 우선순위 스케줄링은 근본적인 문제를 내포하고 있다. 우선순위가 높은 프로세스를 우선하여 처리하는 방식이기에 우선순위가 낮은 프로세스는 (준비 큐에 먼저 삽입되었음에도 불구하고) 우선순위가 높은 프로세스들에 의해 실행이 계속해서 연기될 수 있다. 이를 `기아 (starvation)`현상이라고 한다. 우선순위가 높은 프로세스만 계속 먼저 실행되니 우선순위가 낮은 프로세스의 실행은 계속 뒤로 밀리기 때문이다.

이를 방지하기 위한 대표적인 기법으로 `에이징 (aging)`이 있다. 이는 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식이다. 말하자면 대기 중인 프로세스의 우선순위를 마치 나이 먹듯 점차 증가시키는 방법이다. 에이징 기법을 적용하면 우선순위가 낮아 마냥 기다리기만 하는 프로세스가 없어진다. 우선순위가 낮더라도 언젠가는 높은 우선순위가 될 테니 말이다.

#### 다단계 큐 스케줄링
다단계 큐 스케줄링은 앞서 설명한 우선순위 스케줄링의 발전된 형태이다. `다단계 큐 스케줄링 (multilevel queue scheduling)`은 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식이다. 다단계 큐 스케줄링 하에서는 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 우선순위가 가장 높은 큐가 비어 있으면 그다음 우선순위 큐에 있는 프로세스들을 처리한다.

우선순위 0에 삽입된 프로세스들, 우선순위 1에 삽입된 프로세스들, 우선순위 2에 삽입된 프로세스들 순서대로 CPU를 할당받아 실행된다.

이렇게 큐를 여러 개 두면 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해진다. 가령 어떤 큐에는 우선순위가 비교적 높아야 하는 CPU 집중 프로세스가 삽입될 수 있고, 어떤 큐에는 우선순위가 비교적 낮아도 상관없는 입출력 집중 프로세스가 삽입될 수 있다. 또 어떤 큐에는 (우선순위가 비교적 높아야 하는) 백그라운드 프로세스들을 삽입할 수 있고, 어떤 큐에는 (우선순위가 비교적 낮아도 무방한) 사용자와의 상호작용이 잦은 프로세스들을 삽입할 수 있다.

또한 큐별로 타임 슬라이스를 여러 개 지정할 수도 있고, 큐마다 다른 스케줄링 알고리즘을 사용할 수도 있다. 예를 들어어떤 큐에서의 타임 슬라이스는 크게, 어떤 큐에서의 타임 슬라이스는 작게 사용하고, 어떤 큐에서는 선입 선처리 스케줄링을 사용하고, 어떤 큐에서는 라운드 로빈 스케줄링을 사용할 수 있다.

#### 다단계 피드백 큐 스케줄링
다단계 피드백 큐 스케줄링은 다단계 큐 스케줄링의 발전된 형태이다. 앞서 설명한 다단계 큐 스케줄링에서는 프로세스들이 큐 사이를 이동할 수 없다. 그러나 이런 방식대로라면 우선순위가 낮은 프로세스는 계속 연기될 여지가 있다. 즉, 다시 한번 기아 현상이 발생할 수 있다. 언제 높은 우선순위의 프로세스가 들어올지 모르는데, 우선순위가 낮은 프로세스 입장에서는 매우 불리하다. 이를 보완한 스케줄링 알고리즘이 `다단계 피드백 큐 스케줄링 (multilevel feedback queue scheduling)`이다.

다단계 피드백 큐 스케줄링은 다단계 큐 스케줄링과 비슷하게 작동하지만, 한 가지가 다르다. 바로 프로세스들이 큐 사이를 이동할 수 있다는 점이다. 다단계 피드백 큐 스케줄링에서 새로 준비 상태가 된 프로세스가 있다면 우선 우선순위가 가장 높은 우선순위 큐에 삽입되고 일정 시간 (타임 슬라이스) 동안 실행된다.

그리고 만약 프로세스가 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행된다. 그리고 또 해당 큐에서 실행이 끝나지 않는다면 프로세스는 또 다음 우선순위 큐에 삽입되고, 결국 CPU를 오래 사용해야 하는 프로세스는 점차 우선순위가 낮아진다.

즉, CPU를 비교적 오래 사용해야 하는 CPU 집중 프로세스들은 자연스레 우선순위가 낮아지고, CPU를 비교적 적게 사용하는 입출력 집중 프로세스들은 자연스레 우선순위가 높은 큐에서 실행이 끝난다.

다단계 피드백 큐 스케줄링은 프로세스들이 큐 사이를 이동할 수 있는 방식이기 때문에 낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면 점차 우선순위가 높은 큐로 이동시키는 에이징 기법을 적용하여 기아 현상을 예방할 수 있다.

즉, 다단계 피드백 큐 스케줄링 알고리즘은 어떤 프로세스의 CPU 이용 시간이 길면 낮은 우선순위 큐로 이동시키고, 어떤 프로세스가 낮은 우선순위 큐에서 너무 오래 기다린다면 높은 우선순위 큐로 이동시킬 수 있는 알고리즘이다.

다단계 피드백 큐 스케줄링은 구현이 복잡하지만, 가장 일반적인 CPU 스케줄링 알고리즘으로 알려져 있다.