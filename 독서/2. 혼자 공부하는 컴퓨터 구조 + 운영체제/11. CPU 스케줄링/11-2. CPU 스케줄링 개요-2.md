### 스케줄링 큐
PCB에 우선순위가 적혀 있다고는 하지만, CPU를 사용할 다음 프로세스를 찾기 위해 운영체제가 일일이 모든 프로세스의 PCB를 뒤적거리는 것은 비효율적이다. CPU를 원하는 프로세스들은 한 두 개가 아니고, CPU를 요구하는 새로운 프로세스는 언제든 생길 수 있기 때문이다.

이는 비단 CPU 자원에만 국한된 상황이 아니다. 메모리에 적재되고 싶어 하는 프로세스도 얼마든지 있을 수 있고, 특정 입출력장치와 보조기억장치를 사용하길 원하는 프로세스도 여러 개가 있을 수 있다. 운영체제가 매번 일일이 모든 PCB를 검사하여 먼저 자원을 이용할 프로세스를 결정하는 일은 매우 번거로울 뿐더러 오랜 시간이 걸린다.

그래서 운영체제는 프로세스들에 '줄을 서서 기다릴 것'을 요구한다. CPU를 사용하고 싶은 프로세스들, 메모리에 적재되고 싶은 프로세스들, 특정 입출력장치를 사용하고 싶은 프로세스들을 모두 줄세우는 것이다. 그리고 운영체제는 이 줄을 `스케줄링 큐 (Scheduling Queue)`로 구현하고 관리한다. 큐는 자료 구조 관점에서 보았을 때는 먼저 삽입된 데이터가 먼저 나가는 선입선출 자료 구조이지만, 스케줄링에서 이야기하는 큐는 반드시 선입선출 방식일 필요는 없다.

즉, 운영체제는 메모리로 적재되고 싶은 (새로 생성되는) 프로세스들을 큐에 삽입하여 줄을 세우고, CPU를 이용하고 싶은 프로세스들 또한 큐에 삽입하여 줄을 세우고, 특정 입출력장치를 이용하고 싶은 프로세스들 역시 큐에 삽입하여 줄을 세운다.

![스케줄링큐.001.jpeg](<images/스케줄링큐.001.jpeg>)

운영체제가 관리하는 대부분의 자원은 이렇듯 큐로 관리된다. 그래서 운영체제가 관리하는 줄, 즉 큐에는 다양한 종류가 있다. 대표적인 큐로 준비 큐와 대기 큐가 있다. `준비 큐 (ready queue)`는 CPU를 이용하고 싶은 프로세스들이 서는 줄을 의미하고, `대기 큐 (waiting queue)`는 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄을 의미한다.

![스케줄링큐.002.jpeg](<images/스케줄링큐.002.jpeg>)

준비 상태에 있는 프로세스들의 PCB는 준비 큐의 마지막에 삽입되어 CPU를 사용할 차례를 기다린다. 운영체제는 PCB들이 큐에 삽입된 순서대로 프로세스를 하나씩 꺼내어 실행하되, 그중 우선순위가 높은 프로세스를 먼저 실행한다.

우선순위가 낮은 프로세스들이 먼저 큐에 삽입되어 줄을 섰다고 할지라도 우선순위가 높은 프로세스는 그들보다 먼저 처리될 수 있다. 이런 점에서 봤을 때 높은 우선순위를 가진 프로세스는 마치 VIP와도 같다. 이처럼 프로세스들로 하여금 줄을 세우면서 동시에 높은 우선순위부터 실행하는 구체적인 방식은 다음에 알아본다.

대기 상태에 있는 프로세스도 마찬가지이다. 같은 장치를 요구한 프로세스들은 같은 대기 큐에서 기다린다. 예를 들어 하드 디스크 사용을 요구한 프로세스는 하드 디스크 대기 큐에서 입출력 작업이 완료되기를 기다리고, 프린터 사용을 요구한 프로세스는 프린터 대기 큐에서 입출력 작업이 완료되기를 기다리는 것이다.

입출력이 완료되어 완료 인터럽트가 발생하면 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고, 이 PCB를 준비 상태로 변경한 뒤 대기 큐에서 제거한다. 당연히 해당 PCB는 준비 큐로 이동한다.

![스케줄링큐.003.jpeg](<images/스케줄링큐.003.jpeg>)

이전에 배운 프로세스 상태 다이어그램을 떠올려보자. 운영체제가 유지하는 여러 큐에 대해 알았다면 프로세스 상태 다이어그램을 아래와 같이 조금 더 세밀하게 완성할 수 있다.

![스케줄링큐.004.jpeg](<images/스케줄링큐.004.jpeg>)

