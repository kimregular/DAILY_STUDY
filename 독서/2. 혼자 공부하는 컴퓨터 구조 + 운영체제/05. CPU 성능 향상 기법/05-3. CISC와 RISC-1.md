명령어 파이프라이닝과 슈퍼스칼라 기법을 실제로 CPU에 적용하려면 명령어가 파이프라이닝에 최적화되어 있어야 한다. 쉽게 말해 CPU가 파이프라이닝과 슈퍼스칼라 기법을 효과적으로 사용하려면 CPU가 인출하고 해석하고 실행하는 명령어가 파이프라인닝 하기 쉽게 생겨야 한다.

'파이프라이닝 하기 쉬운 명령어'란 무엇일까? 명령어가 어떻게 생겨야 파이프라이닝에 유리할까? 이와 관련해 CPU의 언어는 `ISA`와 각기 다른 성격의 ISA를 기반으로 설계된 `CISC`와 `RISC`를 알아보자.

### 명령어 집합
명령어의 생김새와 주소 지정 방식 등을 이전에 살펴보았다. 그리고 이런 명령어들을 CPU가 실행한다고 알아봤다. 그런데 한 가지 의문이 생긴다. 이 세상 모든 CPU들이 똑같이 생긴 명령어를 실행할까? 세상에는 수많은 CPU 제조사들이 있고, CPU마다 규격과 기능, 만듦새가 다 다른데, 모든 CPU가 이해하고 실행하는 명령어들이 다 똑같이 생겼을까?

그렇지 않다. 물론 명령어의 기본적인 구조와 작동 원리는 이전에 알아본 내용에서 크게 벗어나지 않지만, 명령어의 세세한 생김새, 명령어로 할 수 있는 연산, 주소 지정 방식 등은 CPU마다 조금씩 차이가 있다. CPU가 이해할 수 있는 명령어들의 모음을 `명령어 집합(instruction set)` 또는 `명령어 집합 구조(ISA : instruction set architecture)`라고 한다. 즉, CPU마다 ISA가 다를 수 있다는 뜻이다. 명령어 집합에 '구조'라는 단어가 붙은 이유는 CPU가 어떤 명령어를 이해하는지에 따라 컴퓨터 구조 및 설계 방식이 달라지기 때문이다.

가령 인텔 노트북 속 CPU는 x86 혹은 x86-64 ISA를 이해하고, 애플의 아이폰 속 CPU는 ARM ISA를 이해한다. x86과 ARM은 다른 ISA이기 때문에 인텔 CPU를 사용하는 컴퓨터와 아이폰은 서로의 명령어를 이해할 수 없다. 실행 파일은 명령어로 이루어져 있고 서로의 컴퓨터가 이해할 수 있는 명령어가 다르기 때문이다.
(x86은 32비트용, x86-64는 64비트용 x86 ISA이다)

이전에 어셈블리어는 명령어를 읽기 편하게 표현한 언어라고 살펴보았다. ISA가 다르다는 건 CPU가 이해할 수 있는 명령어가 다르다는 뜻이고, 명령어가 달라지면 어셈블리어도 달라진다. 다시 말해 같ㅇ느 소스 코드로 만들어진 같은 프로그램이라 할지라도 ISA가 다르면 CPU가 이해할 수 있는 명령어도 어셈블리어도 달라진다는 뜻이다.

예를 들어보자. 동일한 소스 코드를 작성하고 ISA가 다른 컴퓨터에서 어셈블리어로 컴파일하면 아래와 같은 결과를 얻는다.
`소스코드`
```c
int main(void){
	int a = 1;
	int b = 2;
	int c = a + b;
	return 0;
}
```

`x86-64`
```assembly
main:
	push    rbp
	mov     rbp, rsp
	mov     DWORD PTR [rbp-4], 1
	mov     DWORD PTR [rbp-8], 2
	mov     edx, DWORD PTR [rbp-4]
	mov     eax, DWORD PTR [rbp-8]
	add     eax, edx
	mov     DWORD PTR [rbp-12], eax
	mov     eax, 0
	pop     rbp
	ret
```

`ARM`
```assembly
main:
	push    {r7}
	sub     sp, sp, #20
	add     r7, sp, #0
	movs    r3 #1
	str     r3, [r7, #12]
	movs    r3, #2
	str     r3, [r7, #8]
	ldr     r2, [r7, #12]
	ldr     r3, [r7, #8]
	add     r3, r3, r2
	str     r3, [r7, #4]
	movs    r3, #0
	mov     r0, r3
	adds    r7, r7, #20
	mov     sp, r7
	ldr     r7, [sp], #4
	bx      lr
```

위부터 x86-64 ISA, ARM ISA 순서이다. 똑같은 코드로 만든 프로그램임에도 CPU가 이해하고 실행할 수 있는 명령어가 달라 어셈블리어도 다른 것을 알 수 있다. 참고로 사용한 컴파일러에 따라서도 어셈블리어가 달라질 수 있는데, 위 예시에서는 gcc 11.2 라는 동일한 컴파일러를 이용했다.

ISA가 같은 CPU끼리는 서로의 명령어를 이해할 수 있지만, ISA가 다르면 서로의 명령어를 이해하지 못한다. 이런 점에서 볼 때 ISA는 일종의 CPU 언어인 셈이다.

각기 다른 언어를 사용하는 나라들을 보면 사용하는 언어만 다른 게 아니라 언어에 따라 사람들의 가치관과 생활 양식도 다른 것을 볼 수 있다. 마치 높임말이 있는 나라에서는 비교적 어른을 공경하는 문화가 자리잡혀 있고, 높임말이 없는 나라에서는 비교적 평등한 문화가 자리잡힌 것처럼말이다.

CPU도 마찬가지다. CPU가 이해하는 명령어들이 달라지면 비단 명령어의 생김새만 달라지는 게 아니다. ISA가 다르면 그에 따른 나비 효과로 많은 것이 달라진다. 제어장치가 명령어를 해석하는 방식, 사용되는 레지스터의 종류와 개수, 메모리 관리 방법 등 많은 것이 달라진다. 그리고 이는 곧 CPU 하드웨어 설계에도 큰 영향을 미친다.

우리가 실행하는 프로그램은 명령어로 이루어져 있다. ISA는 CPU의 언어임과 동시에 CPU를 비롯한 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속이라고도 볼 수 있다.

앞서서 명령어 병렬 처리 기법을 알아봤다. 이를 적용하기에 용이한 ISA가 있고, 그렇지 못한 ISA가 있다. 다시 말해 명령어 파이프라인, 슈퍼스칼라, 비순차적 명령어 처리를 사용하기에 우리한 명령어 집합이 있고, 그렇지 못한 명령어 집합도 있다. 그렇다면 명령어 병렬 처리 기법들을 도입하기에 유리한 ISA를 알아보자. 이와 관련해 ISA의 양대 산맥인 CISC와 RISC에 대해 알아본다.