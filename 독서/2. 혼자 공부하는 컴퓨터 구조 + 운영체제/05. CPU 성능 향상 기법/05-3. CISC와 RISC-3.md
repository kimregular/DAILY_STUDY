### RISC
CISC의 한계는 아래 두 교훈을 주었다.
1. 빠른 처리를 위해 명령어 파이프라인을 십분 활용해야 한다. 원활한 파이프라이닝을 위해 '명령어 길이와 수행 시간이 짧고 규격화' 되어 있어야 한다.
2. 어차피 자주 쓰이는 명령어만 줄곧 사용된다. 복잡한 기능을 지원하는 명령어를 추가하기보다는 '자주 쓰이는 기본적인 명령어를 작고 빠르게 만드는 것'이 중요하다.
이런 원칙 하에 등장한 것이 RISC이다. `RISC`는 `Reduced Instruction Set Computer`의 약자이다. 이름처럼 RISC는 CISC에 비해 명령어의 종류가 적다. 그리고 CISC와는 달리 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향한다.

즉, RISC는 `고정 길이 명령어`를 활용한다. 명령어가 규격화 되어 있고, 하나의 명령어가 1클럭 내외로 실행되기 때문에 RISC 명령어 집합은 명령어 파이프라이닝에 최적화되어 있다.

그리고 RISC는 메모리에 직접 접근하는 명령어를 load, store 두 개로 제한할 만큼 메모리 접근을 단순화하고 최소화를 추구한다. 그렇기 때문에 CISC보다 주소 지정 방식의 종류가 적은 경우가 많다. 이런 점에서 RISC를 `load-store 구조`라고 부르기도 한다.

RISC는 메모리 접근을 단순화, 최소화하는 대신 레지스터를 적극적으로 활용한다. 그렇기에 CISC보다 레지스터를 이용하는 연산이 많고, 일반적인 경우보다 범용 레지스터 개수도 더 많다. 다만 사용 가능한 명령어 개수가 CISC보다 적기 때문에 RISC는 CISC보다 많은 명령으로 프로그램을 작동시킨다.

이전에 살펴본 어셈블리어 예시를 다시 보자. ARM은 RISC 기반의 대표적인 ISA이다. x86-64 보다 더 많은 명령어로 동일한 프로그램을 실행하는 것을 볼 수 있다. 즉, 같은 소스 코드를 컴파일해도 RISC는 CISC보다 많은 수의 명령어로 변환된다.

마지막으로 CISC와 RISC의 차이를 정리하고 마무리한다.

|CISC|RISC|
|---|---|
|복잡하고 다양한 명령어 | 단순하고 적은 명령어|
|가변 길이 명령어|고정 길이 명령어|
|다양한 주소 지정 방식 |적은 주소 지정 방식|
|프로그램을 이루는 명령어의 수가 적음 | 프로그램을 이루는 명령어의 수가 많음|
|여러 클럭에 걸쳐 명령어 수행 | 1클럭 내외로 명령어 수행|
|파이프라이닝하기 어려움|파이프라이닝하기 쉬움|
