### 비순차적 명령어 처리
마지막으로 알아볼 명령어 병렬 처리 기법은 `비순차적 명령어 처리(OoOE : Out-of-order execution)`이다. 보통 OoOE로 줄여 부른다. 이 기법은 오늘날 CPU 성능 향상에 크게 기여한 기법이자 대부분의 CPU가 차용하는 기법이기에 중요하다.

비순차적 명령어 처리 기법은 이름에서도 알 수 있듯이 명령어들을 순차적으로 실행하지 않는 기법이다. 명령어의 '합법적인 새치기'라고 볼 수 있다. 지금까지 살펴본 명령어 파이프라니잉, 슈퍼스칼라 기법은 모두 여러 명령어의 순차적인 처리를 상정한 방법이었다. 프로그램을 위에서 아래로 차례차례 실행하는 방식이었다. 하지만 파이프라인 위험과 같은 예상치 못한 문제들로 인해 이따금씩 명령어는 곧바로 처리되지 못하기도 한다. 만약 모든 명령어를 순차적으로만 처리한다면 이런 예상치 못한 상황에서 명령어 파이프라인은 멈춰버린다.

예를 들어 아래와 같은 명령어들로 이루어진 소스 코드가 있다고 하자. 편의상 '메모리 N번지'는 M(N)으로, '메모리 N번지에 M을 저장하라'는 M(N) <- M 으로 표기한다.

```
1. M(100) <- 1
2. M(101) <- 2
3. M(102) <- M(100) + M(101)
4. M(150) <- 1
5. M(151) <- 2
6. M(152) <- 3
```

여기서 주목 할 점은 3번 명령어를 실행하기 위해서는 M(100) 값은 물론 M(101) 값이 결정 되어야 하기에 1번과 2번 명령어 실행이 끝날 때까지 기다려야 한다는 점이다.

이 명령어들을 순차적으로 실행되는 CPU로 실행하면 다음 그림과 같다. 2번 명령어 실행이 끝날 때까지 3, 4, 5, 6번 명령어들은 기다린다.

![[‎명령어 파이프라인.‎005.jpeg]]

잠깐 생각해보자. 앞의 코드를 이루는 명령어들 중에 서로 데이터 의존성이 전혀 없는, 순서를 바꿔 처리해도 수행 결과에 영향을 미치지 않는 명령어들이 있다.

가령 3번은 다음과 같이 뒤의 명령어와 순서를 바꾸어 실행해도 크게 문제될 것이 없다. 이렇게 순서를 바꿔 실행하면 아래와 같이 수행된다. 순차적으로 명령어를 처리할 때보다 더 효율적으로 처리되는 것을 볼 수 있다. 이렇게 명령어를 순차적으로만 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법을 `비순차적 명령어 처리 기법`이라고 한다.

```
1. M(100) <- 1
2. M(101) <- 2
4. M(150) <- 1
5. M(151) <- 2
6. M(152) <- 3
3. M(102) <- M(100) + M(101)
```

![[‎명령어 파이프라인.‎006.jpeg]]

하지만 아무 명령어나 순서를 바꿔서 수행할 수는 없다. 다음 예시를 보자.

```
1. M(100) <- 1
2. M(101) <- 2
3. M(102) <- M(100) + M(101)
4. M(103) <- M(102) + M(101)
5. M(104) <- M(100)
```

위 코드에서 3번 명령어와 1번 명령어의 순서를 바꿀 수는 없다. 3번 명령어를 수행하려면 반드시 M(100) 값이 결정되어야 한다. 마찬가지로 4번 명령어와 1번 명령어는 순서를 바꿀 수 없다. 1번 명령어를 토대로 3번 명령어가 수행되고, 3번 명령어를 토대로 4번이 수행되기 때문이다.

하지만 위 코드에서 4번 명령어와 5번 명령어는 순서를 바꾸어 실행할 수 있다. 다시 말해 이 두 명령어는 어떤 의존성도 없기에 순서를 바꿔도 전체 프로그램의 실행 흐름에는 영향이 없다.

이처럼 비순차적 명령어 처리가 가능한 CPU는 명령어들이 어떤 명령어와 데이터 의존성을 가지고 있는지, 순서를 바꿔 실행할 수 있는 명령어에는 어떤 것들이 있는지를 판단할 수 있어야 한다.