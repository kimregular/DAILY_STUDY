> 실무에서는 대형 프로젝트의 초반에 알고리즘 때문에 문제가 생기지 않는다. 오히려 프로그래머가 더 이상 어떻게 진행해야 할지 모르게 되거나 현재 짜놓은 프로그램이 부적합하다는 사실이 갑자기 명백해질 때, 하위 문제로 모습을 드러내곤 한다. - 스티븐 S. 스키에나

## 상황
당신은 빠듯한 마감 기한과 수많은 도구가 사용되는 복잡한 소프트웨어 프로젝트의 세계에 살고 있다. 당신의 고용주들은 모든 역할마다 전문가를 넉넉히 고용하는 사치를 누릴 여유가 없다. 당신은 각종 도구 들을 겨우 지금 하는 작업을 완료하는 데 필요한 정도로만 배우고 있다. 우선 오늘의 작업에 사용할 언어나 라이브러리에 관련된 튜토리얼을 한 움큼 고른다. 그리고 시간을 들여 거기에 내재된 이슈를 이해하지도 않은 채 이런 결정을 내리고, 튜토리얼에 함께 제공된 장난감 예제를 그냥 복사해다 써 버린다. 이런 방식은 당신이 여러 분야로 손을 뻗칠 수 있는 한도까지는 먹혀들 것이다. 당신은 새로운 기술 분야에 뛰어들어서 아주 빨리 해결책을 찾아내는 능력을 지녔다. 당신은 자기가 맡은 부분이 동작하는 데 필요한 것만 공부하고, 그 나머지는 팀의 다른 멤버들에게 의존하고 있다. 예를 들면 당신은 서버쪽 자바 개발자인데, 사용자 인터페이스가 어떻게 구성되는지는 거의 또는 완전히 모르고 있다.

## 문제
당신은 자기 코드를 유지보수 하면서도 계속 난관에 봉착하는데, 당신이 공부했던 튜토리얼들이 실은 필요한 절차도 대충 건너뛰었으며 복잡한 이슈를 단순화했었다는 사실이 드러났기 때문이다. 수많은 도구들에 대한 피상적인 지식만 있다면, 미묘한 버그가 발생하거나 깊은 지식이 필요한 일을 할 때 늘 어쩔 줄 몰라 허둥대야 한다는 것을 알게 되었다. 기존 웹 서비스를 확장한 몇 주 정도의 경력을, 상호 운용적이며 고도의 확장성을 갖춘 대규모 시스템 유지보수 중에 나온 이슈에 대해 깊이 있게 아는 것과 구분하지 않았기 때문에, 사람들은 종종 당신의 이력서에 오해의 소지가 있다고 비난한다. 더 나쁜 상황은, 당신의 지식이 너무나 피상적이라서, 어떤 계기나 누군가 때문에 시험에 들기 전까지는 자기가 아는 바가 얼마나 없는지 자각조차 못하는 것이다.

## 해결책
도구나 기술 분야, 각종 기법 같은 것을 깊이 파고드는 법을 배워라. 왜 그런식으로 되어 있는지 알게 될 때까지 지식의 깊이를 더해 가라. 여기서 깊이라함은 세부적인 설계보다는 그런 설계에 이르게 한 요인을 이해하는 것을 의미한다. 예를 들어 타입 이론에 대해서 다른 사람들이 하는 얘기를 뜻도 모르고 흉내내기보다 이해하려고 노력하는 일처럼 말이다.

우리의 예전 동료 중 어떤 이가 다음과 같이 말했다.

> 동시성의 다양한 형태 (및 그 한계)에 대해서 아는 것이, 'subclass Thread나 implement Runnable'보다 더 유용한 지식이다. (라비 모한과 나눈 대화 중에서)

어떤 분야에 깊이 있는 지식을 가졌다는 사실은 당신에게 자신감을 주며, **바닥을 쓸어라** 패턴의 적용 방식을 결정할 때 안내자 역할을 한다. 이것은 새로운 팀에 들어갔을 때 어떤 역할을 맡아야 빠른 시일 안으로 팀에 도움이 될 수 있을지 보여주기 때문이다. 더 중요한 것은, 이런 지식의 깊이가 새로운 분야에 도전할 때 기댈 언덕이 되어주며 앞으로 나갈 힘을 부여한다는 것이다. 당신은 언제라도 이렇게 얘기할 수가 있다. "EJB도 마스터했으니, 메타클래스도 문제 없을 거야."

어떤 기술 분야를 깊이 파고들 때 얻을 수 있는 또 다른 이점은, 당신이 작업하고 있는 시스템의 물밑에서 무슨 일이 일어나고 있는지 설명할 수 있게 된다는 것이다. 이런 깊이 있는 지식은 채용 면접 때 자기가 만든 소프트웨어도 의미 있게 설명하지 못하는 다른 지원자들 사이에서 당신을 돋보이게 해줄 것이다. 그들은 전체 중의 작은 일부분만을 이해하고 있기 때문이다. 일단 팀의 일원이 된 이후에, 내키는 대로 돌무더기를 쌓는("The Pragmatic Programmer" 에서는 이것을 '우연의 일치에 의한 프로그래밍'으로, 스티브 맥코넬은 '화물 숭배 cargo cult 소프트웨어 공학' 으로 부른다) 사람들과 대성당을 짓는 사람들을 구분하는 것은 이 패턴을 실천했는지 여부다.

어떻게 대성당을 짓는 이들을 분간할 수 있을까? 그들은 바로 당신의 팀 내에서 디버깅하고, 역컴파일하고, 리버스 엔지니어링하는 사람들이며, 당신이 사용하는 기술 분야에 대한 명세서, RFC, 표준 문서 같은 것을 읽는 사람들이다. 이런 사람들은 자기 관점에 변화를 경험했으며, 사용하는 도구에 대해 숙련되게 이해하고 있다.

관점이 변화하면, 시스템의 여러 층위를 뚫고 문제를 쫓아가서 '모든 것이 뜻이 통하는' 수준의 지식을 얻으려는 태도가 생겨난다. 이를테면 싱글코어에서 멀티코어로 노트북을 바꾼 뒤에 자바로 짠 동시성 테스트의 동작이 달라질 수 있다. 어떤 이들은 그저 어깨 한번 으쓱하고서 이제 그 테스트는 예측할 수 없게 동작한다고 생각하고 말 것이다. 하지만 다른 이들은 동시성 라이브러리, 자바 메모리 모델, 물리적 하드웨어 명세 같은 것을 통해 CPU 수준까지 문제를 쫓아갈 것이다.

당신이 친숙해져야 하는 도구들로는, 실행 중인 프로그램의 속을 들여다볼 수 있게 해주는 (GDB, PDB, RDB) 디버거들과 네트워크 트래픽을 볼 수 있는 (Wireshark 같은) 통신 레벨 디버거들, 그에 더해서 명세서를 기꺼이 읽고자 하는 태도가 있다. 코드뿐 아니라 명세서를 읽을 수 있게 된다는 것은, 이제 당신에게 모든 것이 드러나게 되었음을 의미한다. 이렇게 해서 당신이 사용하는 라이브러리에 관해 호된 질문을 던질 수 있게 되며, 만약 거기에 대한 대답이 마음에 들지 않는다면 스스로 재구현하거나 표준을 좀 더 준수하는 다른 대안을 찾아서 옮겨갈 수 있게 된다.

이 패턴의 사용 방법 중 하나는 근원적인 곳으로부터 정보를 얻는 것이다. 이 말은, 다음번에 혹시 누가 Representation State Transfer 즉 REST 에 대해 얘기하면, 이 경험을 REST의 원 개념이 정의된 로이 필딩의 박사 학위 논문을 읽을 이유로 생각해야 한다는 것이다. 이렇게 알게 된 것을 명확히 하거나 공유하기 위해서, 그리고 다른 이에게도 원 문서를 읽도록 격려하기 위해서 블로그에 글로 정리해 보라.

원래의 IETF RFC 문서를 링크하고 있는 위키 백과 페이지, 그것을 다시 언급한 기사 글을 알기 쉽게 풀어서 써 놓은 책을 인용하는, 그런 사람의 말을 그대로 받아들이지 말라. 어떤 개념을 정말로 이해하려면 그 개념이 최초로 언급된 당신의 전후 맥락을 재구성해 볼 필요가 있다. 이렇게 해야 개념의 정수가 그 모든 중간자를 거치고도 살아남았음을 확인할 수 있다.

그 아이디어를 누가 처음 생각해 냈는지 조사해 보고, 그들이 풀려고 했던 문제가 무엇이었는지 이해하라. 이와 같은 맥락에 관한 내용은 보통 그 개념이 전달되는 과정에서 사라진다. 새로운 듯한 개념이지만 실은 오래 전에 폐기된 경우를 가끔 찾을 수 있는데, 거기에는 종종 합당한 이유가 달려있기도 하다. 하지만 본래의 맥락을 읽어버린 탓에 그 후로 오랫동안 그 개념은 모두에게 잊힌 채 지내왔다. 수년 간 서로서로 선택적으로 인용해 오고 있는 일련의 사람들보다는, 그런 개념의 원래 출처가 훨씬 나은 교사 역할을 한다는 사실을 앞으로 자주 깨닫게 될 것이다. 어떻든 간에, 유용한 개념들의 근원을 따라가는 일은 중요한 연습이며, 앞으로 새로운 것을 학습할 때 많은 도움을 주는 습관이 될 것이다.

튜토리얼을 읽을 때는, 복사해서 갖다 쓸 코드를 찾지 말고 새로 습득한 지식을 마음 속 어디에 두면 좋을지 찾도록 하라. 당신의 목표는 그 개념의 역사적인 맥락이 어떤 것인지, 그것이 다른 무언가의 특별한 경우에 해당하는지 이해하는 것이 되어야 한다. 당신이 학습 중인 주제의 이면에 혹시 어떤 전산학적 개념이 깔려 있을지, 그리고 그 개념과 당신이 사용 중인 구현본 사이에는 어떤 절충이 이루어졌는지 알아보라. 이처럼 심도 있는 지식으로 무장하고 나면, 나중에 문제에 맞닥뜨렸을 때 처음의 튜토리얼 수준은 넘어 설 수 있을 것이다.

예를 하나 들면, 사람들은 정규 표현식에 대해 피상적인 이해만 가지고 있어서 가끔 곤란한 처지에 빠지기도 한다. 당신은 DFA와 NFA의 차이점을 확실히 알지못하더라도 몇 년, 아마도 수십 년은 아무 일 없이 지낼 수 있을 것이다. 그러다가 어느 날 당신의 위키가 동작을 멈춰 버린다. 조사해 보니 정규 표현식 엔진이 재귀적으로 구현된 경우에, 백트래킹을 필요로 하는 특정한 입력값이 들어오면 아주 오랫동안 실행되다가 결국 StackOverflowException을 내고 만다는 것을 알게 된다. 애디는 이 사실을 힘들게 알아냈는데, 다행히도 실제 환경이 아니라 그가 만든 장난감 버전에서 일어난 일이었다.

이와 같이 기술과 도구에 대한 심도 있는 이해에 초점을 맞출 때는, 뜻하지 않게 좁은 한 가지 분야에 대한 전문가의 길로 빠져 버리는 일이 없도록 주의를 기울여야 한다. 당신의 목표는, 소프트웨어 개발의 여러 측면이 지닌 상대적인 중요도에 대한 관점을 잃지 않으면서, 어떤 문제를 해결하는 데 필요한 전문 지식을 가능한 한 많이 습득하는 것이다.

이 패턴을 적용할 때 당신이 배우게 될 사실 한 가지는, 심도 있는 지식을 얻는 일은 힘이 든다는 것이다. 대부분의 사람들이 소프트웨어 개발을 받쳐주는 아주 폭넓은 전산학적 지식을 갖고 있지만 그 깊이는 그토록 얕은 이유가 여기에 있다. 스스로 기초 지식을 애써가며 배우기보다는 다른 사람들에게 의지하는 편이 물론 더 쉽고 때로는 더 유리하기도 하다. 당신은 필요하면 언제라도 배울 수 있다고 말할지 모른다. 그러나 주말 전에 모든 것을 알아내야 하는데 사전 지식을 배우는 데만 한 달은 필요한 상황이 닥칠지도 모르는 일이다.

표면적인 지식만 가졌을 때 초래될 수 있는 또 다른 결과는, 풀려고 하는 문제에 대해 잘 알려진 해법이 있는지 혹은 실질적으로 해결이 불가능한 문제인지 전혀 모를 수가 있다는 것이다 (후자의 경우 왜 그것이 불가능하며 해결 가능하게 만들려면 문제를 어떤 식으로 재정의해야 하는지에 대해 쓴 수많은 연구 논문들이 있을 것이다). 수박 겉핥기식으로만 해서는 지금 모르는 것을 앞으로도 모를 것이며, 자기 지식의 한계가 어디까지인지 이해하지 않고 새로운 것을 깨달을 수는 없다. 어떤 문제에 대해 모든 층위를 통틀어 조사하는 과정에서 밑바닥에 깔려 있던 전산학적 개념들이 드러나는 일이 흔하다. 전산학자들의 연구는 실용적으로 보이지 않을 수도 있다. 하지만 가장 진보된 이론을 현실 세계에 적용 할 수 있다면, 다른 사람에게는 마법처럼 보이는 일을 할 능력을 얻게 된다. 단지 알고리즘이나 자료구조를 바꿨을 뿐인데, 몇 달씩 걸리던 배치 작업이 마우스 버튼을 다 누르기도 전에 끝날 수도 있다. List, Set, HashMap 만 알던 사람이라면, 당면한 문제를 해결하기 위해서 트라이 자료구조가 필요하다는 사실은 깨닫지 못한다. 그러는 대신에 '최장 일치 접두어 검색' 같은 문제는 원래 너무나 어려운 거라고 단정짓고서, 그냥 포기해 버리거나 그 기능의 우선순위를 낮출 수 있는지 알아보려 할 것이다.

이 패턴을 정기적으로 실천한다면, 당신은 자기 도구가 어떻게 동작하는지 진정으로 이해하는 사람들 중 하나가 될 것이다. 당신은 더 이상 코드 조각을 짜깁기 해놓고서 일이 되게 하려고 다른 사람들이 마법을 부려 주기를 바라지는 않을 것이다. 하지만 주의할 점이 있다. 당신은 같이 일하는 프로그래머들 대부분과 구별될 것이고, 그 논리적인 귀결로 가장 어려운 과제들을 맡게 될 것이라는 점이다. 그 결과 당신은 완전히 실패하거나 눈부시게 성공하거나 둘 중 하나가 될 가능성이 크다. 덧붙이자면, 이런 지식을 얻었다고 거만을 부려서는 안 된다. 그러는 대신에 **가장 뒤떨어진 사람**이 될 기회를 계속 찾아라. 사물을 분석적으로 보는 능력에 안주하지 말고, 그런 기초적인 구성 요소를 가지고 유용한 도구를 만드는 일에 한번 도전해 보라.

## 실천 방안
HTTP 1.1을 기술하고 있는 RFC2616과, 1976년 1월 당시에는 최첨단이었던 원격 프로시저 호출을 기술한 RFC 707을 찾아서 읽어라. HTTP에 대해 얻은 심도 있는 지식을 바탕으로, RFC 707에 의해해서 RPC 클라이언트와 서버 프로그램을 구현해 보라. 당신이 RFC 707의 저자들이 논했던 절충점에 대해 제대로 이해했다는 생각이 들면, 같은 개념을 현대에 와서 구현한 오픈소스 프로젝트들, 예를 들면 페이스북에 사용되고 있는 Apache Thrift 프레임워크 같은 것을 검토해 보라. 그렇게 상당히 정통해진 입장에서, 지난 30년간 원격 프로시저 호출과 분산 시스템 분야에서 우리 지식이 어떻게 발전해 왔는지를 주제로 블로그에 글을 써라.

이제, RPC에 대한 스티브 비노스키의 글을 읽어라. 당신이 얼마나 깊이 이해하고 있는지 지금도 의혹이 드는가? 당신의 의구심과 현재 이해 수준에 대해 블로그에 글을 올려라.

## 관련 항목
가장 뒤떨어진 이가 되라
바닥을 쓸어라