## 불안함을 느끼는 경우 : b1 난이도 낮추기
b1은 불안함을 느낄 때 난이도를 낮춰서 몰입 영역으로 들어가는 전략입니다.

간단하면서 효과적인 방법은, 자신이 맡은 일의 가장 간단하면서 핵심적인 결과물, 즉 아기 버전을 첫 번째 목표로 삼는 겁니다. 애자일에서 말하는 WTSTTCPW와 같습니다. 테트리스를 만들어야 하는데 불안함이 엄습해 온다면, 일단 화면 한가운데에 네모난 사각형 하나 그리기를 목표로 합니다. 그걸 완성하면 난이도를 조금 올려서, 좌우 화살표를 누르면 방향에 따라 그 사각형이 움직이게 합니다(물론 화면을 벗어났을 때 처리는 무시). 이때 주의할 것은 자료구조나 회전 알고리즘을 먼저 완성하는 게 아니라는 점입니다. 테트리스의 핵심을 살아있으면서도 간단한, 아기 버전의 테트리스를 만드는 것입니다. 

제가 흠모하는 프로그래머 P 님의 경우 (P 님이 작성한 코드를 보고 같은 회사 사람이 감동해서 눈물을 흘렸다는 전설도 있습니다) 대학 시절 알고리즘 수업을 들었는데 그때 사용한 전략이 이 유형에 속합니다. 그 수업에서는 매주 알고리즘 코딩 퀴즈를 내고 학생들이 서버에 제출한 답안을 자동 채점해서 학점을 줬다고 합니다. 채점의 기준은 이렇습니다.

1) 얼마나 일찍 제출했는가
2) 얼마나 많은 테스트 케이스를 통과하는가
3) 얼마나 빠른가

로 점수를 매겨 세 가지 조건을 합산했습니다. P 님은 특이한 전략을 취해서 학기 내내 거의 1등을 놓치지 않았다고 합니다. 기본적으로 과제는 C 언어로 작성해야 했는데, P 님은 남들이 C 언어로 하나 작성할 때 자신은 파이썬으로 한 번, 그리고 그걸 C 언어로 한번 해서 총 두 개의 프로그램을 만들었습니다. 파이썬은 스크립트 언어인지라 로우 레벨에 신경 쓰지 않고 알고리즘 자체에만 신경을 쓰고 프로그래밍할 수 있습니다. P 님은 상대적으로 쉬운 언어를 쓰면서 과제의 난이도를 일시적으로 낮추어 몰입을 경험했습니다. 같은 프로그램을 두 번 만들면서 학습 효과가 생겨 실력도 높아지니 C 언어로 작업할 때에 복리 이익을 얻을 수 있었죠.

한 연구에서는 피실험자를 A 그룹과 B 그룹으로 나누어 A 그룹은 어려운 코딩 문제를 먼저 풀게 한 다음 쉬운 문제를 풀게 했고, 반대로 B 그룹은 쉬운 문제를 먼저 풀고 어려운 문제를 풀게 했습니다. 두 그룹은 서로 순서만 다르지 동일한 문제를 풀었습니다. 결과는 어땠을까요? 작성 시간에서는 유의미한 차이가 없었으나 **결함 수에 엄청난 차이**가 있었습니다. B 그룹이 A 그룹보다 절반 이하의 결함을 만들었습니다. 난이도를 낮춘 결과 학습 효과가 생겨 이득을 얻은 것으로 볼 수 있습니다. 유사한 연구로 유지보수 작업에서 어려운 작업을 먼저 시작하냐, 쉬운 작업을 먼저 시작하냐에 따른 수행 시간과 정확도(얼마나 올바르게 수정했는가) 비교 연구에 따르면 쉬운 작업을 먼저 할 경우 수행 시간 차이는 없으나 정확도가 높아졌습니다.


\* What's the Simplest Thing That Could Possibly Work? 라는 질문의 두문자어이고, 작업을 시작할 때 "동작할 수 있는 가장 간단한 건 뭘까?"하고 서로 묻는 걸 말합니다. 여기에서 '가장 간단한' 이라는 부분과 '수도 있는'이라는 부분의 조합이 핵심입니다. 자세한 내용은 워드 커닝햄 인터뷰를 참고하세요.