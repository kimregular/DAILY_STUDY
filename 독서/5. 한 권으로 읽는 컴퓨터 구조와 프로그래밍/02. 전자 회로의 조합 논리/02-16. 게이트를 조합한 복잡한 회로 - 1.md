게이트를 사용하면서 하드웨어 설계 과정이 아주 단순해졌다. 사람들은 더 이상 개별 부품을 가지고 회로를 설계할 필요가 없다. 예를 들어, 입력이 2개인 NAND 게이트를 설계하려면 대략 10가지 부품이 필요하다. 하지만 7400 IC는 소규모 집적 회로(SSI)라 불리는 한 패키지 안에 네 가지 NAND 게이트를 제공한다. 따라서 이 패키지 하나는 40개의 부품을 대신 할 수 있다.

하드웨어 설계자들은 SSI 게이트를 사용해 자신들이 개별적인 부품을 사용해 설계할 때와 마찬가지로 어떤 것이든 만들 수 있다. 그리고 개별 부품을 사용하는 것보다 더 싸고 더 작게 원하는 시스템을 만들 수 있다. 그리고 게이트의 조합 중에는 특히 자주 사용되는 조합이 있다. 중간 규모 집적 회로(MSI)라고 불리는 부품은 이런 게이트 조합을 제공하기 위해 도입됐다. MSI를 사용하면 필요한 부품의 수를 더 줄일 수 있다. 나중에는 대규모 집적 회로(LSI)나 초대규모 집적 회로(VLSI) 등이 나왔다.

이제부터 몇 가지 게이트 조합을 살펴볼 것이다. 하지만 여기서 살펴보는 조합이 부품을 키워나가는 방식의 전부는 아니다. 작은 프로그램을 조합해 더 크고 복잡한 컴퓨터 프로그램을 만들어내는 것처럼, 이런 (게이트 조합으로 만든) 고수준의 기본 기능 요소를 사용해 더 고수준의 부품을 만들 수 있다.

## 가산기
2의 보수 가산기(덧셈 기계)를 만들어보자. 여러분이 가산기를 직접 설계할 필요는 전혀 없겠지만, 이 예제를 살펴보면 논리를 영리하게 조작할 경우 성능을 얼마나 많이 향상할 수 있는지(이 말은 소프트웨어든 하드웨어든 관계없이 참이다) 볼 수 있다.

1장에서 두 비트를 더한 값은 각 비트의 XOR 이고 올림은 두 비트의 AND라는 사실을 배웠다. 그림 2-39는 이를 게이트로 구현한 것이다.

그림 2-39 반가산기\
![그림 2-39 반가산기](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQjl2os-T68eSnZuTGHhIhwtMs2NXJoq0bDfw&s)

그림에서 더한 값을 계산하는 XOR 게이트와 올림을 계산하는 AND 게이트를 볼 수 있다. 그림 2-39를 반가산기(half adder)라고 부른다. 무언가 빠진 부분이 있어서 가산기에 '반'이라는 접두사가사 붙었다. 두 비트를 더할 때는 반가산기만으로도 충분하지만, (다른 자리에서 올라오는) 올림을 처리하려면 세 번째 입력이 필요하다. 따라서 각 비트의 합을 계산하기 위해 반가산기를 2개 연결할 수도 있지만, 이보다 더 잘 할 수도 있다. 세 입력 중 2개 이상이 1일 때 올림이 발생한다. 표 2-1은 이를 고려한 전가산기(full adder)의 진리표다.

표 2-1 전가산기 진리표\
![표 2-1 전가산기 진리표](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTQ3-r6bkM-587cTNW6-5ikgU6E37dk0zfw3DnmAQmvcbYah2WCo9fUPM1Vcvw52Hqd4oc&usqp=CAU)

이 표를 바탕으로 그림 2-40 처럼 전가산기 회로를 구성하면 반가산기를 2개 사용할 때보다 시간 지연이 적은, 더 나은 회로를 만들 수 있다.

그림 2-40 전가산기\
![그림 2-40 전가산기](https://velog.velcdn.com/images/kmw89891/post/cb486b93-c6ba-47e9-b32a-9f2183d6925a/image.png)

그림을 보면 더 많은 게이트가 필요함을 알 수 있다. 하지만 이제 전가산기가 있기 때문에 여러 비트를 더하는 가산기를 만들 수 있다. 그림 2-41은 리플 자리올림 가산기를 보여준다.

그림 2-41 리플 자리올림 가산기\
![그림 2-41 리플 자리올림 가산기](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQ1W47G5fti1QyRDdUkUkfvVr5hG2VCTVx4Bg&s)

리플 자리올림 가산기는 자리올림이 아래쪽 비트로부터 바로 위쪽 비트로 물결이 퍼져나가는 것처럼 전달되기 때문에 붙은 이름이다. 이 가산기는 잘 작동하지만, 그림을 보면 비트를 하나 처리할 때마다 게이트 2개에 해당하는 출력 시간 지연이 발생한다는 사실을 알 수 있다. 32비트나 64비트 가산기를 만든다면 이 지연 시간의 합이 빠르게 커진다. 올림 예측 가산기를 사용하면 이런 지연을 제거할 수 있다. 올림을 예측하는 방법이 어떻게 동작하는지를 보기위해 간단한 산수 계산을 해보자.

그림 2-40을 보면 i번째 비트의 전가산기 올림 출력이 i + 1 번째 비트의 올림 입력으로 들어간다는 사실을 알 수 있다.

$$C_{i + 1} = (A_iANDB_i)OR(A_iANDC_i)OR(B_iANDC_i)$$

여기서 큰 문제는 $C_{i + 1}$을 계산하기 위해 $C_i$가 필요하다는 점이다. 이로 인해 리플이 발생한다. $C_{i+2}$에 대한 다음 식을 봐도 이 사실을 확인할 수 있다.

$$C_{i + 2} = (A_{i+1}ANDB_{i+1})OR(A_{i+1}ANDC_{i+1})OR(B_{i+1}ANDC_{i+1})$$

두 번째 식에 첫 번째 식을 대입하면 의존관계를 줄일 수 있다. 결과는 다음과 같다.

$$C_{i + 2} = (A_{i + 1}ANDB_{i + 1}OR(A_{i + 1}AND((A_iANDB_i)OR(A_iANDC_i)OR(B_iANDC_i)))OR(B_{i + 1}AND((A_iANDB_i)OR(A_iANDC_i)OR(B_iANDC_i)))$$

여기서 AND와 OR이 아주 많아지지만 전파 지연은 최대 게이트 2개에 해당한다는 사실에 유의하라. $C_n$은 오직 A와 B 입력에 따라 결정되며, 이에 따라 올림을 계산하는 시간이 비트 개수에 따라 달라지지 않게 되고, 그로 인해 전체 덧셈에 걸리는 시간도 일정한 수준으로 고저오딘다. $C_{i+1}$은 항상 $C_n$으로부터 만들어낼 수 있고, n이 커지면 게이트 수가 점점 더 늘어난다. 게이트는 값이 저렴하지만 전력이 소모된다. 따라서 계산 속도와 전력 소모 사이에 트레이드 오프 관계가 존재한다.