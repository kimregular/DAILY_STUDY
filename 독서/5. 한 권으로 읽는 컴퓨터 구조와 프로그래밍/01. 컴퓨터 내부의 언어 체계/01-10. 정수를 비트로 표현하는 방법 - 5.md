### 2의 보수
특별한 하드웨어를 추가할 수 없고 XOR과 AND 연산만 사용해야 한다면 어떻게 일반 정수 사이의 덧셈을 할 수 있을까? +1에 더했을 때 0이 나오는 비트 패턴을 찾고 이 패턴을 -1 이라고 불러보자. 4비트 수의 경우 +1은 0001이다. 그럼 아래 그림처럼 1111을 0001에 더하면 0000이 된다. 따라서 앞으로는 1111을 (4비트에서) -1을 표현하는 비트 패턴으로 사용하자.

![[Two's complement.001.jpeg]]

이런 표현법을 `2의 보수 (two's complement)` 표현법이라고 하며, 이 방법은 부호가 있는 정수를 표현할 때 가장 널리 쓰이는 방법이다. 어떤 수의 비트를 뒤집고(즉 각 비트의 NOT 을 취하고) 1을 추가하면 음수를 얻을 수 있다. 이때 MSB에서 올림이 발생하면 이 값은 버린다. +1, 즉 0001의 비트를 뒤집으면 1110이고, 여기에 1을 더하면 111이 되며, 이 값이 -1을 표현한다. 비슷하게 +2는 0010이고, 비트를 뒤집으면 1101이며, 1을 더하면 1110이며, 이 값이 -2를 표현한다. 아래 표는 -8부터 7까지 16가지 수에 대한 2의 보수 표기를 보여준다.

|부호 |2^2|2^1|2^0 | 10 진수|
| ---| --- | --- |--- |--- |
|0| 1|1 |1 |+7 |
|0| 1|1 |0 |+6 |
|0| 1|0 |1 |+5 |
|0| 1|0 |0 |+4 |
|0| 0|1 |1 |+3 |
|0| 0|1 |0 |+2 |
|0| 0|0 |1 |+1 |
|0| 0|0 |0 |+0 |
|1| 1|1 |1 |-1 |
|1| 1|1 |0 |-2 |
|1| 1|0 |1 |-3 |
|1| 1|0 |0 |-4 |
|1| 0|1 |1 |-5 |
|1| 0|1 |0 |-6 |
|1| 0|0 |1 |-7 |
|1| 0|0 |0 |-8 |

2의 보수에는 0의 중복 표현 문제가 없는지 0을 가지고 살펴보자. 0000의 모든 비트를 뒤집으면 1111을 얻는다. 1111에 1을 더하면 \[1\]0000 이 되는데 이 숫자는 5비트 이므로 우리가 사용할 수 있는 4비트보다 크다. 따라서 1을 올림 비트로 생각하고 무시한다. 결과는 0000인데 이 값은 처음에 시작한 0과 같다. 따라서 2의 보수 표현법에서는 0을 표현하는 방법이 하나뿐이다. 

프로그래머들은 자신이 다뤄야 하는 수를 표현하기 위해 필요한 비트의 개수를 알 필요가 있다. 그래서 프로그래머들은 거의 본능처럼 이런 계산을 수행한다. 반면 여러분은 아래 표를 참조하면 된다. 아래 표는 여러 가지 크기의 2의 보수를 사용해 표현할 수 있는 값의 범위를 보여준다.

|비트개수 |값의 개수|값의 범위| 
| ---| --- | --- | 
|4| 16|-8 ~ 7 | 
|8| 256|-128 ~ 127 | 
|12| 4,096|-2,048 ~ 2,047 | 
|16| 65,536|-32,768 ~ 32,767 | 
|20| 1,048,576|-524,288 ~ 524,287| 
|24| 16,777,216|-8,388,608 ~ 8,388,607| 
|32| 4,294,967,296|-2,147,483,648 ~ 2,147,483,647 | 
|64| 18,446,744,073,709,551,616|-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | 

위 표를 보면 알 수 있는 것처럼 비트 개수가 커지면 표현할 수 있는 값의 범위가 지수적으로 증가한다. 이번 절에서 배운 내용 중에 우리가 같은 숫자로 이뤄진 수를 보더라도 문맥에 따라 표현하는 값이 달라질 수 있다는 점을 꼭 염두해 둬야 한다. 예를 들어, 2진수 1111은 2의 보수에서는 -1이지만 부호의 크기 표기로는 -7이고 1의 보수에서는 -0이다. 따라서 여러분이 사용하는 표현법을 반드시 알고 있어야 한다.