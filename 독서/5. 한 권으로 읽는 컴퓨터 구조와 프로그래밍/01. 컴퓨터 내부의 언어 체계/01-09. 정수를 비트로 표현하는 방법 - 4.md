### 1의 보수
음수를 표현하는 또 다른 방법으로는 양수의 모든 비트를 뒤집는 방법이 있다. 이런 방법을 `1의 보수(one's complement)` 표현법이라고 부른다. 1의 보수 표현법에서도 부호와 크기 표현법과 비슷하게 비트들을 부호 비트와 나머지로 나눈다. 1의 보수라는 문맥에서는 NOT 연산을 통해 보수를 얻는다. 아래 표는 1의 보수 표현법으로 -7부터 7까지의 수를 표현하는 방법을 보여준다.

|부호 |2^2|2^1|2^0 | 10 진수|
| ---| --- | --- |--- |--- |
|0| 1|1 |1 |+7 |
|0| 1|1 |0 |+6 |
|0| 1|0 |1 |+5 |
|0| 1|0 |0 |+4 |
|0| 0|1 |1 |+3 |
|0| 0|1 |0 |+2 |
|0| 0|0 |1 |+1 |
|0| 0|0 |0 |+0 |
|1| 1|1 |1 |-0 |
|1| 1|1 |0 |-1 |
|1| 1|0 |1 |-2 |
|1| 1|0 |0 |-3 |
|1| 0|1 |1 |-4 |
|1| 0|1 |0 |-5 |
|1| 0|0 |1 |-6 |
|1| 0|0 |0 |-7 |

표를 보면 0111(+7)의 각 비트를 뒤집으면 1000(-7)을 얻을 수 있음을 알 수 있다.

1의 보수 표현법에도 0을 두 가지 방식으로 표현한다는 문제가 여전히 존재한다. 게다가 1의 보수에서도 덧셈을 쉽게 할 수는 없다. 이 문제를 해결하려면 MSB 쪽에서 올림이 발생한 경우에는 LSB로 올림을 전달해야 하는데, 이를 `순환 올림(end-around carry)`이라고 부른다. 아래 식은 이런 계산 방법을 보여준다.

![[One’s Complement.001.jpeg]]

1의 보수를 사용해 +2와 -1을 더하려면 0010과 1110의 덧셈을 일반적인 (양수) 덧셈처럼 계산하면 된다. MSB(부호 비트)를 더하면 10이 나오기 때문에 0을 부호 비트에 쓰고 1을 순환 올림으로 LSB에 더한다. 최종 결과는 0000에 1을 더한 0001이 되고, 이 값은 실제로 +2와 -1을 더한 값과 같다. 여전히 이 덧셈 방법도 약간 복잡하다.

이 방식은 잘 작동하기는 하지만 순환 올림을 처리하기 위한 하드웨어를 추가해야 하기 때문에 그다지 좋은 해법은 아니다.

현대 컴퓨터에서는 부호와 크기 표현법이나 1의 보수 표현법을 모두 사용하지 않는다. 이 두 방식을 사용한 계산은 추가적인 하드웨어 없이는 제대로 작동할 수 없고, 하드웨어를 추가해야 한다는 말은 비용이 더 든다는 뜻이다. 이제는 이런 문제를 해결하는 표현법을 살펴보자.