비트 사용법 중 하나는 "날씨가 추운가?", "내 모자를 좋아하나?" 와 같은 예/아니오 질문에 대한 답을 표현하는 것이다. 이때 '예'를 `참(true)`이라는 용어로 부르고, '아니요'를 `거짓(false)`이라는 용어로 부른다. "개 파티 장소는 어디인가?" 와 같은 질문은 '예/아니요'로 답할 수 없기 때문에 한 비트만으로 표현할 수 없다.

자연어에서 여러 예/아니요 구절을 엮어서 한 문장으로 만드는 경우가 자주 있다. "밖에 비가 내리고 있거나 춥다면 코트를 입어라." 라거나, "눈이 오고, 학교에 가는 날이 아니라면 스키를 타러 가라."라고 말할 수 있다. 이 문장들을 다르게 써서 "'추운가?'가 참이거나 '비가 오고 있는가?'가 참이라면 '코트 입는다'가 참이다." 나 "'눈이 오고 있는가?'가 참이고 '학교에 가는 날인가?'가 참이 아니라면 '스키를 탄다'가 참이다."라고 할 수도 있다. 다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 이런 동작을 `논리 연산(logical operation)`이라고 한다.

## 불리언 대수
대수가 수에 대한 연산 규칙의 집합인 것처럼, 1800년대 영국 수학자 `조지 불(George Boole)`이 만들어낸 `불리언 대수(Boolean algebra)`도 비트에 대해 사용할 수 있는 연산 규칙의 집합이다. 일반 대수와 마찬가지로 결합 법칙, 교환 법칙, 분배 법칙을 불리언 대수에 적용할 수 있다.

기본적인 불리언 연산자는 NOT, AND, OR 세 가지다. 추가로 XOR 이라는 합성 연산을 마지막에 설명한다.

- NOT : 이 연산은 '논리적 반대'를 의미한다. 예를 들어, 거짓인 비트에 NOT을 하면 참이 되고 참인 비트에 NOT을 하면 거짓이 된다.
- AND : 이 연산은 둘 이상의 비트에 작용한다. 2비트 연산인 경우 첫 번째 비트가 참이고 두 번째 비트도 참인 경우에만 결과가 참이 된다. 2비트보다 더 많은 비트에 연산을 적용하는 경우 모든 비트가 참이면 AND 연산의 결과도 참이다.
- OR : 이 연산도 둘 이상의 비트에 작용한다. 2비트 연산인 경우 첫 번째 비트가 참이거나 두 번쨰 비트가 참이면 결과가 참이 된다. 2비트보다 더 많은 비트에 연산을 적용하는 경우 어느 한 비트라도 참이면 OR 연산의 결과도 참이다.
- XOR : 이 `배타적(exclusive)` OR 의 결과는 첫 번째 비트와 두 번째 비트가 다른 값인 경우에만 참이 된다. 즉 두 값 중 어느 하나가 참이면 XOR 도 참이지만 두 값이 모두 참이면 XOR 의 결과는 거짓이다. 배타적 OR을 그대로 말로 하면 너무 길기 때문에 줄여서 XOR('엑스오알'이라고 발음한다)이라고 부른다.

아래는 불리언 연산을 `진리표(truth table)`라는 틀을 사용해 시각적으로 요약해 보여준다. `입력(input)`은 박스의 밖에 있고, `출력(output)`은 박스 안에 있다. 이 표에서 T는 참(true)을, F는 거짓(false)을 나타낸다.

![[Logic Operation - Boolean algebra.001.jpeg]]

아래는 NOT과 AND 연산에 대한 진리표를 어떻게 읽는지 보여준다. 표에서 입력(또는 두 입력)의 경로를 따라가면서 입력에 해당하는 (둘 이상인 경우 두 입력이 서로 만나는) 출력을 찾으면 된다.

![[Logic Operation - Boolean algebra.002.jpeg]]

그림을 보면 알 수 있듯이 NOT 연산은 단지 입력의 상태를 반대로 반전시킬 뿐이다. 반대로 AND 연산은 두 입력이 모두 참일 때만 참을 돌려준다.

### 참고
서로 다른 연산을 사용해 XOR 연산을 만들 수 있다. 예를 들어, 두 비트에 대한 XOR 연산 `(a XOR b)`은 `(a OR b) AND (NOT(a AND b))` 와 같다. 이를 통해 기본 불리언 연산을 다양한 방식으로 조합해 똑같은 결과를 얻을 수 있다는 사실을 알 수 있다.