지금까지 회원에서 팀으로만 접근하는 다대일 단방향 매핑을 알아보았다. 이번에는 반대 방향인 팀에서 회원으로 접근하는 관계를 추가하자. 그래서 회원에서 팀으로 접근하고 반대 방향인 팀에서도 회원으로 접근할 수 있도록 양방향 연관관계로 매핑해보자.

회원과 팀은 다대일 관계다. 반대로 팀에서 회원은 일대다 관계다 일대다 관계는 여러 건과 연관관계를 맺을 수 있으므로 컬렉션을 사용해야 한다. Team.members 를 List 컬렉션으로 추가한다.

객체 연관관계를 정리하면 아래와 같다.
- 회원 -> 팀 : Member.team
- 팀 -> 회원 : Team.members

테이블의 관계는 어떻게 될까? 데이터베이스 테이블은 외래 키 하나로 양방향으로 조회할 수 있다. 두 테이블의 연관관계는 외래 키 하나만으로 양방향 조회가 가능하므로 처음부터 양방향 관계다. 따라서 데이터베이스에 추가할 내용은 전혀 없다.

## 양방향 연관관계 매핑
양방향 연관관계를 매핑하자. 먼저 회원 엔티티이다.

```java
@Entity
public class Member{

	@Id
	@Column(name = "MEMBER_ID")
	private Long id;

	private String username;

	@ManyToOne
	@JoinColumn(name = "TEAM_ID")
	private Team team;
}
```

```java
@Entity
public class Team{

	@Id
	@Column(name = "TEAM_ID")
	private Long id;

	private String name;
	
	@OneToMany(mappedBy = "team")
	private List<Member> members = new ArrayList<>();
}
```

팀과 회원은 일대다 관계다. 따라서 팀 엔티티에 컬렉션인 `List<Member> members` 를 추가했다. 그리고 일대다 관계를 매핑하기 위해 `@OneToMany` 매핑 정보를 사용했다. mappedBy 속성은 양방향 매핑일 때 사용하는데 반대쪽 매핑의 필드 이름을 값으로 주면 된다. 반대쪽 매핑이 `Member.team` 이므로 `team` 을 값으로 주었다.

## 연관관계의 주인
`@OneToMany` 는 직관적으로 이해가 될 것이다. 문제는 `@ManyToOne` 속성이다. 단순히 `@OneToMany` 만 있으면 되지 `mappedBy` 는 왜 필요할까?

엄밀히 이야기하면 객체에는 양방향 연관관계라는 것이 없다. 서로 다른 단방향 연관관계 2개를 애플리케이션 로직으로 잘 묶어서 양방향인 것처럼 보이게 할 뿐이다. 반면에 데이터베이스 테이블은 앞서 설명했듯이 외래 키 하나로 양쪽이 서로 조인할 수 있다. 따라서 테이블은 외래 키 하나만으로 양방향 연관관계를 맺는다.

객체 연관관계는 다음과 같다.
- 회원 -> 팀 연관관계 1개(단방향)
- 팀 -> 회원 연관관계 1개(단방향)

테이블 연관관계는 다음과 같다.
- 회원 <-> 팀 연관관계 1개(양방향)

엔티티를 단방향으로 매핑하면 참조를 하나만 사용하므로 이 참조로 외래 키를 관리하면 된다. 그런데 엔티티를 양방향으로 매핑하면 회원 -> 팀, 팀 -> 회원 두 곳에서 서로를 참조한다. 따라서 객체의 연관관계를 관리하는 포인트는 2곳으로 늘어난다. 

엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래 키는 하나다. 따라서 둘 사이에 차이가 발생한다. 그렇다면 둘 중 어떤 관계를 사용해서 외래 키를 관리해야 할까?

이런 차이로 인해 JPA에서는 두 객체 연관관계 중 하나를 정해서 테이블의 외래 키를 관리해야 하는데 이것을 연관관계의 주인이라 한다.

## 양방향 매핑의 규칙 : 연관관계의 주인
양방향 연관관계 매핑 시 지켜야 할 규칙이 있는데 두 연관관계 중 하나를 연관관계의 주인으로 정해야 한다. 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래 키를 관리(등록, 수정, 삭제)할 수 있다. 반면에 주인이 아닌 쪽은 읽기만 할 수 있다.

어떤 연관관계를 주인으로 정할지는 mappedBy 속성을 사용하면 된다.
- 주인은 mappedBy 속성을 사용하지 않는다.
- 주인이 아니면 mappedBy 속성을 사용해서 속성의 값으로 연관관계의 주인을 지정해야 한다.

그렇다면 Member.team, Team.members 둘 중 어떤 것을 연관관계의 주인으로 정해야 할까?

다음 두 코드를 보자.

- 회원 -> 팀 방향
```java
public class Member{

	@ManyToOne
	@JoinColumn(name = "TEAM_ID")
	private Team team;
}
```

- 팀 -> 회원 방향
```java
public class Team{

	@OneToMany(mappedBy = "team")
	private List<Member> members = new ArrayList<>();
}
```

연관관계의 주인을 정한다는 것은 사실 외래 키 관리자를 선택하는 것이다. 여기서는 회원 테이블에 있는 TEAM_ID 외래 키를 관리할 관리자를 선택해야 한다. 만약 회원 엔티티에 있는 Member.team 을 주인으로 선택하면 자기 테이블에 있는 외래 키를 관리하면 된다. 하지만 팀 엔티티에 있는 Team.members 를 주인으로 선택하면 물리적으로 전혀 다른 테이블의 외래 키를 관리해야 한다. 왜냐하면 이 경우 Team.members가 있는 Team 엔티티는 TEAM 테이블에 매핑되어 있는데 관리해야할 외래 키는 MEMBER 테이블에 있기 때문이다.

## 연관관계의 주인은 외래 키가 있는 곳
연관관계의 주인은 테이블에 외래 키가 있는 곳으로 정해야 한다. 여기서는 회원 테이블이 외래 키를 가지고 있으므로 Member.team 이 주인이 된다. 주인이 아닌 Team.members에는 `mappedBy="team"` 속성을 사용해서 주인이 아님을 설정한다. 그리고 `mappedBy` 속성의 값으로는 연관관계의 주인인 team을 주면된다. 여기서 `mappedBy` 의 값으로 사용된 team은 연관관계의 주인인 Member 엔티티의 team 필드를 말한다.

정리하면 연관관계의 주인만 데이터베이스 연관관계와 매핑되고 외래 키를 관리할 수 있다. 주인이 아닌 반대편은 읽기만 가능하고 외래 키를 변경하지는 못한다.