엔티티를 수정하려면 영속성 컨텍스트의 변경 감지 기능이나 병합을 사용하고, 삭제하려면 `EntityManager.remove()` 메소드를 사용한다. 하지만 이 방법으로 수백 개 이상의 엔티티를 하나씩 처리하기에는 시간이 너무 오래 걸린다. 이럴 때 여러 건을 한 번에 수정하거나 삭제하는 벌크 연산을 사용하면 된다.

예를 들어 재고가 10개 미만인 모든 상품의 가격을 10% 상승시키려면 아래와 같이 벌크 연산을 사용하면 된다.

```java
String sqlString = "update Product p set p.price = p.price * 1.1 where p.stockQuantity < :stockAmount";

int resultCount = em.createQuery(sqlString)
					.setParameter("stockAmount", 10)
					.executeUpdate();
```

벌크 연산은 `executeUpdate()` 메소드를 사용한다. 이 메소드는 벌크 연산으로 영향을 받은 엔티티 건수를 반환한다.

삭제도 같은 메소드를 사용한다. 아래는 가격이 100원 미만인 상품을 삭제하는 코드다.

```java
String sqlString = "delete from Product p where p.price < :price";

int resultCount = em.createQuery(sqlString)
					.setParameter("price", 100)
					.executeUpdate();
```

## 주의점
벌크 연산을 사용할 때는 벌크 연산이 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리한다는 점에 주의해야 한다.

벌크 연산은 영속성 컨텍스트를 통하지 않고 데이터베이스에 직접 쿼리한다. 따라서 영속성 컨텍스트에 있는 상품A와 데이터베이스에 있는 상품A의 가격이 다를 수 있다. 따라서 벌크 연산은 주의해서 사용해야 한다.

이런 문제를 해결하는 방법을 알아보자.

### em.refresh()
벌크 연산을 수행한 직후에 정확한 상품A 엔티티를 사용해야 한다면 `em.refresh()` 를 사용해서 데이터베이스에서 상품A를 다시 조회하면된다.

### 벌크 연산 먼저 실행
가장 실용적인 해결책은 벌크 연산을 가장 먼저 실행하는 것이다. 예를 들어 벌크 연산을 먼저 실행하고 나서 상품A를 조회하면 벌크 연산으로 이미 변경된 상품A를 조회하게 된다. 이 방법은 JPA와 JDBC를 함께 사용할 때 유용하다.

### 벌크 연산 수행 후 영속성 컨텍스트 초기화
벌크 연산을 수행한 직후에 바로 영속성 컨텍스트를 초기화해서 영속성 컨텍스트에 남아 있는 엔티티를 제거하는 것도 좋은 방법이다. 그렇지 않으면 엔티티를 조회할 때 영속성 컨텍스트에 남아 있는 엔티티를 조회할 수 있는데 이 엔티티에는 벌크 연산이 적용되어 있지 않다. 영속성 컨텍스트를 초기화하면 이후 엔티티를 조회할 때 벌크 연산이 적용된 데이터베이스에서 엔티티를 조회한다.

## 
벌크 연산은 영속성 컨텍스트와 2차 캐시를 무시하고 데이터베이스에 직접 실행한다. 따라서 영속성 컨텍스트와 데이터베이스 간에 데이터 차이가 발생할 수 있으므로 주의해서 사용해야 한다. 가능하면 벌크 연산을 가장 먼저 수행하는 것이 좋고 상황에 따라 영속성 컨텍스트를 초기화하는 것도 필요하다.