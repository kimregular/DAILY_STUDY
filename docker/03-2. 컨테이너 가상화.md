## 시스템 구조
컨테이너 가상화는 리눅스 커널이 제공하는 LXC(LinuX Containers)라는 자체 격리 기술에서 출발했다. 이전 하이퍼바이저 가상화에서는 하이퍼바이저라는 소프트웨어가 격리된 공간을 만들어 주었다. LXC 기술을 사용하면 하이퍼바이저를 사용하지 않고도 커널의 자체 기능만 사용해서 격리된 공간을 만들 수 있다. 

LXC 기술은 커널의 네임 스페이스와 CGroups(Control groups) 라는 기능을 활용한다. 네임 스페이스는 프로세스와 하드드라이브, 네트워크, 사용자, 호스트 네임 처럼 리소스를 나누는 기준 역할을 한다. 그리고 CGroups는 프로세스가 사용하는 메모리와 CPU, 하드디스크, 네트워크 밴드위스처럼 리소스의 사용량을 배분하는 기술이다. 그리고 이런 LXC 기술을 사용해서 만들어진 각각의 격리된 공간을 컨테이너라고 부른다. 

기억할 부분은 컨테이너 가상화가 하이퍼바이저 없이 커널의 자체 기술을 활용한 가상화라는 점이다. 컨테이너 가상화는 커널의 격리 기능을 사용하기 때문에 모든 컨테이너는 호스트 os의 커널을 공유해서 사용한다. 이 호스트 os의 커널을 공유한다는 부분이 컨테이너 가상화의 가장 중요한 특징이다. 

이전 하이퍼바이저 가상화에서는 게스트 os 와 호스트 os의 커널이 독립적으로 존재했다. 그리고 하이퍼바이저 소프트웨어가 중간에서 커널 간의 통신을 지원한다고 설명했다. 각각의 시스템콜들이 하이퍼바이저의 통역을 거쳐가기 때문에 요청이 거쳐가는 단계가 늘어나게 된다. 이 단계가 많다는 특징을 오버헤드가 크다고 표현한다. 

그러나 컨테이너는 호스트 os의 커널을 그대로 사용하기 때문에 중간 단계(하이퍼바이저의 번역 단계)가 따로 없어서 하이퍼바이저 방식보다 상대적으로 오버헤드가 적다. 오버헤드가 적다는 부분은 하드웨어 리소스 사용 요청이 더 효율적으로 이루어진다고 이해하면 된다. 

그리고 하이퍼바이저 가상화에서 커널이 독립적으로 있다는 것은 이 커널을 실행하는 데 있어서 시간이 더 필요하다는 것을 의미한다. 하지만 각각의 컨테이너들은 자체적인 커널이 없고 호스트 os의 커널을 공유하기 때문에 커널을 실행하는 시간 자체가 없다. 그래서 일반적으로 컨테이너 가상화는 하이퍼바이저 가상화보다 훨씬 더 부팅 속도가 빠르다는 장점도 있다. (하이퍼바이저 약 1분, 컨테이너 약 3초)

그래서 오버헤드가 적고 부팅이 빠르다는 장점으로 모던 애플리케이션의 요구사항을 충족시킬 수 있었다. 다만 커널을 독립적으로 가지고 있는 가상 머신(하이퍼바이저)이 보안 면에서는 더 뛰어나다고 볼 수도 있다. 그리고 컨테이너는 호스트 os의 커널을 공유하기 때문에 호스트 os 와 다른 종류의 os는 실행할 수 없다는 단점도 있다. 

## 컨테이너와 프로세스의 차이
가장 큰 차이점이라면 리소스 사용량 격리이다. 예를 들어 프로세스 A, B를 실행할 경우, 프로세스 A가 호스트 os의 리소스를 100% 사용해 버린다면, 프로세스 B가 정상적으로 동작하지 못한다.

하지만 컨테이너의 경우 컨테이너 별로 리소스 사용량이 격리되어 있기 때문에, 프로세스 A가 사용할 수 있는 리소스를 100% 사용하더라도 프로세스 B가 실행되는 다른 컨테이너에는 영향을 미치지 않는다. 이러한 부분을 리소스 격리라고 부르고 이 기능은 CGroups를 통해 이루어진다.

게다가 컨테이너를 사용하면 파일시스템, 네트워크 인터페이스, 프로세스 ID, 사용자 등 다양한 수준에서의 격리가 이루어지기 때문에, 일반 프로세스를 실행하는 경우보다 훨씬 안전하다고 할 수 있다.

## LXC는 리눅스 기술인데 윈도우나 맥os에서는 어떻게 컨테이너를 사용하는지?

도커는 실제로 리눅스 커널의 기술을 사용하기 때문에, 윈도우와 맥os 에서는 기본적으로 지원되지 않는다. 그래서 도커 데스크탑은 윈도우나 맥os의 하이퍼바이저 가상화 기술을 사용한다. 윈도우/맥os 에서 리눅스 가상머신을 실행한 다음에, 그 리눅스의 커널을 사용해서 컨테이너 환경을 구성한다. 컨테이너 가상화 기술을 사용하기 위해 하이퍼바이저 가상화기술을 활용한다. 

윈도우에서는 WSL2, 맥os 에서는 HyperKit 이라는 가상화 기술을 사용한다. 그래서 `docker version`