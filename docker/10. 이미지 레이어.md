이미지는 컨테이너를 실행하기 위한 읽기 전용 파일이다. 도커 이미지는 저장소를 효율적으로 사용하기 위해서 레이어드 파일 시스템으로 구성되어있다. 레이어는 하나의 층을 의미한다. 여러 개의 층으로 구성되어 있는 것에서 하나의 층을 레이어라고 표현한다. 이미지도 여러 개의 레이어로 구성되어 있다. 

```zsh
docker run -p 80:80 nginx
Unable to find image 'nginx:latest' locally
latest: Pulling from library/nginx
aa6fbc30c84e: Pull complete
c28fc33dc48c: Pull complete
08fb08230766: Pull complete
d2983a84b0c4: Pull complete
9f4e03394720: Pull complete
522e88f665e7: Pull complete
d964500c63bd: Pull complete
```

`nginx`를 실행했을 때 출력을 살펴보자. 먼저  로컬 저장소에 이미지가 없는 것을 확인하고 도커 허브에서 이미지를 다운받는다. 화면을 잘 보면 Nginx라는 이미지를 다운받은 과정에서 풀이 여러 단계에 걸쳐서 실행됨을 볼 수 있다. 여기서 한줄한줄이 하나의 레이어를 의미한다. 이 레이어들이 모여서 하나의 이미지로 구성된다. 각각의 레이어는 이미지의 일부분을 나타낸다. 

그러면 굳이 하나의 이미지를 왜 여러 개의 레이어로 구분했을까? 레이어드 구조는 재사용하기 유리한 구조이기 때문이다. 레이어드 파일 시스템을 사용하면 공간을 효율적으로 사용할 수 있다. 그래서 이미지를 저장하고 전송할 때 스토리지와 네트워크 사용량을 절약할 수 있다. 

건축 도면을 예시로 들어보겠다. 건축 도면을 그릴 때는 투명한 도면 용지를 여러 장 준비하고 건물 구조나 가구 배치, 전기 배관처럼 각각의 주제별로 한 장씩 그리고 이 투명한 용지들을 하나로 합치면 건물에 대한 건축 설계도가 완성된다. 도면이 조경, 전기, 토목, 구조 별로 있다고 해보자. 각각의 도면(레이어)들을 합쳐서 건물 A의 완성된 설계도가 되는 것이다.

만약 설계도에서 조경 부분을 수정해야 한다고 생각해보자. 만약 설계도가 한 장의 도면으로 되어 있었다면 조경 부분을 수정하면 전체 도면이 영향을 받게 된다. 그렇지만 레이어 구조로 되어 있으면 조경 부분만 수정하면 나머지 전기, 토목, 구조 도면은 변경의 영향을 받지 않는다. 즉, 변경 사항에 있어서 재활용이 유리한 구조라는 의미이다. 

그리고 이 설계와 구조, 토목, 조경 부분이 동일하고 전기 배선만 다른 건물 B가 있다고 생각해보자. 만약 레이어드 구조가 아니었으면 설계도를 A 설계도와 B 설계도 두 장을 통째로 관리해야한다. 레이어 구조를 활용하면 겹치는 레이어는 재사용할 수 있다. 재사용하는 방안이 보관하기에도 효율적일 것이다. 그리고 이렇게 겹치는 레이어를 재사용한 상태에서 왼쪽 순서대로 읽으면 설계도 A, 오른쪽 순서대로 읽으면 설계도 B로 읽을 수 있다. 

설계도 A를 이미 가지고 있는 사람한테 설계도 B를 전달해줘야 하는 상황을 가정해보자. 설계도 A의 조경, 토목 구조가 설계도 B와 겹치기 때문에 받은 사람은 전기 한 장만 받으면 설계도 B를 만들 수 있다. 만약 레이어드 구조가 아니었으면 전기 부분이 다르다는 것은 전체 설계도가 다르다는 것을 의미하기 때문에 완전히 새로운 설계도 한 장을 통째로 전달해야 했을 것이다. 즉, 레이어 구조는 데이터 전송에 있어서 더 유리한 구조이다. 

이미지의 레이어는 건축도면과 비슷하지만 조금 다른 방식으로 구성된다. 이미지의 레이어는 바로 직전 단계의 레이어에서 변경된 내용들만 저장된다. 서버에 NGINX를 설치하는 상황을 가정해보자. 

이 NGINX를 구성하는 단계는 
1. 먼저 OS를 설치하고
2. NGINX 소프트웨어를 설치한 다음에
3. NGINX 설정 파일을 수정하고
4. 브라우저에 표시되는 index.html 파일을 사용자에게 응답할 내용으로 수정해야 한다.

이제 이 순서대로 이미지의 레이어를 구성한다고 생각해보면 먼저 os를 준비한 다음, 이 os 위에서 NGINX 소프트웨어를 설치한다. 소프트웨어를 설치하면 이 os의 특정 폴더에 nginx 소프트웨어와 관련된 파일들이 추가된다. 그래서 이 nginx를 설치한다는 것은 기존 os 파일 시스템에서 추가가 되는 부분이 있는 것이다. 이렇게 기존 레이어에서 변경되는 것들은 이 기존의 레이어를 수정하는 것이 아니라 기존 레이어 위에 변경된 내용들이 새로운 레이어로 저장된다. 그래서 두 번째 NGINX 설치 레이어에는 이전 레이어인 OS 레이어에서 NGINX 소프트웨어가 추가된 부분만 따로 가지고 있는 것이다. 이전 레이어와 비교해서 추가되거나 변경된 파일들이 다음 레이어로 저장되는 것이다. 이미지에서 한 번 저장된 레이어는 변경할 수 없다. 변경 사항이 있으면 새로운 레이어로 저장해야 한다. 마치 소스코드에서 한 번 푸시한 내용은 되돌릴 수 없는 것과 같다. 

NGINX 설정 파일인 nginx.conf 파일을 작성하거나, index.html 파일의 내용을 수정하느 것도 각각 새로운 레이어로 만들어진다. 이렇게 이미지 A를 완성한 다음에 이미지 B를 새로 만드는데 이미지 B는 이전과 똑같은 순서이지만 마지막 단계에서 index.html 파일의 내용을 다른 내용인 커스텀 인덱스로 작성한다고 가정해보자. 이미지 B를 만들 때 nginx의 소프트 버전과 nginx 설정을 이미지 A와 모두 동일하게 설정하면 세 번째 nginx 설정(상단 nginx 구성 단계 참조)까지는 같은 레이어를 재사용하게 된다. 마지막에 index.html 파일에 수정하느 내용이 다르기 때문에 이 마지막 레이어만 새롭게 추가되어서 이미지 B가 완성되는 것이다. 그래서 이미지 A와 B는 총 3개의 레이어를 공유하고 각각 하나의 레이어를 별도로 사용하는 구조가 된다.

| 레이어 | 이미지 A | 이미지 B | 
|---|---|---| 
| **1. Base OS Layer** | 포함 | 포함 | 
| **2. Install NGINX** | 포함 | 포함 | 
| **3. Configure NGINX** | 포함 | 포함 | 
| **4. index.html** | 사용자 정의 `index.html` | 커스터마이즈된 `index.html for Image B` |

정리하자면 이미지의 레이어는 순차적으로 쌓인다. 그리고 각각의 레이어는 이전 레이어에서 변경된 부분을 저장하고 있다. 그리고 같은 변경이 일어난 레이어는 공유해서 재사용할 수 있다. 

## 이미지 레이어와 컨테이너 레이어
이제 이 이미지로 컨테이너를 실행해보자. `docker run` 명령으로 컨테이너를 실행하면 이미지의 가장 마지막 레이어 위에서 새로운 읽기 쓰기 전용 레이어가 추가된다. 그리고 이 추가된 레이어를 컨테이너 레이어라고 부른다. 애플리케이션에서 로그가 쌓이거나 컨테이너가 실행 중에 생기는 모든 변경 사항들은 이 새로운 레이어에 저장된다. 위에서 이미지의 레이어는 변경 불가능하다고 설명했다. 그래서 이 이미지의 레이어는 수정이 불가능한 읽기 전용 레이어이다. 

이 이미지의 레이어와 컨테이너의 레이어는 역할이 완전히 다르다. 이미지의 레이어는 컨테이너를 실행하기 위한 세이브 포인트 역할을 하고 컨테이너의 레이어는 실제로 이 이미지를 컨테이너로 실행한 다음에 프로세스가 변경하는 내용을 기록하는 레이어이다. 컨테이너 레이어는 쓰기가 가능한 읽기 쓰기 레이엉이기 때문에 컨테이너 레이어 한 장이 읽기 전용 레이어들인 이미지의 상단에 추가돼서 컨테이너 실행 중에 변경되는 내용만 기록하는 것이다. 

그러면 이미지 A로 두 번째 컨테이너인 컨테이너2를 실행하면 컨테이너2에 읽기 쓰기 레이어가 실행된다. 이 두 개의 컨테이너는 이미지가 같기 때문에 동일한 읽기 전용 레이어를 공유하게 된다. 그러면 실제로 컨테이너를 실행할 때 전체 레이어를 복사하는 것이 아니라 읽기 전용 레이어인 이미지위에 새로운 컨테이너 레이어만 하나씩 추가하면 된다. 동일한 이미지로 컨테이너를 아주 많이 만들어도 이 이미지로 실행된 모든 컨테이너가 하나의 이미지를 공유해서 읽어온다. 실제로 큰 부분을 차지하는 이미지를 하나로 유지할 수 있기 때문에 컨테이너를 생성할 때 속도가 빨라진다. 그리고 저장소도 더 효율적으로 사용할 수 있다. 그리고 이미지에 포함되어 있는 index.html 파일의 내용이 동일하기 때문에 컨테이너 1, 2는 웹 브라우저로 접근했을 때 동일한 화면을 보여준다. 

다음으로 이미지 B를 사용해서 새로운 컨테이너를 실행한다고 가정해보자. 이 경우에 3번 컨테이너는 컨테이너 1, 2와 세 번째 레이어인 nginx 설정까지만 공유한다. 그래서 3번 컨테이너로 접근하면 이미지 B의 index.html 파일의 내용이 출력된다. 

정리하자면 모든 컨테이너는 각자 자기만의 읽기 쓰기 레이어 한장을 가진다. 그리고 컨테이너를 만들 때 사용된 이미지에 따라서 이미지의 읽기 전용 레이어 전체를 공유할 수도 있고 일부만 공유할 수도 있다. 이렇게 읽기 전용 레이어를 활용하면 컨테이너를 실행할 때 전체 공간을 복사하지 않아도 되기 때문에 컨테이너를 빠르게 실행할 수 있다. 그리고 컨테이너가 늘어나면서 사용하는 공간을 최대한 작게 관리할 수 있다. 

이미지 레이어와 컨테이너 레이어의 관계는 비유하자면 건축 도면으로 실제 건물을 지은 것과 비슷하다. 건축 도면은 하나만 있어도 여러 개의 건물을 만들 수가 있다. 건축 도면으로 새로운 건물을 하나 지으면 하나의 설계도로 여러 건물을 만들 수 있다. 이 건물들은 컨테이너가 CPU와 메모리를 사용하는 것처럼, 실제로 전기, 땅 같은 자원을 사용한다. 각각의 건물은 다른 이름과 주소로 사용되면서 각각의 흔적이 남게 된다. 하지만 같은 설게도로 만들어졌기 때문에 상가, 집 학교처럼 이 건물이 근본적으로 수행하는 목적은 동일하다. 마찬가지로 하나의 이미지로 컨테이너를 수십 개 실행해도 이 컨테이너가 수행하는 근본적인 기능은 동일하다. 컨테이너가 실행되면서 읽기 쓰기 레이어에 저장되는 값은 각각 고유한 값들이 쌓이게 될 것이다.