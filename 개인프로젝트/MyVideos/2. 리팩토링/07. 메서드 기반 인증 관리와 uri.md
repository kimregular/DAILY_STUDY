기존에는 /v1/{domain}/{action} 형식의 uri를 사용했다. api 서버를 제작 중이므로 메서드 기반으로 인증을 하기로 결정했다. api를 만들 때마다 securityConfig 에서 해당 api 를 public 으로 열어두는 과정이 귀찮았기 때문이다. 여튼 도입을 했지만 이만저만 불편한 부분이 있었다. 바로 어떤 api가 인증이 필요없는 api 인지 확인하기가 어려웠다. 그래서 리팩토링을 진행했다.

# SecurityConfig
## 개선 전
/v1/{domain}/{actoin}

기존에는 유저 도메인에서 사용할 수 있는 api들이 모두 이런식으로 정의되어 있었다. SecurityConfig의 SecurityFilterChain 설정이 쉽지 않았다. 어떤 api를 permit 설정해야하는지 매번 확인해야만 했다.

```java
http.authorizeHttpRequests(auth ->  
        auth  
                .requestMatchers(  
                        new AntPathRequestMatcher("/favicon.ico"),  
                        new AntPathRequestMatcher("/error"),  
                        new AntPathRequestMatcher("/h2-console/**"),  
                        new AntPathRequestMatcher("/docs/**"),  
                        new AntPathRequestMatcher("/app/uploads/**"),  
                        new AntPathRequestMatcher("/images/**")  
                ).permitAll()  
                .requestMatchers(  
                        new AntPathRequestMatcher("/v1/users/**"),  
                        new AntPathRequestMatcher("/v1/videos/**")  
                ).permitAll()  
                .requestMatchers(HttpMethod.GET, "/v1/comments/**").permitAll()  
                .requestMatchers("/v1/comments/**").authenticated()  
                .anyRequest().authenticated()  
);
```

게다가 comment 도메인의 api는 GET 요청 전체는 permit 이면서 다른 요청은 인증을 받아야한다는 설정이 되어있다.

통일성 없는 모습이 보기 싫어 개선하기로 했다.

## 개선 후
/v1/{domain}/{permitted?}/{action}

```java
http.authorizeHttpRequests(auth ->  
        auth  
                .requestMatchers(  
                        new AntPathRequestMatcher("/favicon.ico"),  
                        new AntPathRequestMatcher("/error"),  
                        new AntPathRequestMatcher("/h2-console/**"),  
                        new AntPathRequestMatcher("/docs/**"),  
                        new AntPathRequestMatcher("/app/uploads/**"),  
                        new AntPathRequestMatcher("/images/**")  
                ).permitAll()  
                .requestMatchers(  
                        new AntPathRequestMatcher("/v1/*/public/**")  
                ).permitAll()  
                .anyRequest().authenticated()  
);
```


# VideoController
## 개선 전

```java
  
@RestController  
@RequiredArgsConstructor  
@RequestMapping("/v1/videos")  
public class VideoController {  
  
    private final VideoService videoService;  
  
    @GetMapping  
    public ResponseEntity<List<VideoResponse>> getHomeVideos() {  
       return ResponseEntity.ok(videoService.getHomeVideos());  
    }  
  
    @GetMapping("/{videoId}/info")  
    public ResponseEntity<VideoResponse> getVideo(@PathVariable Long videoId,  
                                       @AuthenticationPrincipal UserDetails userDetails) {  
       return ResponseEntity.ok(videoService.getVideo(videoId, userDetails));  
    }  
  
    @User  
    @PostMapping(value = "/upload", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)  
    public ResponseEntity<VideoResponse> uploadVideo(@ModelAttribute @Valid VideoUploadRequest videoUploadRequest,  
                                                     @AuthenticationPrincipal UserDetails userDetails) {  
       return ResponseEntity.status(HttpStatus.CREATED).body(videoService.uploadVideo(videoUploadRequest, userDetails));  
    }  
  
    @GetMapping(value = "/{videoId}/stream")  
    public ResponseEntity<StreamingResponseBody> getVideoStream(@PathVariable Long videoId,  
                                                                HttpServletRequest request) {  
       VideoStreamingResponse videoStreamingResponse = videoService.stream(videoId, request);  
       return ResponseEntity.status(videoStreamingResponse.getStatus()).headers(videoStreamingResponse.getHeaders()).body(videoStreamingResponse.getStreamingResponseBody());  
    }  
  
    @User  
    @PatchMapping("/{videoId}/info")  
    public ResponseEntity<VideoResponse> updateVideo(@PathVariable Long videoId,  
                                                     @Valid @RequestBody VideoUpdateRequest videoUpdateRequestDto,  
                                                     @AuthenticationPrincipal UserDetails userDetails) {  
       return ResponseEntity.ok(videoService.updateVideoInfo(videoId, videoUpdateRequestDto, userDetails));  
    }  
  
    @User  
    @PatchMapping("/{videoId}/status")  
    public ResponseEntity<VideoResponse> changeVideoStatus(@PathVariable Long videoId,  
                                                           @Valid @RequestBody VideoStatusChangeRequest videoStatusChangeRequest,  
                                                           @AuthenticationPrincipal UserDetails userDetails) {  
       return ResponseEntity.ok(videoService.changeVideoStatus(videoId, videoStatusChangeRequest, userDetails));  
    }  
  
    @User  
    @PatchMapping("/status")  
    public ResponseEntity<Void> changeVideosStatus(@RequestBody VideosStatusChangeRequest videosStatusChangeRequest,  
                                                   @AuthenticationPrincipal UserDetails userDetails) {  
       videoService.changeVideosStatus(videosStatusChangeRequest, userDetails);  
       return ResponseEntity.ok().build();  
    }  
  
    @GetMapping("/{username}")  
    public ResponseEntity<List<VideoResponse>> getVideosOf(@PathVariable String username) {  
       return ResponseEntity.ok(videoService.getVideosOf(username));  
    }  
}
```

## 개선 후
### 인증 필요한 api 컨트롤러
```java
@User  
@RestController  
@RequiredArgsConstructor  
@RequestMapping("/v1/videos")  
public class VideoPermittedController {  
  
    private final VideoService videoService;  
  
    @PostMapping(value = "/upload", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)  
    public ResponseEntity<VideoResponse> uploadVideo(@ModelAttribute @Valid VideoUploadRequest videoUploadRequest,  
                                                     @AuthenticationPrincipal UserDetails userDetails) {  
       return ResponseEntity.status(HttpStatus.CREATED).body(videoService.uploadVideo(videoUploadRequest, userDetails));  
    }  
  
    @PatchMapping("/{videoId}/info")  
    public ResponseEntity<VideoResponse> updateVideo(@PathVariable Long videoId,  
                                                     @Valid @RequestBody VideoUpdateRequest videoUpdateRequestDto,  
                                                     @AuthenticationPrincipal UserDetails userDetails) {  
       return ResponseEntity.ok(videoService.updateVideoInfo(videoId, videoUpdateRequestDto, userDetails));  
    }  
  
    @PatchMapping("/{videoId}/status")  
    public ResponseEntity<VideoResponse> changeVideoStatus(@PathVariable Long videoId,  
                                                           @Valid @RequestBody VideoStatusChangeRequest videoStatusChangeRequest,  
                                                           @AuthenticationPrincipal UserDetails userDetails) {  
       return ResponseEntity.ok(videoService.changeVideoStatus(videoId, videoStatusChangeRequest, userDetails));  
    }  
  
    @PatchMapping("/status")  
    public ResponseEntity<Void> changeVideosStatus(@RequestBody VideosStatusChangeRequest videosStatusChangeRequest,  
                                                   @AuthenticationPrincipal UserDetails userDetails) {  
       videoService.changeVideosStatus(videosStatusChangeRequest, userDetails);  
       return ResponseEntity.ok().build();  
    }  
}
```

### 인증 불필요한 api 컨트롤러
```java
@RestController  
@RequiredArgsConstructor  
@RequestMapping("/v1/videos/public")  
public class VideoPublicController {  
  
    private final VideoService videoService;  
  
    @GetMapping  
    public ResponseEntity<List<VideoResponse>> getHomeVideos() {  
        return ResponseEntity.ok(videoService.getHomeVideos());  
    }  
  
    @GetMapping("/{videoId}/info")  
    public ResponseEntity<VideoResponse> getVideo(@PathVariable Long videoId,  
                                                  @AuthenticationPrincipal UserDetails userDetails) {  
        return ResponseEntity.ok(videoService.getVideo(videoId, userDetails));  
    }  
  
    @GetMapping(value = "/{videoId}/stream")  
    public ResponseEntity<StreamingResponseBody> getVideoStream(@PathVariable Long videoId,  
                                                                HttpServletRequest request) {  
        VideoStreamingResponse videoStreamingResponse = videoService.stream(videoId, request);  
        return ResponseEntity.status(videoStreamingResponse.getStatus()).headers(videoStreamingResponse.getHeaders()).body(videoStreamingResponse.getStreamingResponseBody());  
    }  
  
    @GetMapping("/{username}")  
    public ResponseEntity<List<VideoResponse>> getVideosOf(@PathVariable String username) {  
        return ResponseEntity.ok(videoService.getVideosOf(username));  
    }  
}
```