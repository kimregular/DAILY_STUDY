# 동시 쓰기 요청 처리 방법

1. 비관적 락
2. 낙관적 락
3. 비동기 순차 처리

## 비관적 락 기반 처리
데이터 접근 시에 항상 충돌이 발생할 가능성이 있다고 가정
- 비관적 관점

데이터를 보호하기 위해 항상 락을 걸어 다른 트랜잭션 접근을 방지
- 다른 트랜잭션은 락이 해제되기까지 대기
- 락을 오래 점유하고 있으면, 성능 저하 또는 deadlock 등으로 인한 장애 발생

### 방법 1
1. transactional start;
2. insert into my_table values (id, v1, v2, v3);
	- 데이터 삽입
3. update my_table_count set my_count = my_count + 1 where id = id;
	- 데이터 수 갱신
	- 비관락 점유
4. commit;

### 방법 2
1. transactinal start;
2. insert into my_table values (id, v1, v2, v3);
3. select \* from my_table_count where id = id for update;
	- for update 구문으로 데이터 조회
	- 조회된 데이터에 대해서 비관락 점유
	- 애플리케이션에서 jpa 를 사용하는 경우,  객체로 조회 가능
4. update my_table_count set my_count = update_my_count where id = id;
	- 데이터 갱신
	- 조회된 데이터를 기반으로 새로운 수를 만들어 준다.
	- 애플리케이션에서 jpa를 사용하는 경우, 엔티티로 위 과정을 수행할 수 있다.
5. commit;

### 비교
락 점유
- 방법 1 : update 문 수행하는 시점에 락을 점유 -> 점유 시간 짧음
- 방법 2 : 데이터 조회 시점부터 락 점유 -> 점유 시간 김
애플리케이션
- 방법 1 : 데이터베이스의 현재 저장된 데이터 기준으로 증감 처리하기 때문에 sql 문을 직접 전송한다.
- 방법 2 : JPA를 사용하는 경우, 엔티티를 이용하여 좀 더 객체지향스럽게 개발 가능하다.

## 낙관적 락 기반 처리
데이터 접근 시에 항상 충돌이 발생할 가능성이 없다고 가정
- 낙관적 관점

데이터의 변경 여부를 확인하여 충돌을 처리
- 데이터가 다른 트랜잭션에 의해 수정되었는지 확인
- 수정된 내역이 있으면 후처리

변경 여부를 어떻게 확인함?
- 각 테이블은 version 컬럼으로 데이터의 변경 여부를 추적

충돌은 어떻게 확인함?
1. 각 트랜잭션에서 version을 함께 조회
2. 레코드 업데이트
	- 이 때, where 조건에 조회된 version을 넣고, version은 증가시킨다.
3. 충돌 확인
	- 데이터 변경이 성공 했다면, 충돌이 없었음
	- 데이터 변경이 실패 했다면, 충돌이 있었음
		- 다른 트랜잭션에서 version을 이미 증가 시켰음을 의미하므로 충돌이 생긴것!

충돌을 감지학고 후처리를 위한 추가 작업이 필요하다.
- 충돌 발생 시에 commit 또는 rollback 또는 재시도
- 이러한 과정을 데이터베이스에서 처리해주진 않는다, 즉 애플리케이션에서 해야한다.

## 비동기 순차 처리
모든 상황을 실시간으로 처리하고 즉시 응답해줄 필요는 없다는 관점
- 요청을 대기열에 저장해두고, 이후에 비동기로 순차적으로 처리할 수 있다.
- 게시글마다 1개의 스레드에서 순차적으로 처리하면, 동시성 문제도 사라진다.
- 락으로 인한 지연이나 실패 케이스가 최소화된다.
- 즉시 처리되지 않기 때문에 사용자 입장에서는 지연 될 수 있다.

큰 비용 소모
- 비동기 처리를 위한 시스템 구축 비용
- 실시간으로 결과 응답이 안되기 때문에 클라이언트 측 추가 처리 필요
- 데이터 일관성 관리를 위한 비용
	- 대기열에서 중복, 누락 없이 반드시 1회 실행 보장되기 위한 시스템 구축 필요