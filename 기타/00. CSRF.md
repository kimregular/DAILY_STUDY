Cross-Site Request Forgery
사이트 간 요청 위조의 줄임말

사용자가 자신의 의지와 무관하게 공격자가 의동한 행동을 해서 특정 웹 페이지를 보안에 취약하게 한다거나 수정, 삭제 등의 작업을 하게 만드는 공격 방법

- 피해자는 웹사이트에 로그인된 상태
- 공격자는 피해자의 브라우저를 통해 요청
- 요청은 정상적인 사용자 요청처럼 보이기 때문에 서버는 이를 신뢰하고 처리

## 예상 시나리오
1. 사용자가 은행 사이트에 로그인한 상태
2. 공격자가 조작된 HTML 또는 스크립트를 포함한 페이지를 사용자가 방문하도록 함
3. 이 페이지에서 공격자가 작성한 해킹 스크립트를 자동으로 요청함
4. 사용자의 세션 쿠키가 자동으로 전송되며, 서버는 정상 사용자의 요청으로 인식하고 처리

## 대응 방법
- CSRF 토큰 사용 (요청마다 고유 토큰을 포함시켜 검증)
- SameSite 쿠키 속성 설정
- Referer 또는 Origin 헤더 검사
- 로그아웃 후 민감 작업 재인증 요구

## JSP에서 대응하기

- 요청 할 때마다 토큰을 생성해서 세션에 저장
- 폼에 hidden 필드로 해당 토큰 삽입
- 서버 수신 시 세션과 요청 값을 비교하여 검증

1. CSRF 토큰 생성
```java
String csrfToken = UUID.randomUUID().toString();
request.getSession().setAttribute("csrfToken", csrfToken);
```

2. 폼에서 토큰 포함
```jsp
<form action="process.jsp" method="post">
    <input type="hidden" name="csrfToken" value="${sessionScope.csrfToken}">
    <input type="text" name="amount">
    <input type="submit" value="Submit">
</form>
```

3. 처리 페이지에서 토큰 검증
```jsp
<%
    String sessionToken = (String) session.getAttribute("csrfToken");
    String requestToken = request.getParameter("csrfToken");

    if (sessionToken == null || !sessionToken.equals(requestToken)) {
        out.println("CSRF 공격 의심됨. 요청 거부.");
        return;
    }

    // 정상 처리 로직
    String amount = request.getParameter("amount");
    out.println("입력된 금액: " + amount);
%>

```