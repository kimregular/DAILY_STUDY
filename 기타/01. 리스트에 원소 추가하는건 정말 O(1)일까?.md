```cpp
std::vector<int> arr;  
arr.push_back(10);
```

```java
List<Integer> arr = new ArrayList<>();
arr.add(1);
```

```python
arr = []
arr.append(1)
```
  

위 코드에서 원소를 더하는 연산은 정말 상수시간일까? 결론부터 말하자면 아니다. 

> 원소 추가 연산의 정확한 시간 복잡도는 amortized O(N) 이다.

설명을 위해 멀리 멀리 돌아가서 시작해보겠다. 프로세스가 사용하는 메모리를 살펴보자. 

코드에서 배열을 선언한다면 메모리에는 위 그림과 같이 배열이 저장된다. 

arr은 힙 영역에 저장된 배열의 시작 주소를 가지고 있다. 배열의 길이가 10이라면 10칸을 메모리에 할당하여 저장한다. 

배열에 1 ~ 10 까지 저장했고 이후 11을 넣고 싶다면? 여기서 두 가지 아이디어가 나온다.

1. 굳이 메모리상에 연속되게 저장해야하나? -> Linked List
2. 길이를 늘린다음 메모리에 새로 할당하지뭐 -> List

우리는 2번 아이디어를 따라 진행한다. 즉, 배열을 다시 메모리에 할당해야한다. 이번에는 11칸 배열을 선언하고 기존 값을 복사, 이후 11을 마지막에 저장한다. 만약 12를 넣고 싶다면? 12칸 배열을 선언하고 기존 값을 복사, 이후 12를 마지막에 저장한다. 10까지는 1번의 연산이었지만 11부터는 n + 1의 연산을 해야한다. 그러면 자연스럽게 다음과 같은 아이디어가 떠오른다.

> 배열 길이를 1만 늘리지 말고 한번에 왕창 늘려놓자!

위 아이디어대로 배열 길이를 하나만 늘리지 말고 편의상 2배씩 늘려보자. 즉 초기값이 10인 배열이라면 배열이 꽉 찼을 때 20의 길이를 가지는 배열로

1 ~ 10 :  원소 추가 연산

11 : 배열 선언 연산 + 복사 연산 + 11 추가 연산

12 ~ 20 : 원소 추가 연산

21 : 배열 선언 연산 + 복사 연산 + 21 추가 연산

22 ~ 40 : 원소 추가 연산

41 : 배열 선언 연산 + 복사 연산 + 41 추가 연산

42 ~ 80 : 원소 추가 연산

81 : 배열 선언 연산 + 복사 연산 + 81 추가 연산

  

규칙이 보이는가? 모든 경우에 일단 추가 연산이 진행된다. 배열이 꽉 차고 이후 배열을 2배 길이로 늘린 다음 선언, 복사하는 연산은 가끔 진행된다.

  

1 ~ 81 : 원소 추가 연산 -> O(1)

11, 21, 41, 81 : 배열 선언 연산, 복사 연산 -> O(N)

  

대충 결론이 보이기 시작한다. 

  

정리하자면 대부분의 경우 상수 시간이 걸린다. 그런데 재수없으면 n의 시간이 걸린다. 그러니까 대충 상수시간이라고 하자! 라고 결론을 낼 수 있겠다. 그런데 정말 대충 결론을 내고나서 만족할 수 있는가? 디테일에 목숨을 거는 타입이라면 여기서 거품을 물고 따지기 시작할 것이다.

  

추가 연산의 평균적인 시간 복잡도를 보다 명확하게 이해하기 위해, 다시 한번 정리해보자.

  

1 ~ 81 : 원소 추가 연산 -> O(1)

11, 21, 41, 81 : 배열 선언 연산, 복사 연산 -> O(N)

  

너무 당연한 원소 추가 연산은 제외하고 배열 길이를 늘리는 케이스를 살펴보자. 11, 21, 41, 81 원소를 추가할 때 연산의 길이는 절대 N을 넘지 않는다. 각 확장 과정에서 배열의 크기는 기존의 2배가 되므로, 총 복사되는 원소 수는 대략 O(N)이다. 하지만 전체 연산을 여러 번 반복하면, 평균적으로 원소당 O(1)의 시간 복잡도를 가지게 된다.

## 자바에서는 1.5배로 리스트를 키운다.
아래 코드는 ArrayList에서 길이를 늘리는 부분이다.
```java
private Object[] grow(int minCapacity) {  
    int oldCapacity = elementData.length;  
    if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {  
        int newCapacity = ArraysSupport.newLength(oldCapacity,  
                minCapacity - oldCapacity, /* minimum growth */  
                oldCapacity >> 1           /* preferred growth */);  
        return elementData = Arrays.copyOf(elementData, newCapacity);  
    } else {  
        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];  
    }  
}
```

`ArraysSupport.newLength()` 메서드에서 리스트 길이를 새로 만든다.

```java
public static int newLength(int oldLength, int minGrowth, int prefGrowth) {  
    // preconditions not checked because of inlining  
    // assert oldLength >= 0  
    // assert minGrowth > 0  
  
    int prefLength = oldLength + Math.max(minGrowth, prefGrowth); // might overflow  
    if (0 < prefLength && prefLength <= SOFT_MAX_ARRAY_LENGTH) {  
        return prefLength;  
    } else {  
        // put code cold in a separate method  
        return hugeLength(oldLength, minGrowth);  
    }  
}
```

prefGrowth 값은 `oldCapacity >> 1` 비트연산을 한 값이다. 그리고 최종으로 `int prefLength = oldLength + Math.max(minGrowth, prefGrowth); ` 여기서 길이가 정해진다. 기존값 + (기존값/2), 즉 1.5배로 길이가 늘어난다.