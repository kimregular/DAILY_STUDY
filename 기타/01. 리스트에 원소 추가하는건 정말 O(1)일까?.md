
```java
List<Integer> arr = new ArrayList<>();

arr.add(10);
```

```python
arr = []

arr.append(1)
```
  

위 코드에서 원소를 더하는 연산은 정말 상수시간일까? 

  

결론부터 말하자면 아니다.

  

설명을 위해 멀리 멀리 돌아가서 시작해보겠다. 프로세스가 사용하는 메모리를 살펴보자. 

  

코드에서 배열을 선언한다면 메모리에는 위 그림과 같이 배열이 저장된다. 

  

arr은 힙 영역에 저장된 배열의 시작 주소를 가지고 있다. 배열의 길이가 10이라면 10칸을 메모리에 할당하여 저장한다. 

  

배열에 1 ~ 10 까지 저장했고 이후 11을 넣고 싶다면? 배열을 다시 메모리에 할당해야한다. 이번에는 11칸 배열을 선언하고 기존 값을 복사, 이후 11을 마지막에 저장한다. 10까지는 1번의 연산이었지만 11부터는 n + 1의 연산을 해야한다.

  

배열 길이를 1만 늘리지 말고 한번에 왕창 늘려놓자!

  

위 아이디어대로 배열 길이를 하나만 늘리지 말고 편의상 2배씩 늘려보자.

  

1 ~ 10 :  원소 추가 연산

11 : 배열 선언 연산 + 복사 연산 + 11 추가 연산

12 ~ 20 : 원소 추가 연산

21 : 배열 선언 연산 + 복사 연산 + 21 추가 연산

22 ~ 40 : 원소 추가 연산

41 : 배열 선언 연산 + 복사 연산 + 41 추가 연산

42 ~ 80 : 원소 추가 연산

81 : 배열 선언 연산 + 복사 연산 + 81 추가 연산

  

규칙이 보이는가? 모든 경우에 일단 추가 연산이 진행된다. 배열이 꽉 차고 이후 배열을 2배 길이로 늘린 다음 선언, 복사하는 연산은 가끔 진행된다.

  

1 ~ 81 : 원소 추가 연산 -> O(1)

11, 21, 41, 81 : 배열 선언 연산, 복사 연산 -> O(N)

  

대충 결론이 보이기 시작한다. 

  

정리하자면 대부분의 경우 상수 시간이 걸린다. 그런데 재수없으면 n의 시간이 걸린다. 그러니까 대충 상수시간이라고 하자! 라고 결론을 낼 수 있겠다. 그런데 정말 대충 결론을 내고나서 만족할 수 있는가? 디테일에 목숨을 거는 타입이라면 여기서 거품을 물고 따지기 시작할 것이다.

  

그래서 위 연산을 다시 정리해서 살펴보자!

  

1 ~ 81 : 원소 추가 연산 -> O(1)

11, 21, 41, 81 : 배열 선언 연산, 복사 연산 -> O(N)

  

너무 당연한 원소 추가 연산은 제외하고 배열 길이를 늘리는 케이스를 살펴보자. 11, 21, 41, 81 원소를 추가할 때 연산의 길이는 절대 N을 넘지 않는다.

## 자바에서는 1.5배로 리스트를 키운다.
아래 코드는 ArrayList에서 길이를 늘리는 부분이다.
```java
private Object[] grow(int minCapacity) {  
    int oldCapacity = elementData.length;  
    if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {  
        int newCapacity = ArraysSupport.newLength(oldCapacity,  
                minCapacity - oldCapacity, /* minimum growth */  
                oldCapacity >> 1           /* preferred growth */);  
        return elementData = Arrays.copyOf(elementData, newCapacity);  
    } else {  
        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];  
    }  
}
```

`ArraysSupport.newLength()` 메서드에서 리스트 길이를 새로 만든다.