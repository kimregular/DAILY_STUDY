# 현대파일시스템

## 간략한 발전도 

```arduino
📂 초기 파일 시스템
│── 📂 FAT 계열 (1980년대~)
│   ├── FAT12 (플로피디스크)
│   ├── FAT16 (DOS, Windows 95)
│   ├── FAT32 (Windows 98~)
│   ├── exFAT (대용량 지원, 플래시 메모리 최적화)
│
│── 📂 유닉스 계열
│   ├── 📂 BSD 계열
│   │   ├── UFS (Unix File System)
│   │   ├── FFS (Fast File System)
│   │   ├── ZFS (Sun Microsystems, 2000년대)
│   │
│   ├── 📂 리눅스 계열
│   │   ├── ext (Extended File System)
│   │   ├── ext2 (로그 없음)
│   │   ├── ext3 (저널링 추가)
│   │   ├── ext4 (성능 최적화)
│   │   ├── XFS (SGI, 대용량 파일 최적화)
│   │   ├── Btrfs (차세대, 스냅샷 및 중복 제거)
│
│── 📂 Windows 계열
│   ├── NTFS (Windows NT, 보안 및 저널링 지원)
│
│── 📂 Apple 계열
│   ├── HFS (초기 Mac OS)
│   ├── HFS+ (Mac OS X)
│   ├── APFS (SSD 최적화, macOS, iOS)
│
│── 📂 네트워크 및 분산 파일 시스템
│   ├── NFS (유닉스 네트워크 파일 시스템)
│   ├── SMB / CIFS (Windows 네트워크 파일 시스템)
│   ├── CephFS (클러스터 기반 분산 파일 시스템)
│   ├── HDFS (Hadoop 기반 대용량 데이터 처리)
│
│── 📂 특수 목적 파일 시스템
│   ├── tmpfs (메모리 기반 파일 시스템)
│   ├── procfs (/proc, 프로세스 정보 제공)
│   ├── sysfs (/sys, 시스템 정보 제공)

```

## 현대 파일시스템의 기능

1. 저널링
2. 암호화
3. 스냅샷
4. 가상파일시스템

## 저널링
작업 로그를 통해 시스템 클래시가 발생했을 때 빠르게 복구하기 위한 방법

3단계로 나누어 진행된다.

1. journal write\
		작업 직전 파티션의 로그 영역에 수행하는 작업에 대한 로그를 남긴다.
2. journal commit\
		로그를 남긴 후 작업을 수행한다.
3. checkpoint\
		작업이 끝났다면 로그를 삭제한다.


컴퓨터가 작업을 진행하던 중에 크래시가 발생하여 다시 부팅을 하게 된다면 파일 시스템 전체를 검사할 필요 없이 로그 영역에 남긴 로그만 검사한다. 저널링 파일 시스템은 시스템 크래시가 발생한 직후에 로그 영역을 읽어 크래시가 발생한 당시 어떤 작업을 실행 중이었는지 알아낸 다음 해당 작업을 완료한다.

## 암호화
암호화 기능을 사용하지 않는다면 공격자의 접근을 보호할 수 없다. 예를 들어 디스크를 빼내어 다른 컴퓨터에 삽입후 해당 데이터에 접근할 수 있다. 이런 상황을 방지하기 위해 암호화된 저장장치를 사용하는 방식을 사용한다.

파일 시스템 암호화는 크게 2가지 방식이 있다.

1. 디스크 암호화
	1. BitLocker
	2. FileVault
2. 파일 레벨 암호화
	1. EFS
	2. fscrypt

### 디스크 암호화

디스크 볼륨에 저장되는 모든 데이터를 암호화한다. 파일 시스템 자체가 암호화되므로 파일 구조가 보호된다. 즉 공격자가 디스크를 물리적으로 분리하여 다른 컴퓨터에 삽입해도 데이터에 접근할 수 없다.

#### 투명한 암호화

데이터가 로드되거나 저장될 때 자동으로 암호화되거나 복호화되는 기능이다. 사용자는 데이터 읽기 쓰기를 평소대로 사용할 수 있다. 암호화, 복호화는 백그라운드에서 자동으로 진행된다. 백그라운드에서 계속 연산이 이뤄지기 때문에 성능을 손해보는 경우도 있다. 

MacOS의 경우 APFS를 사용하면서 해당 성능이 향상되었고, T2칩을 탑재하면서 백그라운드 연산을 전담, 성능하락이 사라졌다. 

### 파일 레벨 암호화
파일 단위로 암호화하는 기술이다. 파일 레벨 암호화를 사용하면, 개별 파일 및 폴더를 전체 스토리지 자체를 암호화하지 않고도 암호화할 수 있다. 

파일마다 암호화가 이루어지므로 각 파일마다 고유한 암호키를 가질 수 있다. 디스크 암호화에서는 전송하는 데이터 보호는 지원하지 않는다. 하지만 파일 레벨 암호화에서는 전송하는 데이터의 정보도 암호화 상태를 유지할 수 있다.

## 스냅샷
특정 시점의 파일 시스템 상태를 캡처하여 별도의 이미지로 저장하는 기술. 여기서 말하는 캡쳐란 데이터 전체의 보관을 의미하지 않는다. 데이터의 변경 사항만 로그같은 형식으로 기록하는 등으로 저장된다. 즉, 원본 데이터의 참조만 가지며, 공간이 절약된다.

일반적으로 2가지 방식이 있다.

1. COW(Copy on Write)\
		새로운 데이터를 쓰기 전에 원래 데이터를 다른 위치에 복사하여 보존한다.
2. ROW(Redirect on Write)\
		변경된 데이터를 새로운 위치에 저장하고, 기존 데이터는 참조만 유지한다.

### 백업과의 차이점

백업 : 전체 데이터를 복사하여 별도 저장
스냅샷 : 변경된 데이터만 저장

## 가상파일(Virtual File System)
애플리케이션과 파일시스템 사이의 가상적인 층으로 애플리케이션이 다양한 파일시스템에 일관된 방식으로 접근할 수 있도록 한다.

만약 VFS가 없는 경우를 살펴보자. 하드디스크를 3개의 파티션으로 나누고 각각에 다른 파일 시스템을 설치했다고도 가정하자. 이때 사용자는 파티션에 접근할때마다 각각 맞는 고유의 함수를 호출해야한다. 이처럼 VFS가 없으면 사용자가 직접 파일시스템의 종류를 파악하고 그에 해당하는 함수를 호출해야 하는 문제점이 발생한다.

이제 VFS가 있다면 사용자는 어디서 어떤 파일시스템을 사용하던 추상화된 공통 함수만으로도 어디든 접근할 수 있다. VFS는 파일을 확인하여 해당 파일을 관리하는 파일 시스템이 무엇인지를 판단한다. 그리고 사용자가 호출한 일관된 함수에 맞는 파일 시스템 고유의 함수를 호출한다. 또한 파일 시스템의 함수가 리턴한 결과를 애플리케이션에 전달한다. 