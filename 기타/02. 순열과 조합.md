# 순열과 조합
## 순열  
  
> 어떤 집합의 원소들을 특정한 순서대로 배열하는 것  
  
순서가 중요하므로 (1, 2) != (2, 1)  
  
> $$_nP_r = \frac{n!}{(n-r)!}$$  
  
> $$_nP_r = n \times _{n-1}P_{r-1}$$  
  
```java  
class Solution {

    private int field;
    private int select;
    private boolean[] used;
    private int[] permutated;
    private StringBuilder answer;

    public String solution(int[] input) {
        init(input);
        getPermutations(0);
        return answer.toString();
    }

    public void getPermutations(int cnt) {
        if (cnt == select) {
            answer.append(savePermutated()).append("\n");
            return;
        }

        for (int i = 1; i <= field; i++) {
            if (used[i]) continue;

            used[i] = true;
            permutated[cnt] = i;
            getPermutations(cnt + 1);
            used[i] = false;
        }
    }

    private void init(int[] input) {
        this.field = input[0];
        this.select = input[1];
        this.used = new boolean[field + 1];
        this.permutated = new int[select];
        this.answer = new StringBuilder();
    }

    private String savePermutated() {
        StringBuilder result = new StringBuilder();
        for (int i : permutated) {
            result.append(i).append(" ");
        }
        return result.toString();
    }
}

```  
  
## [다음 순열](https://www.acmicpc.net/problem/10972)
  
> 지금 순열에서 사전 순으로 다음 순열을 생성한다.  

`ex) [1, 2, 3] -> [1, 3, 2]`

1. 순열의 뒤에서부터 앞으로 가면서 처음으로 내림차순이 되는 지점(`i`)을 찾는다.
	- `ex) [5, 1, 2, 4, 3] 의 경우 i = 2, arr[i] = 2`
2. 만약 그런 `i`가 없다면(뒤에서부터 완전히 오름차순으로 정렬되어 있다면), 이미 마지막 순열이므로 `-1` 출력
3. 만약 그런 `i`가 있다면 다시 뒤에서부터 `arr[i]` 보다 큰 수 `j` 를 찾아 스왑한다.
	- `ex) [5, 1, 2, 4, 3] 의 경우 j = 4, arr[j] = 3`
	- `스왑 후 -> [5, 1, 3, 4, 2]`
4. `i` 부터 끝까지의 구간을 오름차순으로 정렬한다.
	- `ex) [5, 1, 3, 2, 4]`

```java  
class Solution {

	private int[] field;

	public String solution(int[] field) {
		init(field);
		return nextPermutate() ? getResult() : "-1";
	}

	private void init(int[] field) {
		this.field = field;
	}

	private boolean nextPermutate() {
		int i = field.length - 1;

		while(i > 0 && field[i - 1] >= field[i]) --i;

		if(i == 0) return false;

		int j = field.length - 1;
		while(field[i - 1] >= field[j]) --j;

		swap(i - 1, j);

		int k = field.length - 1;
		while(i < k) swap(i++, k--);

		return true;
	}

	private void swap(int i, int j) {
		int temp = field[i];
		field[i] = field[j];
		field[j] = temp;
	}

	private String getResult() {
		StringBuilder result = new StringBuilder();
		for (int i : field) {
			result.append(i).append(" ");
		}
		return result.toString().trim();
	}
}
```

## [이전 순열](https://www.acmicpc.net/problem/10973)
  
> 지금 순열에서 사전 순으로 이전 순열을 생성한다.  

`ex) [1, 3, 2] -> [1, 2, 3]`

1. 순열의 뒤에서부터 앞으로 가면서 처음으로 오름차순이 되는 지점(`i`)을 찾는다.
	- `ex) [5, 1, 2, 4, 3] 의 경우 i = 3, arr[i] = 4`
2. 만약 그런 `i`가 없다면(뒤에서부터 완전히 내림차순 정렬되어 있다면), 이미처음 순열이므로 `-1` 출력
3. 만약 그런 `i`가 있다면 다시 뒤에서부터 `arr[i]` 보다 작은 수 `j` 를 찾아 스왑한다.
	- `ex) [5, 1, 2, 4, 3] 의 경우 j = 3, arr[j] = 4`
	- `스왑 후 -> [5, 1, 2, 3, 4]`
4. `i` 부터 끝까지의 구간을 오름차순으로 정렬한다.
	- `ex) [5, 1, 2, 3, 4]`

```java  
class Solution {

	private int[] field;
	
	public String solution(int[] field) {
		init(field);
		return prevPermutation() ? getPermutated() : "-1";
	}
	
	private void init(int[] field) {
		this.field = field;
	}
	
	private boolean prevPermutation() {
		int i = field.length - 1;
		while(i > 0 && field[i - 1] <= field[i]) i--;
		if(i == 0) return false;
		int j = field.length - 1;
		while(field[i - 1] <= field[j]) j--;
		swap(i - 1, j);
		int k = field.length - 1;
		while(i < k) swap(i++, k--);
		return true;
	}

	private void swap(int i, int j) {	
		int temp = field[i];
		field[i] = field[j];
		field[j] = temp;
	}

	private String getPermutated() {
		StringBuilder result = new StringBuilder();
		for(int f : field) result.append(f).append(" ");
		return result.toString();
	}
}
```

## [n번째 수열 구하기](https://www.acmicpc.net/problem/9742)

시간 복잡도 : $O(N^2)$

> 1부터 N까지 숫자로 만들 수 있는 모든 순열을 사전 순으로 정렬했을 때, K 번째에 해당하는 순열을 구하는 방법

사전 순 순열은 팩토리얼을 이용한 자리수 계산으로 직접 구할 수 있다.

N = 4, K = 9 라고 한다면
- 전체 수열 수 : $4!$ = 24
- 첫 자리에 올 수 있는 숫자 : [1, 2, 3, 4]
- 각 숫자가 첫 자리에 올 때마다 남는 경우의 수 : $3!$ = 6
- K = 9는 두 번째 그룹에 해당 (첫 자리는 2)

```java
class Solution {  
  
    public String solution(List<String> testCases) {  
       StringBuilder result = new StringBuilder();  
       for (String testCase : testCases) {  
          result.append(testCase).append(" = ").append(calc(testCase)).append("\n");  
       }  
       return result.toString();  
    }  
  
    private String calc(String testCase) {  
       String[] input = testCase.split(" ");  
       char[] field = input[0].toCharArray();  
       int n = Integer.parseInt(input[1]);  
       String permutation = getPermutationOf(field, n);  
       return permutation != null ? permutation : "No permutation";  
    }  
  
    private String getPermutationOf(char[] field, int n) {  
       List<Character> chars = new ArrayList<>();  
       for(char c : field) chars.add(c);  
  
       int total = factorial(chars.size());  
       if(n > total) return null;  
  
       n--;  
  
       StringBuilder result = new StringBuilder();  
  
       while (!chars.isEmpty()) {  
          int size = chars.size();  
          int f = factorial(size - 1);  
          int index = n / f;  
  
          result.append(chars.get(index));  
          chars.remove(index);  
  
          n %= f;  
       }  
       return result.toString();  
    }  
  
    private int factorial(int size) {  
       int result = 1;  
       for (int i = 1; i <= size; i++) {  
          result *= i;  
       }  
       return result;  
    }  
}
```


## 조합  
  
> 어떤 집합의 원소들을 순서 상관 없이 배열하는 것  
  
순서가 상관 없으므로 (1, 2) == (2, 1)  
  
$$_nC_r = \frac{_nP_r}{r!} = \frac{n!}{r!(n - r)!}$$  
  
```java  
class Solution {

    private int field;
    private int select;
    private int[] combinated;
    private StringBuilder result;

    public String solution(int[] input) {
        init(input);
        combinate(0, 1);
        return result.toString();
    }

    private void init(int[] input) {
        this.field = input[0];
        this.select = input[1];
        this.combinated = new int[select];
        this.result = new StringBuilder();
    }

    private void combinate(int cnt, int start) {
        if (cnt == select) {
            saveCombinated();
            return;
        }

        for (int i = start; i <= field; i++) {
            combinated[cnt] = i;
            combinate(cnt + 1, i + 1); // 중복 방지를 위해 i+1
        }
    }

    private void saveCombinated() {
        for (int i : combinated) {
            result.append(i).append(" ");
        }
        result.append("\n");
    }
}  
```  
  
## 조합 계산하기(재귀 + dp)  
  
- 파스칼의 삼각형  
  
$$_nC_r = _{n-1}C_{r-1} + _{n-1}C_r$$  
  
> `n개 중 나를 고르고(n - 1), 나머지 조합 구하기 (r - 1)` +  
`n개 중 나를 고르지 않고(n - 1), 나머지 조합 구하기(r)`  
  
* 나를 고르지 않은 경우에는 r이 줄어들지 않는다!  
  
```java  
import java.math.BigInteger;

class Solution {

    private BigInteger[][] dp;

    public BigInteger solution(int[] input) {
        init(input);
        return calc(input[0], input[1]);
    }

    private void init(int[] input) {
        this.dp = new BigInteger[input[0] + 1][input[1] + 1];
    }

    private BigInteger calc(int n, int r) {
        if (r == 0 || n == r) return BigInteger.ONE;
        if (dp[n][r] != null) return dp[n][r];

        dp[n][r] = calc(n - 1, r - 1).add(calc(n - 1, r));
        return dp[n][r];
    }
}
```