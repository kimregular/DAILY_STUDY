#docker 

도커 컴포즈 개념과 사용 방법을 간단하게 살펴보자!

## Docker Compose란?

> 여러 개의 Docker 컨테이너들을 하나의 서비스로 정의하고 구성해 하나의 묶음으로 관리할 수 있게 도와주는 툴

## 왜 사용하는거에요?

1. 여러 개의 컨테이너를 관리하는 데 용이
여러 개의 컨테이너로 이루어진 복잡한 애플리케이션을 한 번에 관리할 수 있게 해준다. 여러 컨테이너를 하나의 환경에서 실행하고 관리하는 데 도움이 된다.

2. 복잡한 명령어로 실행시킨 과정을 간소화 할 수 있다.
Docker Compose를 사용하면 컨테이너를 실행시킬 때마다 복잡한 명령어를 입력하지 않아도 된다. 단순히 `docker compose up` 명령어만 실행시키면 된다.

## 자주 사용하는 Docker Compose CLI 명령어

### compose.yml 파일 작성
```yml
services:
	webserver:
		container_name: webserver
		image: nginx
		ports:
			- 80:80
```

- Docker Compose에서는 하나의 컨테이너를 `service`라고 부른다. 
- `services` : service를 나열하기 전 입력하는 명령어
- `webserver` : services 바로 밑에 위치한 이름은 service의 이름을 나타낸다. 임의로 작성하면 된다.
- `container_name` : 서비스가 컨테이너가 될 때 가지게될 이름을 의미한다.
- `image` : 서비스의 기반이될 이미지를 의미한다.
- `ports` : 서비스가 컨테이너가 됐을 때 사용할 `호스트:컨테이너` 포트를 의미한다.

### compose.yml에서 정의한 컨테이너 실행
```sh
docker compose up    # 포그라운드에서 실행
docker compose up -d # 백그라운드에서 실행
```

### Docker Compose로 실행시킨 컨테이너 확인하기
```sh
# compose.yml에 정의된 컨테이너 중 실행 중인 컨테이너만 보여준다.
docker compose ps
# compose.yml에 정의된 모든 컨테이너를 보여준다.
docker compose ps -a
```

### Docker Compose 로그 확인하기
```sh
# compose.yml에 정의된 모든 컨테이너의 로그를 모아서 출력한다.
docker compose logs
```

### 컨테이너 실행 전에 이미지 재빌드하기
```sh
docker compose up --build    # 포그라운드에서 실행
docker compose up -d --build # 백그라운드에서 실행
```

- `compose.yml`에서 정의한 이미지 파일에서 코드가 변경 됐을 경우, 이미지를 다시 빌드해서 컨테이너를 실행시켜야 변경된 부분이 적용된다. 그러므로 `--build` 옵션을 추가해서 사용해야 한다.
- `docker compose up` : 이미지가 없을 때만 빌드해서 컨테이너를 실행시킨다. 이미지가 존재하는 경우 컨테이너만 실행시킨다.
- `docker compose up --build` : 이미지가 있더라도 빌드를 다시해서 컨테이너를 실행시킨다.

### 이미지 다운받기, 업데이트하기
```sh
docker compose pull
```

- `compose.yml`에서 정의된 이미지를 다운 받거나 업데이트 한다.
	- 로컬 환경에 이미지가 없다면 이미지를 다운 받는다.
	- 로컬 환경에 이미 이미지가 있는데, Dockerhub의 이미지와 다른 이미지일 경우 이미지를 업데이트 한다.

### Docker Compose에서 이용한 컨테이너 종료하기
```sh
docker compose down
```

## Docker Compose 사용해서 Redis 띄워보기

```yml
services:
	my-cache-server:
		image: redis
		ports:
			- 6379:6379
```

- 도커 컴포즈 파일 생성

```sh
docker compose up -d
```

- 도커 컴포즈 실행

```sh
docker compose ps
docker ps
docker compose down
```

- 도커 컨테이너 확인

## Docker Compose 사용해서 MySQL 띄워보기
```yml
services:
	my-db:
		image: mysql
		environment:
			MYSQL_ROOT_PASSWORD: password123
		volumes:
			- ./mysql_data:/var/lib/mysql # docker compose는 상대경로 허용
		ports:
			- 3306:3306
```

## Docker Compose 사용해서 SpringBoot 띄워보기
```yml
services:
	my-server:
		build: . # Dockerfile 과 같은 경로에 있다고 가정 (상대경로)
		ports:
			- 8080:8080
```

- docker-compose.yml 파일과 Dockerfile 파일이 같은 경로에 있다고 가정한다. build 명령어는 Dockerfile을 찾아 내용에 맞게 빌드를 시작한다.

```sh
docker compose up -d --build
```

- 이후 Docker Compose 명령어를 실행할 때 `--build` 옵션을 추가한다. 
- 스프링 부트 프로젝트에 패치가 있다면 `--build` 명령어로 해당 내역을 반영한다.

## Redis와 MySQL 동시에 실행시키기
```yml
services:
	my-db:
		image: mysql
		environment:
			MYSQL_ROOT_PASSWORD: password123
		volumes:
			- ./mysql_data:/var/lib/mysql
		ports:
			- 3306:3306
	my-cache-server:
		image: redis
		ports:
			- 6379:6379
```

## SpringBoot와 MySQL 동시에 실행시키기

`compose.yml` (스프링 프로젝트에 포함)
```yml
services:
	my-server:
		build: .
		ports:
			- 8080:8080
		depends_on:
			my-db:
				condition: service_healthy
	
	my-db:
		image: mysql
		environment:
			MYSQL_ROOT_PASSWORD: password123
			MYSQL_DATABASE: mydb              # db 이름
		volumes:
			- ./mysql_data:/var/lib/mysql
		ports:
			- 3306:3306
		healthckeck:
			test: [ "CMD", "mysqladmin", "ping" ]
			interval: 5s
			retries: 10
```

- `depends_on` : 스프링 애플리케이션은 MySQL에 의존한다. MySQL 컨테이너가 아직 실행 전이라면 스프링 서버도 실행될 수 없다. 따라서 컨테이너 실행 순서를 지정해야한다. 이때 사용하는 명령어이다.

## SpringBoot와 MySQL, Redis 동시에 실행시키기
```yml
services:
	my-server:
		build: .
		ports:
			- 8080:8080
		depends_on:
			my-db:
				condition: service_healthy
			my-cache-server:
				condition: service_health
	
	my-db:
		image: mysql
		environment:
			MYSQL_ROOT_PASSWORD: password123
			MYSQL_DATABASE: mydb              # db 이름
		volumes:
			- ./mysql_data:/var/lib/mysql
		ports:
			- 3306:3306
		healthckeck:
			test: [ "CMD", "mysqladmin", "ping" ]
			interval: 5s
			retries: 10
	
	my-cache-server:
		image: redis
		ports:
			- 6379:6379
		healthcheck:
			test: [ "CMD", "redist-cli", "ping" ]
			interval: 5s
			retries: 10
```