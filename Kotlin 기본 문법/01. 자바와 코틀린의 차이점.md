```kotlin
fun main() {
	println("Hello, World")
}
```

이 간단한 코드에서 발견할 수 있는 코틀린의 특징을 자바의 경우와 비교하면 다음과 같다.

1. 함수의 선언은 `fun` 이라는 키워드로 한다. 참고로 자바스크립트는 `function`, 고 언어는 `func`를 사용한다.
2. 클래스가 보이지 않는다. 코틀린은 자바와 달리 반드시 클래스를 선언할 필요가 없다. 클래스는 선택 사항이며, 코틀린은 클래스 없이 독립된 함수만 따로 존재하는 경우가 훨씬 더 많다. 반면 자바는 반드시 클래스가 필요하다. 특별히 클래스 내부에 구현된 함수는 메소드라고 부르는데, 그래서 자바는 모든 함수를 메소드라고 부른다.
3. 자바는 표준 라이브러리에서 출력을 위한 기능을 제공한다. 그게 바로 `System` 클래스에서 `out` 이라는 변수명으로 `PrintStream`을 지정하고, `println()`이라는 메소드를 실행하는 기능이다. 하나로 합치면 `System.out.println()`이며, 우리가 잘 아는, 자바에서 출력을 기본으로 하는 기본 기능이다. 뭔가 체계적으로 보이지만 아쉽게도 출력처럼 자주 쓰는 기능을 이처럼 번거롭게 구현한 점은 다소 번잡하게 느껴진다. 다행히 코틀린은 이를 한 꺼풀 더 감싸서 `println()`만 하면 동일한 기능을 제공한다. 출력 명령처럼 자주 쓰는 기능은 이처럼 짧게 제공하는 것이 무엇보다 중요하다.
	그렇다면 코틀린의 `println()`은 내부적으로 어떻게 구현되어 있을까? 코틀린의 표준 라이브러리에서 `println()` 함수를 정의한 부분을 보면 다음과 같다.
	```kotlin
	// kotlin/libraries/stdlib/jvm/src/kotlin/io/Console.kt
	@kotlin.internal.InlineOnly
	public actual inline fun println(message: Any?){
		System.out.println(message)
	}
	```
	`println()`은 단순히 자바의 `System.out.println()`을 대신 호출해주는 역할을 한다. 게다가 컴파일 이후에는 `System.out.println()`을 직접 호출한 것처럼 최적화하기 때문에 사실상 완전히 동일하다. 이 함수 덕분에 자바에서 점을 두 번이나 찍어야 했던 복잡한 문법을 코틀린에서는 훨씬 더 간결하게 개선할 수 있다.
	그렇다면 코틀린에서 출력을 할 때 `println()`대신, 자바의  `System.out.println()`을 호출하면 어떻게 될까?
	```kotlin
	fun main() {
		System.out.println("Hello, World!")
	}
	```
	전혀 문제없다. 애초에 코틀린의 `println()`이 하는 역할은 자바의 `System.out.println()`을 대신 호출해주는 역할뿐이며, 어차피 컴파일 후에는 직접 호출한 것처럼 최적화까지 한다. 
4. 라인 끝에 세미콜론(;)이 보이지 않는다. 코틀린은 자바와 달리 세미콜론을 붙일 필요가 없다. 프로그래밍 언어의 역사에서 세미콜론으로 구문을 구분하기 시작한 것은 60여년이 넘은 전통적인 방식이지만 코틀린은 이 전통에서 과감히 탈피했다. 생산성 높은 최신 언어들은 세미콜론 대신 줄바꿈으로 구문을 구분하는 경향이 있으며, 코틀린도 마찬가지로 줄바꿈으로 구문을 구분한다.

함수를 이용해 제곱값을 구하는 예제를 살펴보자.

```kotlin
fun square(x: Int): Int {
	return x * x
}

fun main() {
	val result: Int square(5)
	println(result)
}
```