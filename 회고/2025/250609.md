## 250609 회고 💬
아아 캐리어 선생님,,, 올해도 저를 더위로부터 구원하시는군요... 또다시 덥고 습한 시즌이 시작됐다. 어느새 에어컨 없이 잠들 수가 없다. 이번 주는 별다른 이벤트가 없었다. 왜냐면 SSAFY 방학이기 때문이다. 1주간의 자유시간,,,! 그리고 6월 내내 SSAFY 출근도 안 한다. 집에서 취업 특강만 들으면 된다. OH YEAH! 시간이 많은만큼 프로젝트, 포트폴리오, 청소 등등 밀린 할일들에 많이 할애했다.

## Keep 👍
### 알고리즘
알고리즘 문제 풀이를 계속 하고있다. 그날그날 기분따라서 아무 주제나 잡고 문제를 푼다.

옛날 옛날 아주먼 옛날에 BFS를 이제 막 배운 개발 지망생이 있었다. 지망생은 앞으로 넓이 탐색 문제가 나온다면 절대 틀리지 않을 것이라며 한 가지 다짐을 한다. 바로 백준에 있는 BFS 실버 문제를 모두 푼다는 다짐이었다. 그리고 정말 다 풀어버렸다. 지망생은 이제 BFS 문제라면 자면서도 코딩을 할 수 있는 머슬 메모리를 갖게 되었다. 그 지망생은 지금 다시 한번 다짐한다. 다익스트라 문제도 다 풀어버리겠다! 그리고 지금 그 다짐을 실천 중이다. ~~근데 다익스트라는 실버 문제 몇개 없는데 😵~~

- [알고스팟](https://www.acmicpc.net/problem/1261) : 2차원 배열 다익스트라 문제다. 너무 기초 문제라 뭐 딱히 설명할 부분이 없다.
- [해킹](https://www.acmicpc.net/problem/10282) : 메모리 초과 때문에 상당히 애먹었다. if문 조건 지정을 잘 해야겠다는 다짐 뿐이다. 😢
- [특정한 최단 경로](https://www.acmicpc.net/problem/1504) : 왁! 어려웠다. N으로 이동해야 하는데 이동 중에 지정해준 2 장소를 꼭 방문해야만 한다. 1 -> v1 -> v2 -> n, 1 -> v2 -> v1 -> n 두 가지 경우의 수를 계산해야 한다.

~~골드 1 달성했는데 체점 방식 변경돼서 골드 2로 다시 강등 됨... ㅂㄷㅂㄷ~~

### 출퇴근 자투리 공부
SSAFY 방학으로 출퇴근 시간 공부는 안 했다.

### 개인 공부
[개인 프로젝트](https://github.com/kimregular/mySettlement)에 개선이 있었다. SSAFY 방학 때 최대한 많이 진행해서 완성까지 도전해본다. 🤯

방학 맞이로 프로젝트에 엄청난 개선이 있었다. 이번 주에 이 많은 양을 다 해냈다! 엄청나! 대략 비디오 공유 플랫폼이라고 부를 수 있을만큼의 기능이 완성됐다. 더 진행한다면 배포 또는 성능 개선을 진행할 예정이다.

개발한 기능들을 정리, 리팩토링하면서 관련한 글을 작성했다. 확인들 해보시라!
- [유저 이미지 출력 로직 개선](https://velog.io/@regular_jk_kim/유저-이미지-출력-로직-개선)
- [메서드 기반 인증 관리와 uri](https://velog.io/@regular_jk_kim/메서드-기반-인증-관리와-uri)
- [좋아요 기능 개발](https://velog.io/@regular_jk_kim/좋아요-기능-개발)
- [댓글을 삭제하려면 조건이 어떻다구요?](https://velog.io/@regular_jk_kim/댓글을-삭제하려면-조건이-어떻다구요)
- [RefreshToken](https://velog.io/@regular_jk_kim/RefreshToken)
- [커스텀 에너테이션으로 중복되는 코드 제거하기](https://velog.io/@regular_jk_kim/커스텀-에너테이션으로-중복되는-코드-제거하기)


완료 🙌 🙌 🙌 🙌
- uri 정리 (메서드 기반 인증관리)
	- public api / permitted api 구분
- 리프레시 토큰 구현
	- jwtProvider
	- jwtProperties
	- jwtUtil
	- jwtResolver
	- RefreshToken
- 비디오 좋아요
	- videoLike / videoUnlike
- 댓글 기능
	- comment
- 내장 h2 DB에서 MySQL로 데이터베이스 전환
- 백, 프론트 디렉토리 구조 개선
	- 백엔드 모듈화
	- 프론트 모듈화

### 독서
<한 권으로 읽는 컴퓨터 구조와 프로그래밍>을 계속 읽고 있다.

## Try 🧚
- msa 공부하기
- 개인 프로젝트 진행하기
	-  백엔드
		- 테스트 코드 고도화(레스트 독스)
		- Video 도메인 테스트
		- 레스트 독스 구현
		- 비디오 썸네일 작업
		- ResponseBodyAdvice 적용하기
- 최소 1곳 이상 회사 지원하기
	-  이력서
	- 포트폴리오
- 매일 골드 이상 난의도의 알고리즘 문제 풀이 진행하기
- 책 읽기

## 독서 목록

### 서평 완료 목록
- [혼자 공부하는 컴퓨터 구조 + 운영체제](https://velog.io/@regular_jk_kim/혼자-공부하는-컴퓨터-구조-운영체제-를-읽고)
- [프로그래머의 길, 멘토에게 묻다](https://velog.io/@regular_jk_kim/프로그래머의-길-멘토에게-묻다-를-읽고-24jpq345)
- [함께 자라기 애자일로 가는 길](https://velog.io/@regular_jk_kim/함께-자라기-를-읽고)
- [객체지향의 사실과 오해](https://velog.io/@regular_jk_kim/객체지향의-사실과-오해-를-읽고)

###  서평 예정 목록 (읽는 중) 
- ~~면접을 위한 CS 전공지식 노트~~
- 한 권으로 읽는 컴퓨터 구조와 프로그래밍

### 독서 예정 목록
- 오브젝트
- HTTP 완벽 가이드
- 자바/스프링 개발자를 위한 실용주의 프로그래밍
- 모던 자바 인 액션
- 자바 성능 튜닝 이야기 
- 헤드 퍼스트 서블릿
- 파이브 라인스 오브 코드

## Extras
### [특정한 최단 경로](https://www.acmicpc.net/problem/1504)
```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

public class Main {
    
    public static void main(String[] args) {
        new Main().run();
    }

    private void run() {
        Input ip = readInput();
        System.out.println(new Solution().solution(ip.numOfNodes, ip.edges, ip.v1, ip.v2));
    }

    private Input readInput() {
        try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            StringTokenizer st = new StringTokenizer(br.readLine());
            int numOfNodes = Integer.parseInt(st.nextToken());
            int numOfEdges = Integer.parseInt(st.nextToken());

            int[][] edges = new int[numOfEdges][3];

            for(int i = 0; i < numOfEdges; i++) {
                st = new StringTokenizer(br.readLine());
                edges[i][0] = Integer.parseInt(st.nextToken());
                edges[i][1] = Integer.parseInt(st.nextToken());
                edges[i][2] = Integer.parseInt(st.nextToken());
            }

            st = new StringTokenizer(br.readLine());

            int v1 = Integer.parseInt(st.nextToken());
            int v2 = Integer.parseInt(st.nextToken());

            return new Input(numOfNodes, edges, v1, v2);

        }catch(IOException e) {
            throw new RuntimeException();
        }
    }

    private static class Input {

        final int numOfNodes;
        final int[][] edges;
        final int v1;
        final int v2;

        public Input(int numOfNodes, int[][] edges, int v1, int v2) {
            this.numOfNodes = numOfNodes;
            this.edges = edges;
            this.v1 = v1;
            this.v2 = v2;
        }
    }
}

class Solution {

    private static final int INF = Integer.MAX_VALUE;

    private List<List<int[]>> graph;
    private int[] distFrom1;
    private int[] distFromV1;
    private int[] distFromV2;

    private int v1;
    private int v2;


    public long solution(int numOfNodes, int[][] edges, int v1, int v2) {
        init(numOfNodes, edges, v1, v2);
        calc();
        return getAnswer();
    }

    private void init(int numOfNodes, int[][] edges, int v1, int v2) {
        this.graph = new ArrayList<>();
        this.distFrom1 = new int[numOfNodes + 1];
        this.distFromV1 = new int[numOfNodes + 1];
        this.distFromV2 = new int[numOfNodes + 1];

        this.v1 = v1;
        this.v2 = v2;

        for(int i = 0; i <= numOfNodes; i++) {
            graph.add(new ArrayList<>());
        }

        for(int[] edge : edges) {
            graph.get(edge[0]).add(new int[] {edge[1], edge[2]});
            graph.get(edge[1]).add(new int[] {edge[0], edge[2]});
        }

        Arrays.fill(distFrom1, INF);
        Arrays.fill(distFromV1, INF);
        Arrays.fill(distFromV2, INF);
    }

    private void calc() {
        calc(graph, distFrom1, 1);
        calc(graph, distFromV1, v1);
        calc(graph, distFromV2, v2);
    }

    private void calc(List<List<int[]>> graph, int[] dist, int startNode) {
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[1], b[1]));
        pq.offer(new int[] {startNode, 0});
        dist[startNode] = 0;

        while(!pq.isEmpty()) {
            int[] cur = pq.poll();

            if(cur[1] > dist[cur[0]]) continue;

            for(int[] node : graph.get(cur[0])) {
                int next = node[0];
                int weight = node[1];
                int nextCost = cur[1] + weight;

                if(nextCost > dist[next]) continue;
                dist[next] = nextCost;
                pq.offer(new int[] {next, nextCost});
            }
        }
    }

    private long getAnswer() {
        // 1 -> v1 -> v2 -> n
        long candidate1 = (long) distFrom1[v1] + distFromV1[v2] + distFromV2[graph.size() - 1];
        // 1 -> v2 -> v1 -> n
        long candidate2 = (long) distFrom1[v2] + distFromV2[v1] + distFromV1[graph.size() - 1];

        long result = Math.min(candidate1, candidate2);

        return (candidate1 >= INF || candidate2 >= INF) ? -1 : result;
    }
}
```