## 250223 íšŒê³  ğŸ’¬
ì½”ë¡œë‚˜ì— ê±¸ë ¸ë‹¤. ì„¸ ë²ˆì§¸ë‹¤. ê´´ë¡­ë‹¤. ëª¸ì‚´ì— ì½§ë¬¼, ê°€ë˜ ë“±ë“± ê´´ë¡œìš´ 1ì£¼ì˜€ë‹¤. ì•„ì¹¨ì— ì¼ì–´ë‚˜ëŠ”ë° ë„ˆë¬´ í˜ë“¤ì–´ì„œ ë³‘ì›ì„ ë‹¤ë…€ì˜¤ê¸°ê¹Œì§€ í–ˆë‹¤. ì½”ë¡œë‚˜ì— í˜¹ì‚¬ë‹¹í•œ 2ì›” ë„·ì§¸ ì£¼ë¥¼ ë˜ëŒì•„ë³¸ë‹¤.

## Keep ğŸ‘
- ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´ë¥¼ ê³„ì†í•˜ê³  ìˆë‹¤. ì½”í…Œ ìŠ¤í„°ë””ë¥¼ í•˜ê³  ìˆë‹¤. í˜¼ì ê³µë¶€í•  ë•ŒëŠ” ì‰¬ìš´ ë¸Œë¡ ì¦ˆ ë¬¸ì œ í’€ë©´ì„œ êµ¬ìƒ‰ë§Œ ë§ì¶”ê³¤ í–ˆë‹¤. ê·¸ëŸ°ë° ì´ì œëŠ” ê°•ì œì ìœ¼ë¡œ ê³¨ë“œ ë¬¸ì œë¥¼ í’€ê²Œ ë˜ì—ˆë‹¤. ì´ë²ˆ ì£¼ ê¸°ì¶œ ë¬¸ì œëŠ” [ë‚˜ë¬´ ì¬í…Œí¬](https://www.acmicpc.net/problem/16235)ì´ë‹¤. ê¸°ë³¸ ë¬¸ì œ ì£¼ì œë¡œëŠ” ë°±íŠ¸ë˜í‚¹, ì´ë¶„íƒìƒ‰ì´ë‹¤. ë°±íŠ¸ë˜í‚¹ì€ ì–´ëŠ ì •ë„ ë˜ëŠ”ë° ì´ë¶„íƒìƒ‰ì´ ë¬¸ì œë‹¤. ëŠ˜ ìƒˆë¡œìš´ ë‚´ìš©,,, ì–´ë µë‹¤ ì–´ë ¤ì›Œ! ë¸Œë¡ ì¦ˆë§Œ í’€ì—ˆë‹¤ê³  í•˜ì§€ë§Œ ê·¸ë˜ë„ 1ë…„ ë„˜ê²Œ ê³µë¶€í•´ì„œ ê·¸ëŸ°ì§€ 1ì‹œê°„ ë‚´ì™¸ë¡œ ê³¨ë“œ ë¬¸ì œë¥¼ í’€ ìˆ˜ëŠ” ìˆë‹¤. ğŸ¤ª
- ìŠ¤í”„ë§ ë¶€íŠ¸ ê°•ì˜ë¥¼ ë‹¤ ë“¤ì—ˆë‹¤! ë‹¤ìŒìœ¼ë¡œ ë­ ë“¤ì„ì§€ ê³ ì‹¬í•œ ê²°ê³¼ ìë°” ë©€í‹°ìŠ¤ë ˆë”©ì„ ê³µë¶€í•˜ê¸°ë¡œ í–ˆë‹¤. ê±°ì˜ ëª¨ë¥´ëŠ” ë‚´ìš©ì´ë¼ í•œë²ˆì€ ì •ë¦¬í•˜ê³  ë„˜ì–´ê°€ì•¼ í•˜ê¸°ë„ í–ˆê³ , ë™ì‹œì„± ì²˜ë¦¬ ë¬¸ì œê°€ ì¢…ì¢… í•„ìš”í•˜ê¸° ë•Œë¬¸ì— ì‹œì‘í–ˆë‹¤.
	- springboot
		- ë§ˆì´í¬ë¡œë¯¸í„°
	- multi thread
		- life cycle
		- ë©”ëª¨ë¦¬ ê°€ì‹œì„±
		- synchronized
		- ìƒì‚°ì ì†Œë¹„ì ë¬¸ì œ
- ê°œì¸ í”„ë¡œì íŠ¸ ì§„í–‰í•  ì‹œê°„ ë‚´ê¸°ê°€ ì°¸ í˜ë“¤ë‹¤. ì´ë²ˆ ì£¼ì— SSAFYì—ì„œ ìˆœì—´, ì¡°í•©, ë¶€ë¶„ì§‘í•© ê´€ë ¨ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œë¥¼ ë‚´ì¤¬ëŠ”ë° ì´ê²ƒë“¤ ì²˜ë¦¬í•˜ë‹¤ë³´ë‹ˆ ê°œì¸í”„ë¡œì íŠ¸ ì§„í–‰ì„ í•˜ë‚˜ë„ ëª»í–ˆë‹¤.
- CS ìŠ¤í„°ë””ë¥¼ ì§„í–‰í–ˆë‹¤. ì´ë²ˆ ì£¼ì—ëŠ” ë©”ëª¨ë¦¬ì™€ ì»´í“¨í„° ì£¼ë³€ ê¸°ê¸°ë“¤ì„ í•™ìŠµí–ˆë‹¤.
	- ë©”ëª¨ë¦¬, ìºì‹œ
	- í•˜ë“œë””ìŠ¤í¬
	- ë“œë¼ì´ë²„

## Try ğŸ§š
- SSAFY Bí˜• ëŒ€ë¹„ ë¬¸ì œ í’€ì´í•˜ê¸°
- ì‚¼ì„± ê¸°ì¶œ ë¬¸ì œì§‘ ë¬¸ì œ í’€ì´
- í† ì´ í”„ë¡œì íŠ¸ ë¹„ë””ì˜¤ ì—…ë¡œë“œ ë¡œì§ ì™„ì„±
	- ë°±ì—”ë“œ
		- ê°œì¸ í”„ë¡œí•„ ë¡œì§ ì œì‘
		- ë¹„ë””ì˜¤ ì—…ë¡œë“œ ë¡œì§
	- í”„ë¡ íŠ¸ì—”ë“œ
		- ê°œì¸ í”„ë¡œí•„ í™”ë©´ ì œì‘
		- ë¹„ë””ì˜¤ í™”ë©´ ì œì‘

## ë…ì„œ ëª©ë¡

### ì„œí‰ ì™„ë£Œ ëª©ë¡
- [í˜¼ì ê³µë¶€í•˜ëŠ” ì»´í“¨í„° êµ¬ì¡° + ìš´ì˜ì²´ì œ](https://velog.io/@regular_jk_kim/í˜¼ì-ê³µë¶€í•˜ëŠ”-ì»´í“¨í„°-êµ¬ì¡°-ìš´ì˜ì²´ì œ-ë¥¼-ì½ê³ )
- [í”„ë¡œê·¸ë˜ë¨¸ì˜ ê¸¸, ë©˜í† ì—ê²Œ ë¬»ë‹¤](https://velog.io/@regular_jk_kim/í”„ë¡œê·¸ë˜ë¨¸ì˜-ê¸¸-ë©˜í† ì—ê²Œ-ë¬»ë‹¤-ë¥¼-ì½ê³ -24jpq345)
- [í•¨ê»˜ ìë¼ê¸° ì• ìì¼ë¡œ ê°€ëŠ” ê¸¸](https://velog.io/@regular_jk_kim/í•¨ê»˜-ìë¼ê¸°-ë¥¼-ì½ê³ )
- [ê°ì²´ì§€í–¥ì˜ ì‚¬ì‹¤ê³¼ ì˜¤í•´](https://velog.io/@regular_jk_kim/ê°ì²´ì§€í–¥ì˜-ì‚¬ì‹¤ê³¼-ì˜¤í•´-ë¥¼-ì½ê³ )

###  ì„œí‰ ì˜ˆì • ëª©ë¡ (ì½ëŠ” ì¤‘) 
- ë©´ì ‘ì„ ìœ„í•œ CS ì „ê³µì§€ì‹ ë…¸íŠ¸

### ë…ì„œ ì˜ˆì • ëª©ë¡
- ì˜¤ë¸Œì íŠ¸
- HTTP ì™„ë²½ ê°€ì´ë“œ
- ìë°”/ìŠ¤í”„ë§ ê°œë°œìë¥¼ ìœ„í•œ ì‹¤ìš©ì£¼ì˜ í”„ë¡œê·¸ë˜ë°
- ëª¨ë˜ ìë°” ì¸ ì•¡ì…˜
- ìë°” ì„±ëŠ¥ íŠœë‹ ì´ì•¼ê¸° 
- í—¤ë“œ í¼ìŠ¤íŠ¸ ì„œë¸”ë¦¿
- íŒŒì´ë¸Œ ë¼ì¸ìŠ¤ ì˜¤ë¸Œ ì½”ë“œ

## Extras ğŸ˜€
### [ë‚˜ë¬´ ì¬í…Œí¬](https://www.acmicpc.net/problem/16235)
```java
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.util.*;  
  
public class Main {  
  
    public static void main(String[] args) {  
       new Main().run();  
    }  
  
    private void run() {  
       try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {  
  
          Input ip = readInput(br);  
          Solution s = new Solution();  
          System.out.println(s.solution(ip.years, ip.fertilizeInfo, ip.treeInfo));  
  
       } catch (IOException e) {  
          throw new RuntimeException(e);  
       }  
    }  
  
    private Input readInput(BufferedReader br) throws IOException {  
       StringTokenizer st = new StringTokenizer(br.readLine());  
       int fertilizeLen = Integer.parseInt(st.nextToken());  
       int numOfTrees = Integer.parseInt(st.nextToken());  
       int years = Integer.parseInt(st.nextToken());  
  
       int[][] fertilizeInfo = new int[fertilizeLen][fertilizeLen];  
  
       for (int i = 0; i < fertilizeLen; i++) {  
          st = new StringTokenizer(br.readLine());  
          for (int j = 0; j < fertilizeLen; j++) {  
             fertilizeInfo[i][j] = Integer.parseInt(st.nextToken());  
          }  
       }  
  
       int[][] treeInfo = new int[numOfTrees][3];  
       for (int i = 0; i < numOfTrees; i++) {  
          st = new StringTokenizer(br.readLine());  
          treeInfo[i][0] = Integer.parseInt(st.nextToken()) - 1;  
          treeInfo[i][1] = Integer.parseInt(st.nextToken()) - 1;  
          treeInfo[i][2] = Integer.parseInt(st.nextToken());  
       }  
  
       return new Input(years, fertilizeInfo, treeInfo);  
    }  
  
    private static class Input {  
  
       final int years;  
       final int[][] fertilizeInfo;  
       final int[][] treeInfo;  
  
       public Input(int years, int[][] fertilizeInfo, int[][] treeInfo) {  
          this.years = years;  
          this.fertilizeInfo = fertilizeInfo;  
          this.treeInfo = treeInfo;  
       }  
    }  
}  
  
class Solution {  
  
    private Field field;  
    private PriorityQueue<Tree> trees;  
    private Queue<Tree> deadTrees;  
  
    public int solution(int years, int[][] fertilizeInfo, int[][] treeInfo) {  
       init(fertilizeInfo, treeInfo); // í’€ì´ ë¡œì§ ì´ˆê¸°í™”  
  
       while (years-- > 0) { // ì£¼ì–´ì§„ ë…„ë„ ë°˜ë³µ  
          spring();  
          summer();  
          fall();  
          winter();  
       }  
       return trees.size(); // ëë‚˜ê³  ë‚¨ì€ ë‚˜ë¬´ì˜ ê°œìˆ˜ ë°˜í™˜  
    }  
  
    private void init(int[][] fertilizeInfo, int[][] treeInfos) {  
       this.field = new Field(fertilizeInfo);  
       this.trees = new PriorityQueue<>();  
       this.deadTrees = new ArrayDeque<>();  
       for (int[] treeInfo : treeInfos) {  
          this.trees.offer(new Tree(treeInfo[0], treeInfo[1], treeInfo[2]));  
       }  
    }  
  
    private void spring() {  
       PriorityQueue<Tree> newTrees = new PriorityQueue<>();  
       // ìë¼ë‚œ ë‚˜ë¬´ë“¤ ì„ì‹œ ì €ì¥  
  
       while (!trees.isEmpty()) {  
          Tree tree = trees.poll();  
          if (field.afford(tree)) {  
             // ë§Œì•½ ë‚˜ë¬´ê°€ ë¨¹ì„ ì–‘ë¶„ì´ ìˆìœ¼ë©´  
             field.sock(tree);  
             // ë•…ì—ì„œëŠ” ì–‘ë¶„ì´ ì‚¬ë¼ì§€ê³   
             tree.grow();  
             // ë‚˜ë¬´ëŠ” ìë¼ë‚¨  
             newTrees.offer(tree);  
             // ì„ì‹œ ì €ì¥  
          } else {  
             deadTrees.offer(tree);  
             // ë¨¹ì„ê²Œ ì—†ìœ¼ë©´ ìœ¼ì•™ ì¥¬ê¸ˆ  
          }  
       }  
       trees = newTrees;  
       // ì„ì‹œ ë‚˜ë¬´ë“¤ì„ ë‹¤ì‹œ ì›ë˜ ë³€ìˆ˜ì— ì €ì¥  
    }  
  
    private void summer() {  
       for (Tree deadTree : deadTrees) {  
          // ì£½ì€ ë‚˜ë¬´ë“¤ì„  
          field.fertilizeWith(deadTree);  
          // ë•…ì˜ ë¹„ë£Œë¡œ  
       }  
       deadTrees.clear();  
       // ì´ê±° ì•ˆ í•´ì„œ ì‹œê°„ì´ˆê³¼ ë‚¬ìŒ  
    }  
  
    private void fall() {  
       int[][] DIRECTIONS = {{0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1}, {-1, 0}, {-1, 1}};  
       // 8ë°©í–¥ íƒìƒ‰  
  
       Queue<Tree> temp = new ArrayDeque<>();  
       // ìƒˆë¡œ ìƒê¸´ ë‚˜ë¬´ë“¤ ì„ì‹œ ì €ì¥  
  
       for (Tree tree : trees) {  
          if (tree.age % 5 != 0) continue;  
          // ë‚˜ì´ê°€ 5ë°°ìˆ˜ê°€ ì•„ë‹ˆë©´ ìŠ¤í‚µ  
  
          for (int[] direction : DIRECTIONS) {  
             int nx = tree.x + direction[0];  
             int ny = tree.y + direction[1];  
  
             if (field.isOutOfField(nx, ny)) continue;  
             // ë°­ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë©´ ìŠ¤í‚µ  
  
             temp.offer(new Tree(nx, ny, 1));  
             // ìƒˆë¡œìš´ ë‚˜ë¬´ ì„ì‹œ ì €ì¥  
          }  
       }  
       trees.addAll(temp);  
       // ìƒˆë¡œ ìƒê¸´ ë‚˜ë¬´ë“¤ ëª¨ë‘ ì €ì¥  
    }  
  
    private void winter() {  
       field.fertilize();  
       // ì£¼ì–´ì§„ ìˆ˜ì¹˜ë§Œí¼ ë•…ì— ë¹„ë£Œ ì¶”ê°€  
    }  
}  
  
class Tree implements Comparable<Tree> {  
  
    int x;  
    int y;  
    int age;  
  
    public Tree(int x, int y, int age) {  
       this.x = x;  
       this.y = y;  
       this.age = age;  
    }  
  
    public void grow() {  
       age++;  
    }  
  
    @Override  
    public int compareTo(Tree o) {  
       return Integer.compare(age, o.age);  
    }  
}  
  
class Field {  
  
    private int[][] field;  
    private int[][] fertilizeInfo;  
  
    public Field(int[][] fertilizeInfo) {  
       this.fertilizeInfo = fertilizeInfo;  
       this.field = new int[fertilizeInfo.length][fertilizeInfo.length];  
       for (int[] f : field) {  
          Arrays.fill(f, 5);  
          // ë•…ì˜ ì´ˆê¸°ê°’ì€ 5  
       }  
    }  
  
    public boolean afford(Tree tree) {  
       return field[tree.x][tree.y] >= tree.age;  
       // ë‚˜ë¬´ê°€ ë¨¹ì„ ë§Œí¼ ì˜ì–‘ë¶„ì´ ìˆëŠ”ì§€?  
    }  
  
    public void sock(Tree tree) {  
       field[tree.x][tree.y] -= tree.age;  
       // ë‚˜ë¬´ê°€ ì˜ì–‘ë¶„ ë¹¨ì•„ê°  
    }  
  
    public boolean isOutOfField(int x, int y) {  
       return x < 0 || x >= field.length || y < 0 || y >= field.length;  
    }  
  
    public void fertilize() {  
       // ì§€ì—­ì— ì •í•´ì§„ ì–‘ë§Œí¼ ì˜ì–‘ë¶„ ì¶”ê°€  
       for (int i = 0; i < field.length; i++) {  
          for (int j = 0; j < field.length; j++) {  
             field[i][j] += fertilizeInfo[i][j];  
          }  
       }  
    }  
  
    public void fertilizeWith(Tree tree) {  
       // ì£½ì€ ë‚˜ë¬´ë¥¼ ì˜ì–‘ë¶„ìœ¼ë¡œ ë³€í™˜  
       field[tree.x][tree.y] += (tree.age / 2);  
    }  
}
```