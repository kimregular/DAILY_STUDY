## 240804 íšŒê³  ğŸ’¬
ë³¸ê²© ë°±ìˆ˜ ìƒí™œ 2ë‹¬ ì°¨, 8ì›”ì´ ì‹œì‘ëë‹¤. ì¥ë§ˆê°€ ëë‚˜ë„ ìŠµê¸°ëŠ” ì¢€ ì‚¬ë¼ì¡Œì§€ë§Œ ê·¸ëŸ¼ì—ë„ ì—„ì²­ë‚œ í­ì—¼ìœ¼ë¡œ ë°–ì„ ë‚˜ê°€ì§€ ì•Šì•˜ë‹¤. í•˜ì§€ë§Œ ì¬ìˆ˜ê°€ ì—†ìœ¼ë©´ ë’¤ë¡œ ë„˜ì–´ì ¸ë„ ì½”ê°€ ê¹¨ì§„ëŒ”ë‚˜? ì§‘ì—ë§Œ ìˆì—ˆìŒì—ë„ ì½”ë¡œë‚˜ì— ê±¸ë ¤ë²„ë ¸ë‹¤. ìš°ë¦¬ ì§‘ì— ëˆ„ê°€ ëª°ë˜ ë“¤ì–´ì˜¨ ê±´ê°€? ì™œ ì½”ë¡œë‚˜ì— ê±¸ë ¸ëŠ”ì§€ ì•Œ ìˆ˜ê°€ ì—†ë‹¤. í•œë°¤ì¤‘ì— ì¶”ì›Œì„œ ê¹¼ë‹¤ ì ë“¤ê¸°ë¥¼ ë°˜ë³µí•˜ë‹¤ ë³´ë‹ˆ ì—„ì²­ë‚˜ê²Œ ê´´ë¡­ë‹¤. ê·¸ë˜ì„œ í•œì—¬ë¦„ì¸ë°ë„ ê²¨ìš¸ ì´ë¶ˆì„ êº¼ë‚´ë²„ë ¸ë‹¤. ì™€ ì½”ë¡œë‚˜ ì—„ì²­ í˜ë“¤ë‹¤. ì½”ë¡œë‚˜ë¡œ ì‹œì‘í•˜ëŠ” 8ì›”ì˜ ì²«ì§¸ ì£¼ë¥¼ ë˜ëŒì•„ë³¸ë‹¤.
## Keep ğŸ‘
- ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œí’€ì´ë¥¼ ì—­ì‹œë‚˜ 7ì¼ ì—°ì†ìœ¼ë¡œ í•´ëƒˆë‹¤. 8ì›” 4ì¼ ê¸°ì¤€ ì—°ì† 295ì¼ì§¸, 697ë¬¸ì œë¥¼ í’€ì´ ì¤‘ì´ë‹¤. ìš”ì¦˜ ë‹¤ì‹œ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ê¸°ê°€ ì¬ë°Œì–´ì ¸ì„œ í•˜ë£¨ì— 3, 4ë¬¸ì œì”© í’€ ë•Œë„ ìˆë‹¤. ì•ˆ í’€ë¦¬ë©´ ë„ˆë¬´ ê´´ë¡­ì§€ë§Œ ë˜ ê·¸ë§Œí¼ í‘¼ ë‹¤ìŒì˜ ì¾Œê°ì´ ì»¤ì„œ ê·¸ë§Œë‘ê¸°ê°€ í˜ë“¤ë‹¤. ğŸ‹ï¸
	- [ë¡œë´‡ì²­ì†Œê¸°] (https://www.acmicpc.net/problem/14503) ì¡°ê±´ì´ ì¢€ ë§ì§€ë§Œ ê¹Œë‹¤ë¡­ì§€ ì•Šê¸° ë•Œë¬¸ì— ì²œì²œíˆ êµ¬í˜„í•˜ë‹¤ ë³´ë©´ ì‰½ê²Œ í’€ ìˆ˜ ìˆë‹¤. ê³¨ë“œì™€ ì‹¤ë²„ ì‚¬ì´ì˜ ë¬¸ì œë‹¤. ê°ì²´ì§€í–¥ ì ìœ¼ë¡œ ì„¤ê³„í•˜ë ¤ê³  ê³ ë¯¼ì¢€ í–ˆë‹¤.
	- [ì´ì¤‘ ìš°ì„ ìˆœìœ„ í] (https://www.acmicpc.net/problem/7662) ì•„ì´ë””ì–´ë§Œ ë– ì˜¬ë¦¬ë©´ ì‰½ê²Œ í’€ìˆ˜ ìˆëŠ” ë¬¸ì œë‹¤. ìš°ì„  ìˆœìœ„ í 2ê°œë¥¼ ì‚¬ìš©í•´ë„ ë˜ì§€ë§Œ ì—°ì‚°ëŸ‰ì´ ëŠ˜ì–´ë‚˜ê¸°ì— ë‹¤ë¥¸ ìë£Œêµ¬ì¡° ì‚¬ìš©í•˜ê¸°ë¥¼ ì¶”ì²œí•œë‹¤. ë§¨ ì•ê³¼ ë§¨ ë’¤ë¥¼ í•œë²ˆì— ì ‘ê·¼í•  ìˆ˜ ìˆì–´ì•¼í•˜ê³ , ì •ë ¬ì´ ë¹ ë¥´ê²Œ ë˜ëŠ” ìë£Œêµ¬ì¡°ë¥¼ ì‚¬ìš©í•´ì•¼í•œë‹¤.
- "í•¨ê»˜ ìë¼ê¸° ì• ìì¼ë¡œ ê°€ëŠ” ê¸¸"ì„ ê³„ì† ì½ê³  ìˆë‹¤. 
- ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´ë¥¼ í•˜ëŠë¼ ìš”ì¦˜ì—ëŠ” ì•Œê³ ë¦¬ì¦˜ ê³µë¶€ì— ì§‘ì¤‘ í•˜ê³  ìˆë‹¤. ìŠ¤í”„ë§ ê³µë¶€ë„ í•´ì•¼í•˜ëŠ”ë°,,,ğŸ¤¦â€â™‚ï¸
	- ê·¸ë˜í”„
	- íŠ¸ë¦¬
	- ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ
	- ìš°ì„ ìˆœìœ„ í

## Problem ğŸ¤¢

## Try ğŸ§š
- í•¨ê»˜ ìë¼ê¸° ë§ˆë¬´ë¦¬í•˜ê¸°
- ìµœì†Œì‹ ì¥íŠ¸ë¦¬ ê³µë¶€í•˜ê¸°
	- ìœ ë‹ˆì˜¨íŒŒì¸ë“œ (o)
	- í”„ë¦¼
- ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´ 

## Extras ğŸ˜€
### [ë¡œë´‡ì²­ì†Œê¸°] (https://www.acmicpc.net/problem/14503) 
```java

import java.util.*;
import java.io.*;

public class Main {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            Input ip = getInput(br);
            Solution s = new Solution();
            System.out.println(s.solution(ip.startLocation, ip.toward, ip.room));

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static Input getInput(BufferedReader br) throws IOException {
        String[] dimension = br.readLine().split(" ");
        int x = Integer.parseInt(dimension[0]);
        int y = Integer.parseInt(dimension[1]);

        int[][] room = new int[x][y];

        String[] info = br.readLine().split(" ");
        int startX = Integer.parseInt(info[0]);
        int startY = Integer.parseInt(info[1]);
        int toward = Integer.parseInt(info[2]);

        for (int i = 0; i < room.length; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine(), " ");
            for (int j = 0; j < room[i].length; j++) {
                room[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        return new Input(new int[]{startX, startY}, toward, room);
    }

    private static class Input {

        int[] startLocation;
        int toward;
        int[][] room;

        public Input(int[] startLocation, int toward, int[][] room) {
            this.startLocation = startLocation;
            this.toward = toward;
            this.room = room;
        }
    }
}

class Solution {

    public int solution(int[] startLocation, int toward, int[][] room) {
        Calculator c = new Calculator(startLocation, toward, room);
        return c.getResult();
    }
}

class Calculator {

    VacuumCleaner vacuumCleaner;
    Room room;
    int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};  // UP, RIGHT, DOWN, LEFT

    public Calculator(int[] startLocation, int toward, int[][] room) {
        this.vacuumCleaner = new VacuumCleaner(startLocation, toward);
        this.room = new Room(room);
    }

    public int getResult() {
        cleanUp();
        return vacuumCleaner.cleaned;
    }

    private void cleanUp() {
        while (true) {
            if (room.getStatusOf(vacuumCleaner.location) == 0) {
                room.getClean(vacuumCleaner.location);
                vacuumCleaner.cleaned++;
            }

            if (noDirtAround()) {
                if (room.noWallBehind(vacuumCleaner.getBackward())) {
                    vacuumCleaner.goBackward();
                } else {
                    break;
                }
            } else {
                vacuumCleaner.turn();
                if (room.isWithinRoom(vacuumCleaner.getForward()) && room.getStatusOf(vacuumCleaner.getForward()) == 0) {
                    vacuumCleaner.goForward();
                }
            }
        }
    }

    public boolean noDirtAround() {
        int[] location = vacuumCleaner.location;
        for (int[] direction : directions) {
            int nx = location[0] + direction[0];
            int ny = location[1] + direction[1];

            if (room.isWithinRoom(nx, ny) && room.getStatusOf(nx, ny) == 0) {
                return false;
            }
        }
        return true;
    }
}

class VacuumCleaner {

    int[] location;
    Direction toward;
    int cleaned = 0;

    public VacuumCleaner(int[] location, int toward) {
        this.location = location;
        this.toward = Direction.setDirection(toward);
    }

    public int[] getForward() {
        int[] forward = toward.getForward();
        return new int[]{location[0] + forward[0], location[1] + forward[1]};
    }

    public void goForward() {
        int[] forward = toward.getForward();
        location = new int[]{location[0] + forward[0], location[1] + forward[1]};
    }

    public void goBackward() {
        int[] backward = toward.getBackward();
        location = new int[]{location[0] + backward[0], location[1] + backward[1]};
    }

    public int[] getBackward() {
        int[] backward = toward.getBackward();
        return new int[]{location[0] + backward[0], location[1] + backward[1]};
    }

    public void turn() {
        toward = Direction.turnLeft(toward);
    }

    private enum Direction {

        UPWARD(0, new int[]{-1, 0}, new int[]{1, 0}),
        RIGHTWARD(1, new int[]{0, 1}, new int[]{0, -1}),
        DOWNWARD(2, new int[]{1, 0}, new int[]{-1, 0}),
        LEFTWARD(3, new int[]{0, -1}, new int[]{0, 1}),
        ;

        private final int toward;
        private final int[] forward;
        private final int[] backward;

        Direction(int toward, int[] forward, int[] backward) {
            this.toward = toward;
            this.forward = forward;
            this.backward = backward;
        }

        public static Direction setDirection(int toward) {
            for (Direction d : Direction.values()) {
                if (d.toward == toward) return d;
            }
            return UPWARD;
        }

        public int[] getForward() {
            return forward;
        }

        public int[] getBackward() {
            return backward;
        }

        public static Direction turnLeft(Direction d) {
            switch(d) {
                case UPWARD -> {
                    return LEFTWARD;
                }
                case RIGHTWARD -> {
                    return UPWARD;
                }
                case DOWNWARD -> {
                    return RIGHTWARD;
                }
                case LEFTWARD -> {
                    return DOWNWARD;
                }
            }
            return d;
        }
    }
}

class Room {

    int[][] room;

    public Room(int[][] room) {
        this.room = room;
    }

    public int getStatusOf(int[] location) {
        int x = location[0];
        int y = location[1];
        return room[x][y];
    }

    public int getStatusOf(int x, int y) {
        return room[x][y];
    }

    public void getClean(int[] location) {
        int x = location[0];
        int y = location[1];
        room[x][y] = -1;
    }

    public boolean isWithinRoom(int x, int y) {
        return 0 <= x && x < room.length && 0 <= y && y < room[x].length;
    }

    public boolean noWallBehind(int[] location) {
        int x = location[0];
        int y = location[1];
        return isWithinRoom(x, y) && room[x][y] != 1;
    }

    public boolean isWithinRoom(int[] forward) {
        int x = forward[0];
        int y = forward[1];
        return 0 <= x && x < room.length && 0 <= y && y < room[x].length;
    }
}

```
### [ì´ì¤‘ ìš°ì„ ìˆœìœ„ í] (https://www.acmicpc.net/problem/7662)
```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.TreeMap;

public class Main {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            int TEST_CASE = Integer.parseInt(br.readLine());

            while (TEST_CASE-- > 0) {
                Solution s = new Solution();
                int orderLen = Integer.parseInt(br.readLine());
                while (orderLen-- > 0) {
                    String[] order = br.readLine().split(" ");
                    s.process(order[0], Integer.parseInt(order[1]));
                }
                System.out.println(s.getResult());
            }

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

class Solution {

    DoublePriorityQueue dpq = new DoublePriorityQueue();

    public void process(String order, int num) {
        dpq.calc(order, num);
    }

    public String getResult() {
        return dpq.getResult();
    }
}

class DoublePriorityQueue {

    private TreeMap<Integer, Integer> map = new TreeMap<>();

    public String getResult() {
        if (map.isEmpty()) return "EMPTY";
        return map.lastKey() + " " + map.firstKey();
    }

    public void calc(String order, int num) {
        if (order.equals("I")) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        } else {
            deleteCalc(num);
        }
    }

    private void deleteCalc(int num) {
        if (map.isEmpty()) return;

        int key = (num == 1) ? map.lastKey() : map.firstKey();

        if (map.get(key) == 1) {
            map.remove(key);
        } else {
            map.put(key, map.get(key) - 1);
        }
    }
}

```
## ë…ì„œ ëª©ë¡

### ì„œí‰ ì™„ë£Œ ëª©ë¡
- [í˜¼ì ê³µë¶€í•˜ëŠ” ì»´í“¨í„° êµ¬ì¡° + ìš´ì˜ì²´ì œ](https://github.com/kimregular/DAILY_STUDY/blob/main/ë…ì„œ/1.%20ì„œí‰/01.%20í˜¼ì%20ê³µë¶€í•˜ëŠ”%20ì»´í“¨í„°%20êµ¬ì¡°%20%2B%20ìš´ì˜ì²´ì œ%20ë¥¼%20ì½ê³ %20ğŸ“.md)

###  ì„œí‰ ì˜ˆì • ëª©ë¡ (ì½ëŠ” ì¤‘)
- í”„ë¡œê·¸ë˜ë¨¸ì˜ ê¸¸, ë©˜í† ì—ê²Œ ë¬»ë‹¤
- í•¨ê»˜ ìë¼ê¸° ì• ìì¼ë¡œ ê°€ëŠ” ê¸¸

### ë…ì„œ ì˜ˆì • ëª©ë¡
#### ëª©ë¡ì€ ìš°ì„ ìˆœìœ„ íì´ë‹¤. ìƒë‹¨ì— ìˆë”ë¼ë„ ë” ì¤‘ìš”í•œ ì±…ì´ ë“¤ì–´ì˜¨ë‹¤ë©´ ìˆœìœ„ê°€ ë’¤ë¡œ ë°€ë¦´ ìˆ˜ ìˆë‹¤.
- ê°ì²´ì§€í–¥ì˜ ì‚¬ì‹¤ê³¼ ì˜¤í•´
- ì˜¤ë¸Œì íŠ¸
- íŒŒì´ë¸Œ ë¼ì¸ìŠ¤ ì˜¤ë¸Œ ì½”ë“œ
- HTTP ì™„ë²½ ê°€ì´ë“œ
- ìë°”/ìŠ¤í”„ë§ ê°œë°œìë¥¼ ìœ„í•œ ì‹¤ìš©ì£¼ì˜ í”„ë¡œê·¸ë˜ë°
- ëª¨ë˜ ìë°” ì¸ ì•¡ì…˜
- ìë°” ì„±ëŠ¥ íŠœë‹ ì´ì•¼ê¸° 
- ìë°” ê°œë°œìì™€ ì‹œìŠ¤í…œ ìš´ì˜ìë¥¼ ìœ„í•œ íŠ¸ëŸ¬ë¸” ìŠˆíŒ… ì´ì•¼ê¸° / scouterë¥¼ í™œìš©í•œ ì‹œìŠ¤í…œ ì¥ì•  ì§„ë‹¨ ë° í•´ê²° ë…¸í•˜ìš° ìë°” íŠ¸ëŸ¬ë¸”ìŠˆíŒ…
- í—¤ë“œ í¼ìŠ¤íŠ¸ ì„œë¸”ë¦¿
- Hello Coding ê·¸ë¦¼ìœ¼ë¡œ ê°œë…ì„ ì´í•´í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
