## 241104 íšŒê³  ğŸ’¬
11ì›”ì´ ì‹œì‘ëë‹¤. ë‚®ì— 20ë„ê¹Œì§€ ì˜¬ë¼ê°€ëŠ” 11ì›”ì´ë‹¤. ë´„ë‚ ì”¨ê°€ ëŠê»´ì§€ëŠ” 11ì›”ì˜ ì²« ì£¼ë¥¼ ë˜ëŒì•„ë³¸ë‹¤.

## Keep ğŸ‘
- ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œí’€ì´ë¥¼ 7ì¼ ì—°ì†ìœ¼ë¡œ í•´ëƒˆë‹¤. 241104ê¸°ì¤€ìœ¼ë¡œ 387ì¼, 800ë¬¸ì œ í•´ê²° ì¤‘ì´ë‹¤. ì´ë²ˆ ì£¼ì—ëŠ” MST, í”Œë¡œì´ë“œ ì•Œê³ ë¦¬ì¦˜ì„ ê³µë¶€í–ˆë‹¤. 
	- [ë„ì‹œ ë¶„í•  ê³„íš](https://www.acmicpc.net/problem/1647) ê°„ë‹¨í•œ MST ë¬¸ì œë‹¤. í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ë³´ë‹¤ëŠ” í¬ë£¨ìŠ¤ì¹¼ì„ ì„ í˜¸í•´ì„œ MSTë¬¸ì œëŠ” ê±°ì§„ ëª¨ë‘ í¬ë£¨ìŠ¤ì¹¼ì„ ì‚¬ìš©í•´ í’€ì´í•œë‹¤. ì¸í’‹ ì²˜ë¦¬ë§Œ ì˜ í•´ê²°í•˜ë©´ ë‚˜ë¨¸ì§€ ë¡œì§ì€ ì „í˜•ì ì¸ ë¬¸ì œí’€ì´ ë°©ë²•ìœ¼ë¡œ ì ‘ê·¼í•˜ë©´ ëœë‹¤.
	- [Line Friends (Small)] (https://www.acmicpc.net/problem/14588) í”Œë¡œì´ë“œ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œë‹¤. ì„ ë¶„ì´ ê²¹ì¹˜ëŠ”ì§€ íŒë‹¨í•˜ëŠ” ë¡œì§ë§Œ ìƒê°í•´ë‚¼ ìˆ˜ ìˆìœ¼ë©´ í•´ë‹¹ ë¬¸ì œë„ ì „í˜•ì ì¸ í’€ì´ë°©ì‹ìœ¼ë¡œ ì ‘ê·¼í•´ì„œ í•´ê²° ê°€ëŠ¥í•˜ë‹¤. ì„ ë¶„ ê²¹ì¹˜ëŠ” ë¡œì§ ìƒê°í•˜ê¸°ê°€ ì‹œê°„ì´ ë§ì´ ê±¸ë ¸ë‹¤.
- í† ì´ í”„ë¡œì íŠ¸ë¥¼ ì œì‘í•˜ê³  ìˆë‹¤. ì´ë²ˆ ì£¼ì—ëŠ” í”„ë¡ íŠ¸ ì‘ì—…ì„ ë§ì´ í–ˆë‹¤.
	- ë™ì˜ìƒ ë…¹í™” ë¡œì§ ì œì‘
	- ë™ì˜ìƒ ì„¬ë„¤ì¼ ë§Œë“œëŠ” ë¡œì§ ì œì‘
	- Webpack & SCSS 

## Try ğŸ§š
- ê°ì²´ì§€í–¥ì˜ ì‚¬ì‹¤ê³¼ ì˜¤í•´ ë§ˆë¬´ë¦¬í•˜ê¸°
- ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´ 
- í”„ë¡ íŠ¸ ì„œë²„ êµ¬ì¶•
	- node ê°œë… í•™ìŠµ
	- cors í•´ê²°í•˜ê¸°
- ë°±ì—”ë“œ ì„œë²„ ê°œë°œ
	- ì¸ì¦, ì¸ê°€
	- mvp ì œì‘

## ë…ì„œ ëª©ë¡

### ì„œí‰ ì™„ë£Œ ëª©ë¡
- [í˜¼ì ê³µë¶€í•˜ëŠ” ì»´í“¨í„° êµ¬ì¡° + ìš´ì˜ì²´ì œ](https://velog.io/@regular_jk_kim/í˜¼ì-ê³µë¶€í•˜ëŠ”-ì»´í“¨í„°-êµ¬ì¡°-ìš´ì˜ì²´ì œ-ë¥¼-ì½ê³ )
- [í”„ë¡œê·¸ë˜ë¨¸ì˜ ê¸¸, ë©˜í† ì—ê²Œ ë¬»ë‹¤](https://velog.io/@regular_jk_kim/í”„ë¡œê·¸ë˜ë¨¸ì˜-ê¸¸-ë©˜í† ì—ê²Œ-ë¬»ë‹¤-ë¥¼-ì½ê³ -24jpq345)

###  ì„œí‰ ì˜ˆì • ëª©ë¡ (ì½ëŠ” ì¤‘) 
- í•¨ê»˜ ìë¼ê¸° ì• ìì¼ë¡œ ê°€ëŠ” ê¸¸
- ê°ì²´ì§€í–¥ì˜ ì‚¬ì‹¤ê³¼ ì˜¤í•´

### ë…ì„œ ì˜ˆì • ëª©ë¡
#### ëª©ë¡ì€ ìš°ì„ ìˆœìœ„ íì´ë‹¤. ìƒë‹¨ì— ìˆë”ë¼ë„ ë” ì¤‘ìš”í•œ ì±…ì´ ë“¤ì–´ì˜¨ë‹¤ë©´ ìˆœìœ„ê°€ ë’¤ë¡œ ë°€ë¦´ ìˆ˜ ìˆë‹¤.
- ì˜¤ë¸Œì íŠ¸
- íŒŒì´ë¸Œ ë¼ì¸ìŠ¤ ì˜¤ë¸Œ ì½”ë“œ
- HTTP ì™„ë²½ ê°€ì´ë“œ
- ìë°”/ìŠ¤í”„ë§ ê°œë°œìë¥¼ ìœ„í•œ ì‹¤ìš©ì£¼ì˜ í”„ë¡œê·¸ë˜ë°
- ëª¨ë˜ ìë°” ì¸ ì•¡ì…˜
- ìë°” ì„±ëŠ¥ íŠœë‹ ì´ì•¼ê¸° 
- ìë°” ê°œë°œìì™€ ì‹œìŠ¤í…œ ìš´ì˜ìë¥¼ ìœ„í•œ íŠ¸ëŸ¬ë¸” ìŠˆíŒ… ì´ì•¼ê¸° / scouterë¥¼ í™œìš©í•œ ì‹œìŠ¤í…œ ì¥ì•  ì§„ë‹¨ ë° í•´ê²° ë…¸í•˜ìš° ìë°” íŠ¸ëŸ¬ë¸”ìŠˆíŒ…
- í—¤ë“œ í¼ìŠ¤íŠ¸ ì„œë¸”ë¦¿
- Hello Coding ê·¸ë¦¼ìœ¼ë¡œ ê°œë…ì„ ì´í•´í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜


## Extras ğŸ˜€
### [ë„ì‹œ ë¶„í•  ê³„íš](https://www.acmicpc.net/problem/1647)
```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.StringTokenizer;
import java.util.stream.IntStream;

public class Main {

    public static void main(String[] args) {
        new Main().run();
    }

    private void run() {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            Input ip = readInput(br);
            Solution s = new Solution();
            System.out.println(s.solution(ip.numOfHouses, ip.roads));

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private Input readInput(BufferedReader br) throws IOException {
        String[] tokens = br.readLine().split(" ");
        int numOfHouese = Integer.parseInt(tokens[0]);
        int numOfRoads = Integer.parseInt(tokens[1]);

        int[][] roads = new int[numOfRoads][3];

        for (int i = 0; i < numOfRoads; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine(), " ");
            int from = Integer.parseInt(st.nextToken());
            int to = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());
            roads[i][0] = from;
            roads[i][1] = to;
            roads[i][2] = cost;
        }

        return new Input(numOfHouese, roads);
    }

    private static class Input {
        private final int numOfHouses;
        private final int[][] roads;

        public Input(int numOfHouses, int[][] roads) {
            this.numOfHouses = numOfHouses;
            this.roads = roads;
        }
    }
}

class Solution {

    public int solution(int numOfHouses, int[][] roads) {
        int[] group = IntStream.range(0, numOfHouses + 1).toArray();

        Arrays.sort(roads, Comparator.comparing(a -> a[2]));

        int max = 0;
        int answer = 0;
        for (int[] road : roads) {
            int from = road[0];
            int to = road[1];

            if(isGroup(group, from, to)) continue;
            connect(group, from, to);

            int cost = road[2];
            answer += cost;
            if(max < cost) max = cost;
        }

        return answer - max;
    }

    private boolean isGroup(int[] group, int target1, int target2) {
        return getGroup(group, target1) == getGroup(group, target2);
    }

    private int getGroup(int[] group, int target) {
        if(target != group[target]) group[target] = getGroup(group, group[target]);
        return group[target];
    }

    private void connect(int[] group, int target1, int target2) {
        int g1 = getGroup(group, target1);
        int g2 = getGroup(group, target2);
        if (g1 != g2) {
            group[Math.max(g1, g2)] = Math.min(g1, g2);
        }
    }
}
```
### [Line Friends (Small)] (https://www.acmicpc.net/problem/14588)
```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {

    public static void main(String[] args) {
        new Main().run();
    }

    private void run() {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            Solution s = new Solution();
            System.out.println(s.solution(readInput(br), readQuestions(br)));

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private int[][] readInput(BufferedReader br) throws IOException {
        int len = Integer.parseInt(br.readLine());
        int[][] result = new int[len + 1][2];

        for (int i = 1; i < len + 1; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine(), " ");
            int start = Integer.parseInt(st.nextToken());
            int end = Integer.parseInt(st.nextToken());
            result[i][0] = start;
            result[i][1] = end;
        }
        return result;
    }

    private int[][] readQuestions(BufferedReader br) throws IOException {
        int len = Integer.parseInt(br.readLine());
        int[][] result = new int[len][2];

        for (int i = 0; i < len; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine(), " ");
            int start = Integer.parseInt(st.nextToken());
            int end = Integer.parseInt(st.nextToken());
            result[i][0] = start;
            result[i][1] = end;
        }
        return result;
    }
}

class Solution {

    public String solution(int[][] people, int[][] questions) {
        int len = people.length;

        int[][] relations = getRelations(people);

        for (int k = 1; k < len; k++) {
            for (int i = 1; i < len; i++) {
                for (int j = 1; j < len; j++) {
                    if (relations[i][j] > relations[i][k] + relations[k][j]) {
                        relations[i][j] = relations[i][k] + relations[k][j];
                    }
                }
            }
        }

        StringBuilder answer = new StringBuilder();
        for (int[] question : questions) {
            int from = question[0];
            int to = question[1];
            if(relations[from][to] == 0 || relations[from][to] == 999_999_999) answer.append(-1);
            else answer.append(relations[from][to]);
            answer.append("\n");
        }

        return answer.toString();
    }

    private int[][] getRelations(int[][] people) {
        int len = people.length;
        int[][] relations = new int[len][len];
        for (int i = 1; i < len; i++) {
            for (int j = 1; j < len; j++) {
                if(i == j) continue;
                if(isConnected(people[i], people[j])) relations[i][j] = 1;
            }
        }

        for (int i = 1; i < len; i++) {
            for (int j = 1; j < len; j++) {
                if(i == j) continue;
                if(relations[i][j] == 0) relations[i][j] = 999_999_999;
            }
        }
        return relations;
    }

    private boolean isConnected(int[] target1, int[] target2) {
        return Math.max(target1[0], target2[0]) <= Math.min(target1[1], target2[1]);
    }
}
```