## 240331 íšŒê³  ğŸ’¬
ë´„ í™©ì‚¬ì™€ í•¨ê»˜ ë¯¸ì„¸ë¨¼ì§€ê°€ ê¸°ìŠ¹ì„ ë¶€ë¦¬ëŠ” 1ì£¼ì¼ì´ì—ˆë‹¤. ì½” ì•„í”„ê³ , ëª© ì•„í”„ê³ , ì†ë„ ëˆì ê±°ë¦¬ê³ ,,, ğŸ¤§ ê°€ë§Œíˆ ìˆì–´ë„ ìˆ˜ëª…ì´ ê¹ì—¬ë‚˜ê°€ëŠ” 1ì£¼ì¼...ğŸ’€ 24ë…„ 3ì›”ì˜ ë§ˆì§€ë§‰ ì£¼ë¥¼ íšŒê³ í•œë‹¤.
## Keep ğŸ‘
- ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´ë¥¼ ì´ë²ˆ ì£¼ì—ë„ 7ì¼ ì—°ì†ìœ¼ë¡œ í•´ëƒˆë‹¤. ê·¸ë¦¬ê³  ì˜¤í”„ë¼ì¸ ì•Œê³ ë¦¬ì¦˜ ìŠ¤í„°ë”” ê·¸ë£¹ë„ ì°¸ê°€í–ˆë‹¤. 
	- ì•Œê³ ë¦¬ì¦˜ ì¸ê°• ë³µìŠµ ì§„í–‰ì€ íšŒì‚¬ ìŠ¤í„°ë”” ì‹œê°„ì— í•˜ë ¤ê³  í–ˆë‹¤. ê·¸ëŸ°ë° ìš”ì¦˜ ë°”ë¹ ì„œ íšŒì‚¬ ìŠ¤í„°ë”” ì§„í–‰ì´ ì•ˆ ëœë‹¤. ì£¼ë§ì— ëª°ì•„ì„œ ë¬¸ì œ í’€ì´ë¥¼ ì§„í–‰í–ˆë‹¤. ì €ë²ˆ ë³µìŠµì‹œê°„ì—ëŠ” ë°˜ë³µë¬¸, 2ì°¨ì› ë°°ì—´ ë¶€ë¶„ì„ ëëƒˆë‹¤. ê·¸ë˜ì„œ ì´ë²ˆ ë³µìŠµ ì‹œê°„ì—ëŠ” í•´ì‰¬, ë§µ ìë£Œêµ¬ì¡°ë¥¼ ì´ìš©í•œ ë¬¸ì œ í’€ì´ë¥¼ ì§„í–‰í–ˆë‹¤. 
	- íŒ€ ìŠ¤íŒŒë¥´íƒ€ì˜ 99í´ëŸ½ ì½”í…Œ ìŠ¤í„°ë””ì— ì°¸ê°€í–ˆë‹¤. í˜¼ì ì½”í…Œ ì¤€ë¹„ë¥¼ í•´ì˜¨ì§€ ì–´ì–¸ ë°˜ë…„... íê´€ìˆ˜ë ¨í•˜ëŠ” ê¸°ë¶„ì´ë‹¤. í˜¼ì ê³µë¶€í•˜ë‹¤ë³´ë‹ˆ ë‚´ê°€ ì§€ê¸ˆ ì–´ëŠ ì •ë„ì¸ì§€ ê°€ëŠ í•  ìˆ˜ ì—†ì—ˆë‹¤. ê·¸ë¦¬ê³  ì‚¬ì‹¤ ì‰¬ìš´ ë¬¸ì œë¥¼ ê³¨ë¼ í‘¸ëŠ” ìš”ë ¹ë„ ì—†ì–ì•„ ìˆë‹¤ë³´ë‹ˆ ì ì  ë§¤ë„ˆë¦¬ì¦˜ì— ë¹ ì§€ëŠ” ìƒí™©ì´ì—ˆë‹¤. ê·¸ëŸ°ë° ë§¤ì¼ 1ë¬¸ì œì”© ì¶”ì²œì„ í•´ì£¼ê³  ë‹¤ë¥¸ ì‚¬ëŒë“¤ í’€ì´ë„ ë“¤ì–´ ë³¼ ìˆ˜ ìˆëŠ” ì‹œê°„ì´ ìƒê²¼ë‹¤. ì¢‹ì€ ê¸°íšŒë¼ê³  ì—¬ê¸°ê³  ìˆë‹¤.
	- [ì°¨ì§‘í•©](https://www.acmicpc.net/problem/1822) í•´ì‰¬ ë¬¸ì œë¥¼ í’€ì—ˆë‹¤. ì‹¤ë²„ 4 ìˆ˜ì¤€ ë¬¸ì œì—ëŠ” ìë£Œ êµ¬ì¡° ë¬¸ì œê°€ ë§ì€ ë“¯ í•˜ë‹¤. ì…ë ¥ ì›ì†Œ ê°œìˆ˜ê°€ ë§ì§€ ì•Šê¸° ë•Œë¬¸ì— ë³µì¡í•œ ë¡œì§ì€ í•„ìš”í•˜ì§€ ì•Šë‹¤. í•´ì‰¬ ê°œë…ë§Œ ì•Œê³  ìˆìœ¼ë©´ ì‰½ê²Œ í’€ ìˆ˜ ìˆë‹¤. ë§ˆì§€ë§‰ì— ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì›ì†Œ ì¶œë ¥ì´ í•„ìš”í•˜ë‹¤. ì´ ë¶€ë¶„ë„ ê°„ë‹¨í•˜ê²Œ ì†ŒíŒ…í•˜ë©´ ëœë‹¤. í•´ì‰¬ ê°œë…ì„ ì•„ëƒ ëª¨ë¥´ëƒ ë¬¼ì–´ë³´ëŠ” ë¬¸ì œì´ë‹¤.
	- [ì„¸ ê°œì˜ ì†Œìˆ˜ ë¬¸ì œ](https://www.acmicpc.net/problem/11502) ì†Œìˆ˜ íŒë³„ ë¬¸ì œë¥¼ í’€ì—ˆë‹¤. ì—ë¼í† ìŠ¤í…Œë„¤ìŠ¤ì˜ ì±„ë¡œ ì†Œìˆ˜ë“¤ì„ êµ¬í•œ ë‹¤ìŒ ë¸Œë£¨íŠ¸ í¬ìŠ¤ë¡œ ëª©í‘¯ê°’ì„ ì°¾ìœ¼ë©´ ë˜ëŠ” ë¬¸ì œë‹¤. ì—­í• ë³„ë¡œ í´ë˜ìŠ¤ë¥¼ ë‚˜ëˆ„ëŠë¼ ì‹œê°„ì´ ì¢€ ê±¸ë ¸ë‹¤.
	- [ì§€ë¢° ì°¾ê¸°](https://www.acmicpc.net/problem/4396) ë¬¸ì œ ì„¤ëª…ì„ ì´í•´í•˜ëŠ”ë° ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë ¸ë‹¤. ì—­ì‹œ êµ­ì–´ê°€ ì œì¼ ë¬¸ì œë‹¤. ë¬¸ì œ í’€ì´ í¬ì¸íŠ¸ë¡œëŠ” ì¼ë‹¨ ì…ë ¥ê°’ëŒ€ë¡œ í´ë¦­ì„ ê³„ì† ì§„í–‰í•œë‹¤ëŠ” ì ì´ë‹¤. ê·¸ë¦¬ê³  ë§Œì•½ í´ë¦­í•œ ìœ„ì¹˜ì— ì§€ë¢°ê°€ ìœ„ì¹˜í•œë‹¤ë©´ ì§€ë¢° ìœ„ì¹˜ë§Œ ê²°ê³¼ê°’ì— í‘œì‹œí•´ì£¼ë©´ ëœë‹¤. 
	- [Sort ë§ˆìŠ¤í„° ë°°ì§€í›ˆì˜ í›„ê³„ì](https://www.acmicpc.net/problem/20551) ë¬¸ì œë¥¼ í’€ì—ˆë‹¤. ì •ë ¬ê³¼ í•´ì‰¬ë§µ ê°œë…ì´ ì„ì¸ ë¬¸ì œë‹¤. ë§µ ê¸°ë³¸ ë©”ì†Œë“œë¥¼ ì•Œê³  ìˆë‹¤ë©´ ì‰½ê²Œ í’€ ìˆ˜ ìˆëŠ” ë¬¸ì œë‹¤.
	- ì•Œê³ ë¦¬ì¦˜ ì¸ê°• ë³µìŠµë„ ì§„í–‰í–ˆë‹¤. ì´ë²ˆì— í‘¼ ë¬¸ì œë“¤ì€ ë‚¯ì„  ë©”ì†Œë“œë¥¼ ì‚¬ìš©í•´ì•¼ ì‰½ê²Œ í’€ ìˆ˜ ìˆëŠ” ë¬¸ì œì˜€ë‹¤. Map ì˜ equals() ë©”ì†Œë“œëŠ” ë‘ ê°œì˜ map ì¸ìŠ¤í„´ìŠ¤ í‚¤ì™€ ê·¸ í‚¤ì˜ ê°’ì´ ê°™ì€ì§€ ë¹„êµí•´ì¤€ë‹¤. TreeSet ì€ ê¸°ë³¸ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ì´ë‹¤. ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ê°’ì„ ì–»ê³  ì‹¶ë‹¤ë©´ ìˆœíšŒí•˜ëŠ” ìˆœê°„ì— descendingSet() ë©”ì†Œë“œë¥¼ ì‚¬ìš©í•˜ë©´ ëœë‹¤. ì•„ë‹ˆë©´ TreeSet ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ì‹œì ì— Collections.reverseOrder() íŒŒë¼ë¯¸í„°ë¥¼ ë„˜ê²¨ì£¼ë©´ ëœë‹¤.
	```java
	// 1. descendingSet() ì˜µì…˜ ì‚¬ìš©
	for (Integer i : deck.descendingSet()) {  
		if(idx++ + 1 == targetIdx) return i;  
	}

	// 2. ìƒì„±ì‹œ ë‚´ë¦¼ì°¨ìˆœ ì˜µì…˜ ì¶”ê°€
	new TreeSet<>(Collections.reverseOrder());
	```
- Servlet ê³µë¶€ë„ ì§„í–‰í–ˆë‹¤.
	- init() -> service() -> doGet() || doPost() íë¦„ìœ¼ë¡œ ì„œë¸”ë¦¿ì´ ìŠ¤ë ˆë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ê³¼ì •ì„ ìƒëª… ì£¼ê¸°ë¥¼ ê³µë¶€í•˜ë©° ì•Œì•„ë´¤ë‹¤. ì„œë¸”ë¦¿ì€ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ì§€ ì•Šê³  ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ì—¬ ìš”ì²­ì„ ì²˜ë¦¬í•œë‹¤. ê·¸ëŸ¬ë¯€ë¡œ í´ë¼ì´ì–¸íŠ¸ ìš”ì²­ì— ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•œë‹¤ëŠ” ë§ì€ í‹€ë¦° ë§ì´ë‹¤.
	- doGet() í˜¹ì€ doPost() ë©”ì†Œë“œëŠ” ì¸ìë¡œ HttpServletRequest, HttpServletResponse ë‘ ê°€ì§€ë¥¼ ë°›ëŠ”ë‹¤. ê·¸ëŸ°ë° ì´ ë‘ íŒŒë¼ë¯¸í„°ëŠ” ì¸í„°í˜ì´ìŠ¤ì´ë‹¤. ì¸ìŠ¤í„´ìŠ¤ëŠ” ëˆ„ê°€ ìƒì„±í• ê¹Œ? ë°”ë¡œ ì»¨í…Œì´ë„ˆê°€ ìƒì„±í•œë‹¤. ê°œë°œìëŠ” HttpServletRequest, HttpServletResponse ë‘ ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•  ì¼ì´ ì ˆëŒ€ ì—†ë‹¤. ê·¸ëŸ¬ë‹ˆ ê·¸ëƒ¥ ì‚¬ìš©ë§Œ í•˜ë©´ ëœë‹¤.
- ë§¤ì¼ì€ ì•„ë‹ˆì§€ë§Œ ê·¸ë˜ë„ ìš´ë™ì„ í•˜ê¸´ í–ˆë‹¤. ì£¼ë§ì—ëŠ” í—¬ìŠ¤ì¥ë„ ë‹¤ë…€ì™”ë‹¤. ì´ë²ˆ ì£¼ì—ëŠ” ë“±ìš´ë™ì„ ì§„í–‰í–ˆë‹¤. 
- ì¶œí‡´ê·¼ ê³µë¶€ë¡œ ìë°” ê¸°ë³¸ ë¬¸ë²• ë³µìŠµì„ í•˜ê³  ìˆë‹¤. ì´ë²ˆ ì£¼ì—ëŠ” ì¶”ìƒ í´ë˜ìŠ¤, ë©”ì†Œë“œì™€ ì¸í„°í˜ì´ìŠ¤, ìƒì†, ë‹¤ì¤‘ êµ¬í˜„ì„ ê³µë¶€í–ˆë‹¤. ë¶€ë„ëŸ½ì§€ë§Œ ì¶”ìƒ í´ë˜ìŠ¤ì™€ ì¸í„°í˜ì´ìŠ¤ì˜ ì°¨ì´ì ì„ ëª…ì¾Œí•˜ê²Œ ì„¤ëª…í•˜ì§€ ëª»í•˜ëŠ” ìƒíƒœì˜€ë‹¤. í•˜ì§€ë§Œ ì´ë²ˆ ê³µë¶€ë¡œ ìì‹  ìˆê²Œ ì„¤ëª…í•  ìˆ˜ ìˆê²Œ ë˜ì—ˆë‹¤. ë˜í•œ ë‹¤ì¤‘ êµ¬í˜„ì„ í–ˆì„ ë•Œì˜ ë©”ì†Œë“œ í˜¸ì¶œ íë¦„ë„ ê³µë¶€í–ˆë‹¤.

## Extras ğŸ˜€
### [ì°¨ì§‘í•©](https://www.acmicpc.net/problem/1822)
```java
import java.io.*;  
import java.util.*;  
  
public class Main {  
  
    public static void main(String[] args) {  
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {  
  
            Input ip = getInput(br);  
            Solution s = new Solution();  
            System.out.println(s.solution(ip.arr1, ip.arr2));  
  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        }  
    }  
  
    private static Input getInput(BufferedReader br) throws IOException {  
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");  
        int len1 = Integer.parseInt(st.nextToken());  
        int len2 = Integer.parseInt(st.nextToken());  
  
        int[] arr1 = getArray(br, len1);  
        int[] arr2 = getArray(br, len2);  
  
        return new Input(arr1, arr2);  
    }  
  
    private static int[] getArray(BufferedReader br, int len) throws IOException {  
        int[] arr = new int[len];  
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");  
        for (int i = 0; i < arr.length; i++) {  
            arr[i] = Integer.parseInt(st.nextToken());  
        }  
        return arr;  
    }  
    static class Input{  
        int[] arr1;  
        int[] arr2;  
  
        public Input(int[] arr1, int[] arr2) {  
            this.arr1 = arr1;  
            this.arr2 = arr2;  
        }  
    }  
}  
  
class Solution {  
  
    public String solution(int[] arr1, int[] arr2) {  
        return getAnswer(getDiffer(arr1, getSet(arr2)));  
    }  
  
    private String getAnswer(List<Integer> list) {  
        StringBuilder answer = new StringBuilder();  
        if(list.isEmpty()) return "0";  
  
        answer.append(list.size()).append("\n");  
  
        for (int i : list) {  
            answer.append(i).append(" ");  
        }  
        return answer.toString();  
    }  
  
    private List<Integer> getDiffer(int[] arr1, Set<Integer> set) {  
        List<Integer> result = new ArrayList<>();  
  
        for (int i : arr1) {  
            if(!set.contains(i)) result.add(i);  
        }  
        Collections.sort(result);  
        return result;  
    }  
  
    private Set<Integer> getSet(int[] arr) {  
        Set<Integer> set = new HashSet<>();  
        for (int i : arr) {  
            set.add(i);  
        }  
        return set;  
    }  
}
```

### [ì„¸ ê°œì˜ ì†Œìˆ˜ ë¬¸ì œ](https://www.acmicpc.net/problem/11502)
```java
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.util.ArrayList;  
import java.util.Arrays;  
import java.util.List;  
  
public class Main {  
  
    public static void main(String[] args) {  
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {  
  
            Solution s = new Solution();  
            System.out.println(s.solution(getInput(br)));  
  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        }  
    }  
  
    private static int[] getInput(BufferedReader br) throws IOException {  
        int len = Integer.parseInt(br.readLine());  
  
        int[] arr = new int[len];  
        for (int i = 0; i < arr.length; i++) {  
            arr[i] = Integer.parseInt(br.readLine());  
        }  
  
        return arr;  
    }  
}  
  
class Solution {  
  
    public String solution(int[] arr) {  
        return getAnswer(arr);  
    }  
  
    private String getAnswer(int[] arr) {  
        StringBuilder answer = new StringBuilder();  
        for (int i : arr) {  
            Sieve sieve = new Sieve(i);  
            ThreePrimeProblemSolver tpps = new ThreePrimeProblemSolver(i, sieve.getPrimeNums());  
            int[] result = tpps.solveThreePrimeProblem();  
            if (isSolved(result)) {  
                for (int primeNum : result) {  
                    answer.append(primeNum).append(" ");  
                }  
                answer.append("\n");  
            }  
        }  
        return answer.toString();  
    }  
  
    private boolean isSolved(int[] result) {  
        int sum = 0;  
        for (int i : result) {  
            sum += i;  
        }  
  
        return sum != 0;  
    }  
}  
  
class ThreePrimeProblemSolver {  
  
    int target;  
    List<Integer> sievedNums;  
  
    public ThreePrimeProblemSolver(int target, List<Integer> sievedNums) {  
        this.target = target;  
        this.sievedNums = sievedNums;  
    }  
  
    public int[] solveThreePrimeProblem() {  
        for (Integer sievedNum1 : this.sievedNums) {  
            for (Integer sievedNum2 : this.sievedNums) {  
                for (Integer sievedNum3 : this.sievedNums) {  
                    if(sievedNum1 + sievedNum2 + sievedNum3 == this.target)  
                        return new int[]{sievedNum1, sievedNum2, sievedNum3};  
                }  
            }  
        }  
        return new int[]{0, 0, 0};  
    }  
}  
  
class Sieve {  
  
    boolean[] sieve;  
  
    List<Integer> primeNums;  
  
    public Sieve(int limit) {  
        this.sieve = new boolean[limit + 1];  
        Arrays.fill(this.sieve, true);  
        this.primeNums = getSievedNums();  
    }  
  
    private List<Integer> getSievedNums() {  
        List<Integer> sievedNums = new ArrayList<>();  
  
        for (int i = 2; i < this.sieve.length; i++) {  
            if (this.sieve[i]) {  
                sievedNums.add(i);  
                sieveNums(i);  
            }  
        }  
        return sievedNums;  
    }  
  
    private void sieveNums(int num) {  
        for (int i = num * 2; i < this.sieve.length; i += num) {  
            this.sieve[i] = false;  
        }  
    }  
  
    public List<Integer> getPrimeNums() {  
        return this.primeNums;  
    }  
}
```

### [ì§€ë¢° ì°¾ê¸°] (https://www.acmicpc.net/problem/4396)
```java

import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            int len = Integer.parseInt(br.readLine());
            Solution s = new Solution();
            System.out.println(s.solution(getInput(br, len), getInput(br, len)));

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static String[][] getInput(BufferedReader br, int len) throws IOException {
        String[][] board = new String[len][len];

        for (int i = 0; i < board.length; i++) {
            board[i] = br.readLine().split("");
        }

        return board;
    }
}

class Solution {

    public String solution(String[][] board, String[][] input) {
        MineSearchPlayer msp = new MineSearchPlayer(board, input);
        return getAnswer(msp.getResult());
    }

    private String getAnswer(String[][] result) {
        StringBuilder answer = new StringBuilder();

        for (String[] row : result) {
            for (String i : row) {
                answer.append(i);
            }
            answer.append("\n");
        }
        return answer.toString();
    }

    private class MineSearchPlayer {

        String[][] mineField;
        String[][] inputs;
        boolean[][] isVisited;
        int[][] result;
        String[][] processedField;

        boolean isAlreadyFail = false;

        int[][] directions = {{0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1}, {-1, 0}, {-1, 1}};

        public MineSearchPlayer(String[][] mineField, String[][] inputs) {
            this.mineField = mineField;
            this.inputs = inputs;
            this.isVisited = new boolean[mineField.length][mineField[0].length];
            this.result = new int[mineField.length][mineField[0].length];
            this.processedField = new String[mineField.length][mineField[0].length];
            for (String[] strings : this.processedField) {
                Arrays.fill(strings, ".");
            }
        }

        public String[][] getResult() {
            playMineSearch();
            return afterPlay();
        }

        private String[][] afterPlay() {
            for (int x = 0; x < this.result.length; x++) {
                for (int y = 0; y < this.result[x].length; y++) {
                    if (this.isVisited[x][y])this.processedField[x][y] = String.valueOf(this.result[x][y]);
                }
            }

            if(this.isAlreadyFail) failProcess();

            return this.processedField;
        }

        private void playMineSearch() {
            for (int x = 0; x < this.inputs.length; x++) {
                for (int y = 0; y < this.inputs[x].length; y++) {
                    if("x".equals(this.inputs[x][y])){
                        search(x, y);
                    }
                }
            }
        }

        private void search(int x, int y) {
            this.isVisited[x][y] = true;
            if (isMineLocated(x, y) && !this.isAlreadyFail) {
                this.isAlreadyFail = true;
            }
            for (int[] direction : this.directions) {
                int nx = x + direction[0];
                int ny = y + direction[1];
                if (isWithinMineField(nx, ny) && isMineLocated(nx, ny)) this.result[x][y]++;
            }
        }

        private boolean isWithinMineField(int x, int y) {
            return 0 <= x && x < this.inputs.length && 0 <= y && y < this.inputs[x].length;
        }

        private boolean isMineLocated(int x, int y) {
            return "*".equals(this.mineField[x][y]);
        }

        private void failProcess() {
            for (int x = 0; x < this.processedField.length; x++) {
                for (int y = 0; y < this.processedField[x].length; y++) {
                    if("*".equals(this.mineField[x][y])) this.processedField[x][y] = "*";
                }
            }
        }
    }
}



```