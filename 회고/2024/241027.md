## 241027 íšŒê³  ğŸ’¬
10ì›”ì´ ê±°ì˜ ëë‚˜ê°„ë‹¤. 24ë…„ë„ 100ì¼ì´ ì±„ ë‚¨ì§€ ì•Šì•˜ë‹¤. ê³§ ì„œë¥¸ì¸ë°... â˜¹ï¸ ì´ë²ˆ ì£¼ ë­˜ í–ˆë‚˜ 10ì›”ì˜ ë„·ì§¸ ì£¼ë¥¼ ë˜ëŒì•„ë³¸ë‹¤.

## Keep ğŸ‘
- ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´ë¥¼ 7ì¼ ì—°ì† í•´ëƒˆë‹¤. 241027ê¸°ì¤€ 379ì¼ ì—°ì†í’€ì´, 790ë¬¸ì œ í•´ê²° ì¤‘ì´ë‹¤. ì´ë²ˆ ì£¼ì—ëŠ” ìœ„ìƒì •ë ¬ê³¼ ìµœì†ŒìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ë¥¼ ê³µë¶€í–ˆë‹¤.
	- [ë¬¸ì œì§‘](https://www.acmicpc.net/problem/1766) ê°€ì¥ ê¸°ë³¸ì ì€ ìœ„ìƒì •ë ¬ ë¬¸ì œì´ë‹¤. ìœ„ìƒì •ë ¬ ê¸°ë³¸ ê°œë…(ê·¸ë˜í”„ ê°œë…ì€ ë”°ë¡œ ê³µë¶€í•´ì•¼í•¨)ì„ ê³µë¶€í•œ í›„ì— ë°”ë¡œ ë„ì „í•  ìˆ˜ ìˆëŠ” ë¬¸ì œë‹¤. indegree ê°€ 0ì´ ë˜ëŠ” ìˆœìœ¼ë¡œ ì¶œë ¥í•˜ë©´ ëœë‹¤.
	- [ê²Œì„ê°œë°œ](https://www.acmicpc.net/problem/1516) ìœ„ìƒì •ë ¬ dp ë¬¸ì œë‹¤. indegree ë°°ì—´ ì™¸ì— ì†Œìš”ì‹œê°„ì„ ì €ì¥í•˜ëŠ” dpë°°ì—´ì„ í•˜ë‚˜ ë” ì •ì˜í•˜ê³  ì—¬ê¸°ì— ê³„ì‚°ì„ ì ìš©í•˜ë©´ ëœë‹¤. indegree ê°’ì´ 0ì´ ë˜ëŠ” ë…¸ë“œë“¤ì„ ì²˜ë¦¬í•˜ë©´ì„œ ê·¸ ë‹¤ìŒ ê±´ë¬¼ì˜ ê±´ì„¤ ì†Œìš”ì‹œê°„ì„ ê°±ì‹ í•˜ë©´ ëœë‹¤.
	- [ìŒì•…í”„ë¡œê·¸ë¨](https://www.acmicpc.net/problem/2623) ê¸°ë³¸ ìœ„ìƒì •ë ¬ ë¬¸ì œì™€ ë˜‘ê°™ë‹¤. ë‹¤ë§Œ ì¸í’‹ìœ¼ë¡œ ìˆœí™˜ê·¸ë˜í”„ê°€ ì£¼ì–´ì§ˆ ìˆ˜ ìˆë‹¤. ìˆœí™˜ê·¸ë˜í”„ì˜ ê²½ìš°ì—ëŠ” ìœ„ìƒì •ë ¬ì´ ë¶ˆê°€ëŠ¥í•˜ë‹¤. ì´ ê²½ìš°ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë¡œì§ì„ êµ¬í˜„í•˜ëŠ”ê²Œ ì´ ë¬¸ì œì˜ í¬ì¸íŠ¸ë‹¤. indegree ê°€ 0ì´ë˜ëŠ” ë…¸ë“œë¥¼ ì²˜ë¦¬í•˜ë©´ì„œ ì¹´ìš´íŠ¸ê°’ì„ ëˆ„ì ì‹œí‚¨ë‹¤. ë¡œì§ì´ ëë‚˜ê³  ì¹´ìš´íŠ¸ ê°’ê³¼ ë…¸ë“œì˜ ê°’ì„ ë¹„êµ, ê°’ì´ ë‹¤ë¥´ë©´ ìˆœí™˜ ê·¸ë˜í”„ê°€ ìˆë‹¤ê³  í•  ìˆ˜ ìˆë‹¤. 
	- [ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬](https://www.acmicpc.net/problem/1197) ê°€ì¥ ê¸°ë³¸ì ì¸ mst ë¬¸ì œì´ë‹¤. í¬ë£¨ìŠ¤ì¹¼ì„ ì‚¬ìš©í•˜ë˜, í”„ë¦¼ì„ ì‚¬ìš©í•˜ë˜ í¸í•œ ë¡œì§ìœ¼ë¡œ êµ¬í˜„í•˜ë©´ ëœë‹¤. ê°œì¸ì ìœ¼ë¡œ í¬ë£¨ìŠ¤ì¹¼ í’€ì´ë¥¼ ì¢‹ì•„í•´ì„œ í¬ë£¨ìŠ¤ì¹¼ë¡œë§Œ í’€ì´í•˜ê³  ìˆë‹¤. í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì€ ì§ê´€ì ì¸ ì´í•´ê°€ ì•„ì§ ì•ˆ ë¼ì„œ ì‚¬ìš©ì„ ì§€ì–‘í•˜ê³  ìˆë‹¤. 
	- [ë„¤íŠ¸ì›Œí¬ ì—°ê²°](https://www.acmicpc.net/problem/1922) ê°€ì¥ ê¸°ë³¸ì ì¸ mst ë¬¸ì œ2ì´ë‹¤. ë§ˆì°¬ê°€ì§€ë¡œ í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•´ì„œ í’€ì´í–ˆë‹¤. 
- ë…¸ë“œ + ìµìŠ¤í”„ë ˆìŠ¤ë¥¼ ê³µë¶€í•˜ê³  ìˆë‹¤. ê¸°ì¡´ ìŠ¤í”„ë§ê³¼ ê°œë…ì´ ë‹¤ë¥¸ ë¶€ë¶„ì´ ë§ì•„ ë§ì´ ë°©í™©í•˜ëŠ” ì¤‘ì´ë‹¤. ì´ê²Œ ë­,,, ì™€ ì–´ë µë‹¤. 
	- multarë¥¼ ì´ìš©í•œ íŒŒì¼ ì—…ë¡œë“œ
	- mongooseë¥¼ ì‚¬ìš©í•œ ì—°ê´€ê´€ê³„ ë§¤í•‘ (1:N, N:1, ì–‘ë°©í–¥)
- ë…ì„œë¡œ ê°ì²´ì§€í–¥ì˜ ì‚¬ì‹¤ê³¼ ì˜¤í•´ë¥¼ ì½ê³  ìˆë‹¤. 

## Problem ğŸ¤¢
ìˆœê³µ ì‹œê°„ì„ ê¸¸ê²Œ ì¡ì§€ ëª»í•˜ê³ ìˆë‹¤. ì§‘ì¤‘ë ¥ì´ ë§ì´ ì•ˆ ì¢‹ë‹¤. 

## Try ğŸ§š
- ê°ì²´ì§€í–¥ì˜ ì‚¬ì‹¤ê³¼ ì˜¤í•´ ë§ˆë¬´ë¦¬í•˜ê¸°
- ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´ 
- í”„ë¡ íŠ¸ ì„œë²„ êµ¬ì¶•
	- node ê°œë… í•™ìŠµ
	- cors í•´ê²°í•˜ê¸°
- ë°±ì—”ë“œ ì„œë²„ ê°œë°œ
	- ì¸ì¦, ì¸ê°€
	- mvp ì œì‘

## ë…ì„œ ëª©ë¡

### ì„œí‰ ì™„ë£Œ ëª©ë¡
- [í˜¼ì ê³µë¶€í•˜ëŠ” ì»´í“¨í„° êµ¬ì¡° + ìš´ì˜ì²´ì œ](https://velog.io/@regular_jk_kim/í˜¼ì-ê³µë¶€í•˜ëŠ”-ì»´í“¨í„°-êµ¬ì¡°-ìš´ì˜ì²´ì œ-ë¥¼-ì½ê³ )
- [í”„ë¡œê·¸ë˜ë¨¸ì˜ ê¸¸, ë©˜í† ì—ê²Œ ë¬»ë‹¤](https://velog.io/@regular_jk_kim/í”„ë¡œê·¸ë˜ë¨¸ì˜-ê¸¸-ë©˜í† ì—ê²Œ-ë¬»ë‹¤-ë¥¼-ì½ê³ -24jpq345)

###  ì„œí‰ ì˜ˆì • ëª©ë¡ (ì½ëŠ” ì¤‘) 
- í•¨ê»˜ ìë¼ê¸° ì• ìì¼ë¡œ ê°€ëŠ” ê¸¸
- ê°ì²´ì§€í–¥ì˜ ì‚¬ì‹¤ê³¼ ì˜¤í•´

### ë…ì„œ ì˜ˆì • ëª©ë¡
#### ëª©ë¡ì€ ìš°ì„ ìˆœìœ„ íì´ë‹¤. ìƒë‹¨ì— ìˆë”ë¼ë„ ë” ì¤‘ìš”í•œ ì±…ì´ ë“¤ì–´ì˜¨ë‹¤ë©´ ìˆœìœ„ê°€ ë’¤ë¡œ ë°€ë¦´ ìˆ˜ ìˆë‹¤.
- ì˜¤ë¸Œì íŠ¸
- íŒŒì´ë¸Œ ë¼ì¸ìŠ¤ ì˜¤ë¸Œ ì½”ë“œ
- HTTP ì™„ë²½ ê°€ì´ë“œ
- ìë°”/ìŠ¤í”„ë§ ê°œë°œìë¥¼ ìœ„í•œ ì‹¤ìš©ì£¼ì˜ í”„ë¡œê·¸ë˜ë°
- ëª¨ë˜ ìë°” ì¸ ì•¡ì…˜
- ìë°” ì„±ëŠ¥ íŠœë‹ ì´ì•¼ê¸° 
- ìë°” ê°œë°œìì™€ ì‹œìŠ¤í…œ ìš´ì˜ìë¥¼ ìœ„í•œ íŠ¸ëŸ¬ë¸” ìŠˆíŒ… ì´ì•¼ê¸° / scouterë¥¼ í™œìš©í•œ ì‹œìŠ¤í…œ ì¥ì•  ì§„ë‹¨ ë° í•´ê²° ë…¸í•˜ìš° ìë°” íŠ¸ëŸ¬ë¸”ìŠˆíŒ…
- í—¤ë“œ í¼ìŠ¤íŠ¸ ì„œë¸”ë¦¿
- Hello Coding ê·¸ë¦¼ìœ¼ë¡œ ê°œë…ì„ ì´í•´í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜


## Extras ğŸ˜€
### 
### [ê²Œì„ê°œë°œ](https://www.acmicpc.net/problem/1516)
```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {

    public static void main(String[] args) {
        new Main().run();
    }

    private void run() {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            Input ip = readInput(br);
            Solution s = new Solution();
            System.out.println(s.solution(ip.costs, ip.graph));

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private Input readInput(BufferedReader br) throws IOException {
        int len = Integer.parseInt(br.readLine());
        int[] costs = new int[len + 1];
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < len + 1; i++) {
            graph.add(new ArrayList<>());
        }

        for (int i = 0; i < len; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine(), " ");
            int cost = Integer.parseInt(st.nextToken());
            costs[i + 1] = cost;

            while (st.hasMoreTokens()) {
                int value = Integer.parseInt(st.nextToken());
                if(value == -1) break;
                graph.get(value).add(i + 1);
            }
        }
        return new Input(costs, graph);
    }

    private static class Input {
        private final int[] costs;
        private final List<List<Integer>> graph;

        public Input(int[] costs, List<List<Integer>> graph) {
            this.costs = costs;
            this.graph = graph;
        }
    }
}

class Solution {

    public String solution(int[] costs, List<List<Integer>> graph) {
        int[] indegree = getIndegree(graph);
        int[] dp = Arrays.copyOfRange(costs, 0, costs.length);

        Queue<Integer> q = new ArrayDeque<>();
        for (int i = 1; i < indegree.length; i++) {
            if(indegree[i] == 0) q.offer(i);
        }

        while (!q.isEmpty()) {
            int cur = q.poll();

            for (Integer next : graph.get(cur)) {
                if (dp[next] < dp[cur] + costs[next]) {
                    dp[next] = dp[cur] + costs[next];
                }
                indegree[next]--;
                if(indegree[next] == 0) q.offer(next);
            }
        }

        return getAnswer(dp);
    }

    private int[] getIndegree(List<List<Integer>> graph) {
        int len = graph.size();
        int[] indegree = new int[len];
        for (int i = 1; i < len; i++) {
            List<Integer> node = graph.get(i);
            for (Integer next : node) {
                indegree[next]++;
            }
        }
        return indegree;
    }

    private String getAnswer(int[] dp) {
        StringBuilder answer = new StringBuilder();
        for (int i = 1; i < dp.length; i++) {
            answer.append(dp[i]).append("\n");
        }
        return answer.toString();
    }
}
```
### [ìŒì•…í”„ë¡œê·¸ë¨](https://www.acmicpc.net/problem/2623)
```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {

    public static void main(String[] args) {
        new Main().run();
    }

    private void run() {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            Solution s = new Solution();
            System.out.println(s.solution(readInput(br)));

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private List<List<Integer>> readInput(BufferedReader br) throws IOException {
        String[] tokens = br.readLine().split(" ");
        int numOfNodes = Integer.parseInt(tokens[0]);
        int repeat = Integer.parseInt(tokens[1]);

        List<List<Integer>> result = new ArrayList<>();
        for (int i = 0; i < numOfNodes + 1; i++) {
            result.add(new ArrayList<>());
        }

        for (int i = 0; i < repeat; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine(), " ");
            st.nextToken();
            int from = 0;
            int value = 0;
            while (st.hasMoreTokens()) {
                if (from == 0) {
                    from = Integer.parseInt(st.nextToken());
                    value = Integer.parseInt(st.nextToken());
                } else {
                    value = Integer.parseInt(st.nextToken());
                }
                result.get(from).add(value);
                from = value;
            }
        }
        return result;
    }
}

class Solution {

    public String solution(List<List<Integer>> graph) {
        StringBuilder answer = new StringBuilder();
        int[] indegree = getIndegree(graph);

        Queue<Integer> q = new ArrayDeque<>();
        for (int i = 1; i < indegree.length; i++) {
            if(indegree[i] == 0) q.offer(i);
        }

        int cnt = 0;
        while (!q.isEmpty()) {
            int cur = q.poll();
            cnt++;

            answer.append(cur).append("\n");

            for (Integer next : graph.get(cur)) {
                indegree[next]--;
                if(indegree[next] == 0) q.offer(next);
            }
        }

        if (cnt == graph.size() - 1) {
            return answer.toString();
        }
        return "0";
    }

    private int[] getIndegree(List<List<Integer>> graph) {
        int len = graph.size();
        int[] indegree = new int[len];

        for (int i = 1; i < len; i++) {
            for (Integer next : graph.get(i)) {
                indegree[next]++;
            }
        }
        return indegree;
    }
}
```
### [ë„¤íŠ¸ì›Œí¬ ì—°ê²°](https://www.acmicpc.net/problem/1922)
```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.StringTokenizer;

public class Main {

    public static void main(String[] args) {
        new Main().run();
    }

    private void run() {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            Input ip = readInput(br);
            Solution s = new Solution();
            System.out.println(s.solution(ip.numOfComputers, ip.wires));
            
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private Input readInput(BufferedReader br) throws IOException {
        int numOfComputers = Integer.parseInt(br.readLine());
        int numOfWires = Integer.parseInt(br.readLine());

        int[][] wires = new int[numOfWires][3];
        for (int i = 0; i < numOfWires; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine(), " ");
            int from = Integer.parseInt(st.nextToken());
            int to = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());
            wires[i][0] = from;
            wires[i][1] = to;
            wires[i][2] = cost;
        }
        return new Input(numOfComputers, wires);
    }

    private static class Input{
        private final int numOfComputers;
        private final int[][] wires;

        public Input(int numOfComputers, int[][] wires) {
            this.numOfComputers = numOfComputers;
            this.wires = wires;
        }
    }
}

class Solution {

    public int solution(int numOfComputers, int[][] wires) {
        Arrays.sort(wires, Comparator.comparing(a -> a[2]));
        int[] group = initGroup(numOfComputers);

        int cnt = 0;
        int sumOfCosts = 0;

        for (int[] wire : wires) {
            if(cnt == numOfComputers - 1) break;
            int from = wire[0];
            int to = wire[1];
            if(isSameGroup(group, from, to)) continue;

            connect(group, from, to);
            sumOfCosts += wire[2];
        }

        return sumOfCosts;
    }

    private int[] initGroup(int numOfComputers) {
        int[] result = new int[numOfComputers + 1];
        for (int i = 0; i < numOfComputers + 1; i++) {
            result[i] = i;
        }
        return result;
    }

    private boolean isSameGroup(int[] group, int target1, int target2) {
        return getGroup(group, target1) == getGroup(group, target2);
    }

    private int getGroup(int[] group, int target) {
        if(target != group[target]) group[target] = getGroup(group, group[target]);
        return group[target];
    }

    private void connect(int[] group, int target1, int target2) {
        int group1 = getGroup(group, target1);
        int group2 = getGroup(group, target2);
        group[Math.max(group1, group2)] = Math.min(group1, group2);
    }
}
```

