## 240825 회고 💬
공부만 하는데도 시간이 너무 빨리 가는 만 28살 백수... 백수 된 지도 3달 차가 다 돼간다. 🐷 어서 취업해야 할 텐데... 걱정만 하고 꾸준히 노는데 집중하고 있다. 우주의 블랙홀처럼 집구석에만 머무르며 자신의 질량을 꾸준히 불려 나간 8월의 넷 째 주를 되돌아본다. 

## Keep 👍
- 알고리즘 문제 풀이를 이번 주에도 7일 연속 해냈다. 240825 기준으로 316일 연속 풀이 중이다. 이번 주에도 실버 문제만 풀었다. 브론즈 문제를 350 문제 풀었는데, 브론즈 난이도 보다 실버 난이도 풀이 개수가 더 많았으면 좋겠다. 그래서 실버만 풀고 있다. 그래서 골드 문제는 몇 개 풀었냐고? 헤헤 40개 좀 넘게 풀었다. 실버 개수가 어느 정도 잡히면 골드에 도전해 보겠다. -> 개수에 집착하는 이상한 병이 있습니다. 😵
	- [라디오](https://www.acmicpc.net/problem/3135) 알고리즘 분류는 그리디로 돼있지만 그냥 BFS로 풀어버렸다. 그리디에 자신이 없기도 하고 탐색 문제를 엄청 많이 풀어놔서 이쪽으로만 풀이가 떠오른다. 다른 방법으로 풀라 한다면 솔직히 자신 없다 ㅋㅋㅋㅋ 🤣
	- [이름 궁합] (https://www.acmicpc.net/problem/15312) 처음에는 List 자료구조로 풀이 접근을 했다. 풀고나서 보니 더 최적화할 수 있을듯 해서 계속 깎고 깎다가 int 배열만 사용해서 풀이 돼도록 개선했다. 
	- [틱! 택! 토!] (https://www.acmicpc.net/problem/12759) 틱택토 게임을 시뮬레이트 하는 문제다. 누가 어디에 체크했지 입력으로 주어진다. 해당 입력대로 게임을 진행하고 누가 이겼는지 출력하면 된다. for문만 잘 쓰면 쉽게 해결할 수 있다.
	- 어느날 갑자기 떠오른 생각이다. 내가 어떤 문제를 풀어 놓고 복습한 경우가 있었나? 지금까지 몇 문제는 한두 번 정도 다시 푼 경우가 있긴 하지만 모든 문제를 복습하지는 않았다. 한번 풀어놓고 머리로 다 기억할 수 있다는 근본 없는 자신감 때문에 그런 듯하다. 그래서 9월부터는 하루에 알고리즘 문제를 2개씩 풀 계획이다. 1문제는 그날 풀어야 할 문제, 다른 1문제는 전달 그날에 풀었던 문제 복습 풀이다.
- `함께 자라기, 애자일로 가는 길` 을 계속 읽고 있다.
- 요즘 개인 프로젝트를 작업 중이다. 
	- 스프링 시큐리티로 JWT, OAuth2 구현하려고 했는데 실패했다. 일단 시큐리티에 대해 아는게 하나도 없으니 남의 코드를 베껴 구현하더라도 에러가 계속 발생했다. 그리고 더 문제는 그 에러를 해결할 수가 없었다. 떠오른 방법은 하나... 일단 미뤄두고 다른 부분 구현하기다. 🤪 
	- 기본 엔티티 구현 작업을 하면서 테스트 코드를 작성하려고 했다. 쉬운 일이 하나도 없더라... 😥 서비스, 레포 테스트 코드는 작성할만 했는데 컨트롤러 테스트 코드가 생각보다 까다로웠다. 일단은 Mock 사용 방법을 몰라서 알음알음 검색해가며 시도해 봤지만... 자꾸 오류 나서 그냥 다 지워버리고 구현부터 시도했다. 그래서 지금은 일단 레이어를 모두 작업해 놓고 http 요청으로 응답 값을 눈으로 확인하는 방식으로 작업 중이다. Mock 공부 최대한 빨리 시작해서 컨트롤러 테스트 코드 작업을 다시 도전해 보겠다. 
	- 글로벌 응답 클래스를 작업했다.
	- 글로벌 예외 응답 클래스를 작업했다.
	- 프로젝트 예외 클래스를 작업했다. 글로벌 예외는 RuntimeException 을 슈퍼클래스로 하는 서브 클래스다.
	- 프로젝트 예외 클래스를 처리하는 핸들러를 작업했다. `@RestControllerAdvice` 를 사용한다. 
	- 기본 엔티티 CRUD를 작업 했다. 

## Problem 🤢

## Try 🧚
- 함께 자라기 마무리하기
- 알고리즘 문제 풀이 
- 토이 프로젝트 테스트 코드 작성하기
	- 컨트롤러
	- 서비스
	- 레포

## 독서 목록

### 서평 완료 목록
- [혼자 공부하는 컴퓨터 구조 + 운영체제](https://github.com/kimregular/DAILY_STUDY/blob/main/독서/1.%20서평/01.%20혼자%20공부하는%20컴퓨터%20구조%20%2B%20운영체제%20를%20읽고%20📝.md)

###  서평 예정 목록 (읽는 중)
- 프로그래머의 길, 멘토에게 묻다
- 함께 자라기 애자일로 가는 길

### 독서 예정 목록
#### 목록은 우선순위 큐이다. 상단에 있더라도 더 중요한 책이 들어온다면 순위가 뒤로 밀릴 수 있다.
- 객체지향의 사실과 오해
- 오브젝트
- 파이브 라인스 오브 코드
- HTTP 완벽 가이드
- 자바/스프링 개발자를 위한 실용주의 프로그래밍
- 모던 자바 인 액션
- 자바 성능 튜닝 이야기 
- 자바 개발자와 시스템 운영자를 위한 트러블 슈팅 이야기 / scouter를 활용한 시스템 장애 진단 및 해결 노하우 자바 트러블슈팅
- 헤드 퍼스트 서블릿
- Hello Coding 그림으로 개념을 이해하는 알고리즘


## Extras 😀
### [라디오](https://www.acmicpc.net/problem/3135)
```java

import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            Input ip = getInput(br);
            Solution s = new Solution();
            System.out.println(s.solution(ip.start, ip.target, ip.savedPosition));

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static Input getInput(BufferedReader br) throws IOException {
        String[] tokens = br.readLine().split(" ");
        int start = Integer.parseInt(tokens[0]);
        int target = Integer.parseInt(tokens[1]);

        int len = Integer.parseInt(br.readLine());
        int[] savedPosition = new int[len];
        for (int i = 0; i < savedPosition.length; i++) {
            savedPosition[i] = Integer.parseInt(br.readLine());
        }
        return new Input(start, target, savedPosition);
    }

    private static class Input {

        int start;
        int target;
        int[] savedPosition;

        public Input(int start, int target, int[] savedPosition) {
            this.start = start;
            this.target = target;
            this.savedPosition = savedPosition;
        }
    }
}

class Solution {

    public int solution(int start, int target, int[] savedPosition) {
        Calculator c = new Calculator(start, target, savedPosition);
        return c.getResult();
    }
}

class Calculator {

    int start;
    int target;
    boolean[] isChecked;
    Queue<Click> q;

    public Calculator(int start, int target, int[] savedPosition) {
        this.start = start;
        this.target = target;
        this.isChecked = new boolean[1_000];
        this.q = new ArrayDeque<>();
        q.offer(new Click(start, 0));
        isChecked[start] = true;
        for (int position : savedPosition) {
            isChecked[position] = true;
            q.offer(new Click(position, 1));
        }
    }

    public int getResult() {
        while (!q.isEmpty()) {
            Click cur = q.poll();

            if(cur.position == target) return cur.click;
            else move(cur);
        }
        return -1;
    }

    private void move(Click cur) {
        int[] nextPositions = {cur.position + 1, cur.position - 1};

        for (int nextPosition : nextPositions) {
            if (isValid(nextPosition) && !isChecked[nextPosition]) {
                isChecked[nextPosition] = true;
                q.offer(new Click(nextPosition, cur.click + 1));
            }
        }
    }

    private boolean isValid(int position) {
        return 0 <= position && position < 1000;
    }


    private static class Click {

        int position;
        int click;

        public Click(int position, int click) {
            this.position = position;
            this.click = click;
        }
    }
}
```
### [이름 궁합] (https://www.acmicpc.net/problem/15312)
```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            Solution s = new Solution();
            System.out.println(s.solution(getInput(br), getInput(br)));

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static char[] getInput(BufferedReader br) throws IOException {
        return br.readLine().toCharArray();
    }
}

class Solution {

    int[] scores = {3, 2, 1, 2, 3, 3, 2, 3, 3, 2, 2, 1, 2, 2, 1, 2, 2, 2, 1, 2, 1, 1, 1, 2, 2, 1};

    public String solution(char[] his, char[] her) {
        return getAnswer(process(getScoredName(his, her)));
    }

    private int[] getScoredName(char[] his, char[] her) {
        int[] result = new int[his.length + her.length];

        for (int i = 0; i < his.length; i++) {
            result[2 * i] = scores[his[i] - 'A'];
            result[2 * i + 1] = scores[her[i] - 'A'];
        }

        return result;
    }

    private int[] process(int[] nameScore) {
        int repeat = nameScore.length;
        while (repeat > 2) {
            for (int i = 0; i < repeat - 1; i++) {
                nameScore[i] = (nameScore[i] + nameScore[i + 1]) % 10;
            }
            repeat--;
        }
        return nameScore;
    }

    private String getAnswer(int[] nameScore) {
        return "" + nameScore[0] + nameScore[1];
    }
}

```
### [틱! 택! 토!] (https://www.acmicpc.net/problem/12759)
```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            Input ip = getInput(br);
            Solution s = new Solution();
            System.out.println(s.solution(ip.startPlayer, ip.draws));

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static Input getInput(BufferedReader br) throws IOException {
        int startPlayer = Integer.parseInt(br.readLine());

        int[][] draws = new int[9][2];
        for (int i = 0; i < draws.length; i++) {
            String[] tokens = br.readLine().split(" ");
            int x = Integer.parseInt(tokens[0]);
            int y = Integer.parseInt(tokens[1]);
            draws[i][0] = x;
            draws[i][1] = y;
        }

        return new Input(startPlayer, draws);
    }

    private static class Input {

        int startPlayer;
        int[][] draws;

        public Input(int startPlayer, int[][] draws) {
            this.startPlayer = startPlayer;
            this.draws = draws;
        }
    }
}

class Solution {

    public int solution(int startPlayer, int[][] draws) {
        Game g = new Game(startPlayer);
        for (int[] draw : draws) {
            g.check(draw);
            if(g.isDone()) return g.getWinner();
        }
        return 0;
    }
}

class Game {

    final int PLAYER_ONE = 1;
    final int PLAYER_TWO = 2;

    int prevPlayer;
    int[][] field;
    int winner = 0;

    public Game(int startPlayer) {
        this.prevPlayer = startPlayer == PLAYER_ONE ? PLAYER_TWO : PLAYER_ONE;
        this.field = new int[4][4];
    }

    public void check(int[] draw) {
        int x = draw[0];
        int y = draw[1];
        int player = getPlayer();
        field[x][y] = player;
        prevPlayer = player;
    }

    public boolean isDone() {
        return isLineDone() || isDiagonalDone();
    }

    public int getWinner() {
        return winner;
    }

    private boolean isLineDone() {
        for (int i = 1; i < field.length; i++) {
            int[] horizontalChecker = new int[3];
            int[] verticalChecker = new int[3];
            for (int j = 1; j < field.length; j++) {
                horizontalChecker[field[i][j]]++;
                verticalChecker[field[j][i]]++;
            }
            if(isWinnerExist(horizontalChecker)) return true;
            if(isWinnerExist(verticalChecker)) return true;
        }
        return false;
    }

    private boolean isDiagonalDone() {
        int[] checker = new int[3];
        int[] reversedChecker = new int[3];
        for (int i = 1; i < field.length; i++) {
            checker[field[i][i]]++;
            reversedChecker[field[i][4 - i]]++;
        }
        return isWinnerExist(checker) || isWinnerExist(reversedChecker);
    }

    private boolean isWinnerExist(int[] checker) {
        for (int i = 1; i < 3; i++) {
            if (checker[i] == 3) {
                winner = i;
                return true;
            }
        }
        return false;
    }

    private int getPlayer() {
        return prevPlayer == PLAYER_ONE ? PLAYER_TWO : PLAYER_ONE;
    }
}
```
