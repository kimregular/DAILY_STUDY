## 241020 íšŒê³  ğŸ’¬
ê¸¸ê³  ê¸¸ì—ˆë˜ ë²ˆì•„ì›ƒì´ ëë‚˜ê³  ë“œë””ì–´ ê³µë¶€í•  ë§˜ì´ ì ì  ìƒê²¨ê°€ê³  ìˆë‹¤. ì´ì œê¹Œì§€ ì§‘ì—ì„œë§Œ ê³µë¶€í•˜ë ¤ë˜ ê³ ì§‘ì„ ì ì‹œ ë‚´ë ¤ë†“ê³  ìŠ¤í„°ë””ì¹´í˜, ì¹´í˜ ì´ê³³ì €ê³³ì„ ë‚˜ëŒì•„ë‹¤ë‹ˆë©° ì£¼ë³€ í™˜ê²½ì„ ë°”ê¿”ë³´ì•˜ë‹¤. ê²°ê³¼ëŠ” ëŒ€ì„±ê³µì´ë‹¤. í™˜ê²½ì´ ë³€í•˜ë‹ˆ ê·¸ê°„ì˜ ë²ˆì•„ì›ƒì´ ì‚¬ë¼ì§€ê³  ì§‘ì¤‘ë ¥ì´ ì•„ì£¼ ì¢‹ì•„ì¡Œë‹¤. ë•ë¶„ì— í‰ê·  ìˆœê³µì‹œê°„ 7ì‹œê°„ì„ ë‹¬ì„±í–ˆë‹¤. ê°€ë”ì€ ì§€ë‚˜ê°€ëŠ” ì‚¬ëŒë“¤ êµ¬ê²½í•˜ëŠë¼ ì•ì— ì§‘ì¤‘ ëª» í•  ì ë„ ìˆì—ˆë˜ 10ì›” ì…‹ì§¸ ì£¼ë¥¼ ë˜ëŒì•„ë³¸ë‹¤.

## Keep ğŸ‘
- ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´ë¥¼ 7ì¼ ì—°ì†ìœ¼ë¡œ ì´ë²ˆ ì£¼ì—ë„ í•´ëƒˆë‹¤. 241020 ê¸°ì¤€ìœ¼ë¡œ ì—°ì† 372ì¼ í’€ì´ ì¤‘ì´ë‹¤. ì´ë²ˆ ì£¼ì—ëŠ” ê·¸ê°„ ë„ˆë¬´ ì‰¬ìš´ ë¬¸ì œë“¤ë§Œ í‘¼ë“¯ í•´ì„œ ê³¨ë“œ ë¬¸ì œì— ë„ì „í•´ë´¤ë‹¤.
	- [ìƒë²” ë¹Œë”©](https://www.acmicpc.net/problem/6593) 3ì°¨ì› BFS ë¬¸ì œë‹¤. BFS ë¬¸ì œ ì¤‘ ìœ ëª…í•œ í† ë§ˆí†  ë¬¸ì œë¥¼ í’€ì—ˆë‹¤ë©´ ì‰½ê²Œ í’€ ìˆ˜ ìˆëŠ” ë¬¸ì œì´ë‹¤. ì‚¬ì‹¤ ë¡œì§ ë¶€ë¶„ì´ ì•„ë‹ˆë¼ ì¸í’‹ ë°›ëŠ” ë°©ì‹ì„ ì–´ë–»ê²Œ êµ¬í˜„í• ì§€ê°€ í’€ì´ ì¤‘ì— ì œì¼ ì–´ë ¤ì› ë˜ ë¶€ë¶„ì´ì—ˆë‹¤.
	- [ë¶ˆ](https://www.acmicpc.net/problem/5427) ìœ ëª…í•œ 2ì¤‘ BFS ë¬¸ì œë‹¤. 2ì¤‘ì´ë¼ê³  í•˜ì§€ë§Œ í¬ê²Œ ì–´ë µì§„ ì•Šë‹¤. ë¶ˆì´ í¼ì§€ëŠ” ì‹œë®¬ë ˆì´ì…˜ì„ ë¨¼ì € í•˜ê³ ë‚˜ì„œ ìœ„ì¹˜ë§ˆë‹¤ ë¶ˆì´ ì–¸ì œ ë„ë‹¬í•˜ëŠ”ì§€ ì €ì¥í•œë‹¤. ê·¸ í›„ ì‚¬ëŒì„ ì‹œë®¬ë ˆì´ì…˜ í•˜ë©´ì„œ í•´ë‹¹ ìœ„ì¹˜ì— ë¶ˆë³´ë‹¤ ì‚¬ëŒì´ ë¨¼ì € ì˜¬ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•˜ë©´ ëœë‹¤.
- ìš”ì¦˜ì€ ë…¸ë“œ + ìµìŠ¤í”„ë ˆìŠ¤ ê³µë¶€ë¥¼ í•˜ê³  ìˆë‹¤. ìµœê·¼(ì´ë¼ê³¤ í•˜ì§€ë§Œ ë²ˆì•„ì›ƒìœ¼ë¡œ ë¯¸ì ì§€ê·¼ í–ˆë˜) ìŠ¤í”„ë§ ê³µë¶€ë§Œ í–ˆë”ë‹ˆ ë­”ê°€ ë‹¤ë¥¸ ì›¹ ê¸°ìˆ ë„ ê³µë¶€í•´ ë³´ê³  ì‹¶ì—ˆë‹¤. ê·¸ë˜ì„œ í”„ë¡ íŠ¸ ì„œë²„ë„ ê°™ì´ ì‘ì—… í• ê²¸ ì‹œì‘í–ˆë‹¤. 
	- ê¸°ì´ˆì ì¸ í”„ë¡œì íŠ¸ êµ¬ì„± ë°©ë²•
	- ë¼ìš°í„° êµ¬ì„±
	- ë¡œê·¸ì¸(ì„¸ì…˜)
	- ê¹ƒí—ˆë¸Œ OAuth
	- í…œí”Œë¦¿ ì—”ì§„(Pug)
	- mongoDB & mongoose
- ê°ì²´ì§€í–¥ì˜ ì‚¬ì‹¤ê³¼ ì˜¤í•´ë¥¼ ê³„ì† ì½ê³  ìˆë‹¤. ì´ë²ˆ ì£¼ì—ëŠ” ë…ì„œ ì‹œê°„ì´ ê¸¸ì§€ëŠ” ì•Šì•˜ë‹¤. ë°˜ì„±í•œë‹¤.


## Try ğŸ§š
- ê°ì²´ì§€í–¥ì˜ ì‚¬ì‹¤ê³¼ ì˜¤í•´ ë§ˆë¬´ë¦¬í•˜ê¸°
- ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´ 
- í”„ë¡ íŠ¸ ì„œë²„ êµ¬ì¶•
	- webpack
	- scss
	- file 
- ë°±ì—”ë“œ ì„œë²„ ê°œë°œ
	- ì¸ì¦, ì¸ê°€
	- mvp ì œì‘

## ë…ì„œ ëª©ë¡

### ì„œí‰ ì™„ë£Œ ëª©ë¡
- [í˜¼ì ê³µë¶€í•˜ëŠ” ì»´í“¨í„° êµ¬ì¡° + ìš´ì˜ì²´ì œ](https://velog.io/@regular_jk_kim/í˜¼ì-ê³µë¶€í•˜ëŠ”-ì»´í“¨í„°-êµ¬ì¡°-ìš´ì˜ì²´ì œ-ë¥¼-ì½ê³ )
- [í”„ë¡œê·¸ë˜ë¨¸ì˜ ê¸¸, ë©˜í† ì—ê²Œ ë¬»ë‹¤](https://velog.io/@regular_jk_kim/í”„ë¡œê·¸ë˜ë¨¸ì˜-ê¸¸-ë©˜í† ì—ê²Œ-ë¬»ë‹¤-ë¥¼-ì½ê³ -24jpq345)

###  ì„œí‰ ì˜ˆì • ëª©ë¡ (ì½ëŠ” ì¤‘) 
- í•¨ê»˜ ìë¼ê¸° ì• ìì¼ë¡œ ê°€ëŠ” ê¸¸
- ê°ì²´ì§€í–¥ì˜ ì‚¬ì‹¤ê³¼ ì˜¤í•´

### ë…ì„œ ì˜ˆì • ëª©ë¡
#### ëª©ë¡ì€ ìš°ì„ ìˆœìœ„ íì´ë‹¤. ìƒë‹¨ì— ìˆë”ë¼ë„ ë” ì¤‘ìš”í•œ ì±…ì´ ë“¤ì–´ì˜¨ë‹¤ë©´ ìˆœìœ„ê°€ ë’¤ë¡œ ë°€ë¦´ ìˆ˜ ìˆë‹¤.
- ì˜¤ë¸Œì íŠ¸
- íŒŒì´ë¸Œ ë¼ì¸ìŠ¤ ì˜¤ë¸Œ ì½”ë“œ
- HTTP ì™„ë²½ ê°€ì´ë“œ
- ìë°”/ìŠ¤í”„ë§ ê°œë°œìë¥¼ ìœ„í•œ ì‹¤ìš©ì£¼ì˜ í”„ë¡œê·¸ë˜ë°
- ëª¨ë˜ ìë°” ì¸ ì•¡ì…˜
- ìë°” ì„±ëŠ¥ íŠœë‹ ì´ì•¼ê¸° 
- ìë°” ê°œë°œìì™€ ì‹œìŠ¤í…œ ìš´ì˜ìë¥¼ ìœ„í•œ íŠ¸ëŸ¬ë¸” ìŠˆíŒ… ì´ì•¼ê¸° / scouterë¥¼ í™œìš©í•œ ì‹œìŠ¤í…œ ì¥ì•  ì§„ë‹¨ ë° í•´ê²° ë…¸í•˜ìš° ìë°” íŠ¸ëŸ¬ë¸”ìŠˆíŒ…
- í—¤ë“œ í¼ìŠ¤íŠ¸ ì„œë¸”ë¦¿
- Hello Coding ê·¸ë¦¼ìœ¼ë¡œ ê°œë…ì„ ì´í•´í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜

## Extras ğŸ˜€
### [ìƒë²” ë¹Œë”©](https://www.acmicpc.net/problem/6593) 
```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            Solution s = new Solution();
            System.out.println(s.solution(readInput(br)));

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static List<String[][][]> readInput(BufferedReader br) throws IOException {
        List<String[][][]> result = new ArrayList<>();

        int idx = 0;
        while (true) {
            StringTokenizer st = new StringTokenizer(br.readLine(), " ");
            int floors = Integer.parseInt(st.nextToken());
            int x = Integer.parseInt(st.nextToken());
            int y = Integer.parseInt(st.nextToken());

            if(floors == 0 && x == 0 && y == 0) break;

            result.add(new String[floors][x][y]);
            for (int i = 0; i < floors; i++) {
                for (int j = 0; j < x; j++) {
                    result.get(idx)[i][j] = br.readLine().split("");
                }
                br.readLine();
            }
            idx++;
        }
        return result;
    }
}

class Solution {

    public String solution(List<String[][][]> testCases) {
        StringBuilder answer = new StringBuilder();
        for (String[][][] testCase : testCases) {
            Calculator c = new Calculator(testCase);
            answer.append(c.getResult()).append("\n");
        }
        return answer.toString();
    }
}

class Calculator {

    private static final int[][] DIRECTIONS = {{1, 0, 0}, {-1, 0, 0}, {0, 1, 0}, {0, -1, 0}, {0, 0, -1}, {0, 0, 1}};

    private final String[][][] map;
    private final boolean[][][] isVisited;
    private int[] startPoint;
    private int[] endPoint;
    private int time = 0;

    public Calculator(String[][][] map) {
        this.map = map;
        this.isVisited = new boolean[map.length][map[0].length][map[0][0].length];

        int floors = map.length;
        int x = map[0].length;
        int y = map[0][0].length;

        for (int i = 0; i < floors; i++) {
            for (int j = 0; j < x; j++) {
                for (int k = 0; k < y; k++) {
                    if(map[i][j][k].equals("S")) startPoint = new int[]{i, j, k};
                    if(map[i][j][k].equals("E")) endPoint = new int[]{i, j, k};
                    if(startPoint != null && endPoint != null) return;
                }
            }
        }
    }

    public String getResult() {
        simulateEscape();
        if(isFail()) return "Trapped!";
        return "Escaped in " + time + " minute(s).";
    }

    private void simulateEscape() {
        Queue<Location> q = new ArrayDeque<>();
        Location startLocation = new Location(startPoint[0], startPoint[1], startPoint[2], 0);
        q.offer(startLocation);
        visit(startLocation);

        while (!q.isEmpty()) {
            Location cur = q.poll();

            if (cur.isTargetLocation(endPoint)) {
                this.time = cur.getTime();
                return;
            }

            for (int[] direction : DIRECTIONS) {
                int nfloor = cur.getFloor() + direction[0];
                int nx = cur.getX() + direction[1];
                int ny = cur.getY() + direction[2];

                if (isWithinBuilding(nfloor, nx, ny) && isReachable(nfloor, nx, ny) && !isVisited[nfloor][nx][ny]) {
                    Location nextLocation = new Location(nfloor, nx, ny, cur.getTime() + 1);
                    visit(nextLocation);
                    q.offer(nextLocation);
                }
            }
        }
    }

    private void visit(Location location) {
        int floor = location.getFloor();
        int x = location.getX();
        int y = location.getY();
        isVisited[floor][x][y] = true;
    }

    private boolean isFail() {
        return time == 0;
    }

    private boolean isWithinBuilding(int z, int x, int y) {
        return 0 <= z && z < map.length && 0 <= x && x < map[z].length && 0 <= y && y < map[z][x].length;
    }

    private boolean isReachable(int z, int x, int y) {
        return map[z][x][y].equals(".") || map[z][x][y].equals("E");
    }

    private static class Location {

        private final int floor;
        private final int x;
        private final int y;
        private final int time;

        public Location(int floor, int x, int y, int time) {
            this.floor = floor;
            this.x = x;
            this.y = y;
            this.time = time;
        }

        public boolean isTargetLocation(int[] targetPoint) {
            return floor == targetPoint[0] && x == targetPoint[1] && y == targetPoint[2];
        }

        public int getFloor() {
            return floor;
        }

        public int getX() {
            return x;
        }

        public int getY() {
            return y;
        }

        public int getTime() {
            return time;
        }
    }
}
```
### [ë¶ˆ](https://www.acmicpc.net/problem/5427)
```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            Solution s = new Solution();
            System.out.println(s.solution(readInput(br)));

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static List<char[][]> readInput(BufferedReader br) throws IOException {
        int len = Integer.parseInt(br.readLine());
        List<char[][]> result = new ArrayList<>();

        for (int i = 0; i < len; i++) {
            String[] tokens = br.readLine().split(" ");
            int x = Integer.parseInt(tokens[1]);
            int y = Integer.parseInt(tokens[0]);
            char[][] field = new char[x][y];
            for (int j = 0; j < x; j++) {
                field[j] = br.readLine().toCharArray();
            }
            result.add(field);
        }
        return result;
    }
}

class Solution {

    public String solution(List<char[][]> testCases) {
        StringBuilder answer = new StringBuilder();
        for (char[][] testCase : testCases) {
            EscapeSimulator es = new EscapeSimulator(testCase);
            answer.append(es.getResult()).append("\n");
        }
        return answer.toString();
    }
}

class EscapeSimulator {

    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};

    private final char[][] building;
    private final boolean[][] isVisited;
    private final int[][] fireBoard;

    private final Queue<int[]> humanLocation = new ArrayDeque<>();
    private final Queue<int[]> fireLocation = new ArrayDeque<>();

    private int result = Integer.MAX_VALUE;

    public EscapeSimulator(char[][] building) {
        this.building = building;
        this.isVisited = new boolean[building.length][building[0].length];
        this.fireBoard = new int[building.length][building[0].length];
        for (int[] ints : fireBoard) {
            Arrays.fill(ints, -1);
        }
    }

    public String getResult() {
        simulateEscape(init());
        if(result == Integer.MAX_VALUE) return "IMPOSSIBLE";
        return result + "";
    }

    private int[] init() {
        int x = building.length;
        int y = building[0].length;

        int[] startPosition = new int[3];
        for (int i = 0; i < x; i++) {
            for (int j = 0; j < y; j++) {
                if (building[i][j] == '@') {
                    isVisited[i][j] = true;
                    startPosition = new int[]{i, j, 0};
                } else if (building[i][j] == '*') {
                    fireBoard[i][j] = 0;
                    fireLocation.add(new int[]{i, j, 0});
                }
            }
        }
        return startPosition;
    }

    private void simulateEscape(int[] startPosition) {
        fireSimulate();
        humanSimulate(startPosition);
    }

    private void fireSimulate() {
        while (!fireLocation.isEmpty()) {
            int[] cur = fireLocation.poll();
            int x = cur[0];
            int y = cur[1];
            int time = cur[2];

            for (int[] direction : DIRECTIONS) {
                int nx = x + direction[0];
                int ny = y + direction[1];
                int ntime = time + 1;
                if (isWithinBuilding(nx, ny) && (building[nx][ny] == '.' || building[nx][ny] == '@') && fireBoard[nx][ny] == -1) {
                    fireBoard[nx][ny] = ntime;
                    fireLocation.offer(new int[]{nx, ny, ntime});
                }
            }
        }
    }

    private void humanSimulate(int[] startPosition) {
        int startX = startPosition[0];
        int startY = startPosition[1];
        humanLocation.offer(startPosition);
        isVisited[startX][startY] = true;

        while (!humanLocation.isEmpty()) {
            int[] cur = humanLocation.poll();
            int x = cur[0];
            int y = cur[1];
            int time = cur[2];

            for (int[] direction : DIRECTIONS) {
                int nx = x + direction[0];
                int ny = y + direction[1];
                int ntime = time + 1;

                if (isOutOfBuilding(nx, ny)) {
                    result = Math.min(result, ntime);
                    return;
                }

                if (isWithinBuilding(nx, ny) && building[nx][ny] == '.' && (fireBoard[nx][ny] > ntime || fireBoard[nx][ny] == -1) && !isVisited[nx][ny]) {
                    isVisited[nx][ny] = true;
                    humanLocation.offer(new int[]{nx, ny, ntime});
                }
            }
        }
    }

    private boolean isOutOfBuilding(int x, int y) {
        return x < 0 || x >= building.length || y < 0 || y >= building[x].length;
    }

    private boolean isWithinBuilding(int x, int y) {
        return 0 <= x && x < building.length && 0 <= y && y < building[x].length;
    }
}


```
