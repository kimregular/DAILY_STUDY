## 240728 íšŒê³  ğŸ’¬
ì ì‹œë¼ë„ ë°–ì— ìˆìœ¼ë©´ ìœ¡ìˆ˜ê°€ ì¤„ì¤„ íë¥´ëŠ” ë‚ ì”¨ì— ì§€ì³ ì§‘ ë°–ìœ¼ë¡œ ë‚˜ê°ˆ ìƒê°ì¡°ì°¨ ì•ˆ í•˜ëŠ” 1ì¸. ì—ì–´ì»¨ ì‹œì›í•˜ê²Œ ë§ì¶°ë†“ê³  ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œë¥¼ í’€ê³  ìˆë…¸ë¼ë©´ ì´ë³´ë‹¤ í–‰ë³µí•  ìˆ˜ê°€ ìˆì„ê¹Œ? ì ì  ì´ì„±ì„ ë†“ê²Œ ë˜ëŠ” 7ì›”ì˜ ë§ˆì§€ë§‰ ì£¼ë¥¼ ë˜ëŒì•„ë³¸ë‹¤.

## Keep ğŸ‘
- ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´ë¥¼ 7ì¼ ì—°ì† í•´ëƒˆë‹¤. 288ì¼ì§¸ ì—°ì†ìœ¼ë¡œ í’€ì´í•˜ê³  ìˆë‹¤. ğŸ¥³
	- [ì¹˜í‚¨ ë°°ë‹¬] (https://www.acmicpc.net/problem/15686) ë°±íŠ¸ë˜í‚¹ ë¬¸ì œë‹¤. ê±°ë¦¬ êµ¬í•˜ëŠ” ì‹ì„ ì•Œë ¤ì£¼ê¸° ë•Œë¬¸ì— BFS ë¡œì§ì„ êµ¬í˜„í•˜ì§€ ì•Šì•„ë„ ëœë‹¤. ì§€ë„ìƒì— ìˆëŠ” ì¹˜í‚¨ ê°€ê²Œ n ê°œ ì¤‘ì—ì„œ rê°œë¥¼ ì •í•´ì„œ í•´ë‹¹ ê°€ê²Œë“¤ì˜ ì´ ê±°ë¦¬ë¥¼ ê³„ì‚°í•˜ë©´ ë˜ëŠ” ë¬¸ì œë‹¤.
	- [ê°€ìš´ë°ë¥¼ ë§í•´ìš”] (https://www.acmicpc.net/problem/1655) ìµœì†Œí™ê³¼ ìµœëŒ€í™ì„ ê°™ì´ ì‚¬ìš©í•˜ëŠ” ë¬¸ì œë‹¤. í•´ë‹¹ ì•„ì´ë””ì–´ë§Œ ë– ì˜¬ë¦¬ë©´ ì‰½ê²Œ í’€ ìˆ˜ ìˆëŠ” ë¬¸ì œë‹¤.
	- [ì–‘ì¹˜ê¸° ê¿] (https://www.acmicpc.net/problem/3187) ì˜¤ëœë§Œì— BFS ë¬¸ì œ í’€ì´ë¥¼ í–ˆë‹¤. ì´ì „ì— í•œì°¸ì„ ë¶™ì¡ê³  ìˆë˜ ìœ í˜•ì´ì—¬ì„œ ì˜¤ëœë§Œì— í’€ì´í•´ë„ ì†ì´ ì €ì ˆë¡œ ì›€ì§ì˜€ë‹¤. ì‚¬ì‹¤ DFSë¡œ í’€ì–´ë„ ëœë‹¤. ë­ë“  ìƒê´€ì—†ìœ¼ë‹ˆ ê¸°ë³¸ê¸°ë§Œ ìˆë‹¤ë©´ ì‰½ê²Œ í’€ ìˆ˜ ìˆëŠ” ë¬¸ì œë‹¤.
- í•¨ê»˜ ìë¼ê¸°ë¥¼ ê³„ì† ì½ê³  ìˆë‹¤.
- ì´ë²ˆ ì£¼ì—ëŠ” ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´ì— ì¬ë¯¸ê°€ ë“¤ë ¤ì„œ ìŠ¤í”„ë§ ê³µë¶€ëŠ” ëª»í–ˆë‹¤.

## Problem ğŸ¤¢

## Try ğŸ§š
- í•¨ê»˜ ìë¼ê¸° ë§ˆë¬´ë¦¬í•˜ê¸°
- ìµœì†Œì‹ ì¥íŠ¸ë¦¬ ê³µë¶€í•˜ê¸°
	- ìœ ë‹ˆì˜¨íŒŒì¸ë“œ
	- í”„ë¦¼
- ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´ 

## Extras ğŸ˜€
### [ì¹˜í‚¨ ë°°ë‹¬] (https://www.acmicpc.net/problem/15686)
```java

import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            Input ip = getInput(br);
            Solution s = new Solution();
            System.out.println(s.solution(ip.board, ip.target));

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static Input getInput(BufferedReader br) throws IOException {
        int[] tokens = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        int len = tokens[0];
        int target = tokens[1];

        int[][] board = new int[len][len];
        for (int i = 0; i < board.length; i++) {
            board[i] = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        }

        return new Input(target, board);
    }

    private static class Input {

        int target;
        int[][] board;

        public Input(int target, int[][] board) {
            this.target = target;
            this.board = board;
        }
    }
}

class Solution {

    public int solution(int[][] board, int target) {
        Calculator c = new Calculator(board, target);
        return c.getResult();
    }
}

class Calculator {

    int[][] board;
    int target;
    int[] selectedChickens;
    int result = Integer.MAX_VALUE;
    List<Point> houses = new ArrayList<>();
    List<Point> chickens = new ArrayList<>();

    public Calculator(int[][] board, int target) {
        this.board = board;
        this.target = target;
        this.selectedChickens = new int[target];
    }

    public int getResult() {
        init();
        select(0, 0);
        return result;
    }

    private void init() {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                if(board[i][j] == 1) houses.add(new Point(i, j));
                else if (board[i][j] == 2) chickens.add(new Point(i, j));
            }
        }
    }

    public void select(int numOfSelected, int shopNum) {
        if (numOfSelected == target) {
            calc();
        } else {
            for (int i = shopNum; i < chickens.size(); i++) {
                selectedChickens[numOfSelected] = i;
                select(numOfSelected + 1, i + 1);
            }
        }
    }

    private void calc() {
        int sum = 0;
        for (Point house : houses) {
            int chickenDistance = Integer.MAX_VALUE;
            for (int i : selectedChickens) {
                Point selectedChicken = chickens.get(i);
                int distance = Math.abs(house.x - selectedChicken.x) + Math.abs(house.y - selectedChicken.y);
                chickenDistance = Math.min(chickenDistance, distance);
            }
            sum += chickenDistance;
        }
        result = Math.min(result, sum);
    }

    private static class Point {
        int x, y;

        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
}
```

### [ê°€ìš´ë°ë¥¼ ë§í•´ìš”] (https://www.acmicpc.net/problem/1655)
```java

import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            Solution s = new Solution();
            System.out.println(s.solution(getInput(br)));

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static int[] getInput(BufferedReader br) throws IOException {
        int len = Integer.parseInt(br.readLine());
        int[] result = new int[len];
        for (int i = 0; i < result.length; i++) {
            result[i] = Integer.parseInt(br.readLine());
        }
        return result;
    }
}

class Solution {

    MidHeap mh = new MidHeap();

    public String solution(int[] nums) {

        StringBuilder result = new StringBuilder();
        for(int num : nums){
            mh.add(num);
            result.append(mh.getMidNum()).append("\n");
        }

        return result.toString();
    }
}

class MidHeap {

    PriorityQueue<Integer> maxQ = new PriorityQueue<>(Collections.reverseOrder());
    PriorityQueue<Integer> minQ = new PriorityQueue<>();

    public void add(int num) {
        if (maxQ.size() >= minQ.size()) {
            maxQ.add(num);
            minQ.add(maxQ.poll());
        } else {
            minQ.add(num);
            maxQ.add(minQ.poll());
        }
    }

    public int getMidNum() {
        if(maxQ.isEmpty() || maxQ.size() < minQ.size()) return minQ.peek();
        return maxQ.peek();
    }
}
```

### [ì–‘ì¹˜ê¸° ê¿] (https://www.acmicpc.net/problem/3187)
```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.Queue;

public class Main {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            Solution s = new Solution();
            System.out.println(s.solution(getInput(br)));

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static String[][] getInput(BufferedReader br) throws IOException {
        String[] dimensions = br.readLine().split(" ");
        int x = Integer.parseInt(dimensions[0]);
        int y = Integer.parseInt(dimensions[1]);
        String[][] field = new String[x][y];

        for (int i = 0; i < field.length; i++) {
            field[i] = br.readLine().split("");
        }

        return field;
    }
}

class Solution {

    public String solution(String[][] field) {
        SeekAndHide sh = new SeekAndHide(field);
        return sh.getResult();
    }
}

class SeekAndHide {

    String[][] field;
    boolean[][] isChecked;
    int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int sheepSurvived = 0;
    int wolvesSurvived = 0;

    public SeekAndHide(String[][] field) {
        this.field = field;
        this.isChecked = new boolean[field.length][field[0].length];
    }

    public String getResult() {
        explore();
        return sheepSurvived + " " + wolvesSurvived;
    }

    private void explore() {
        for (int i = 0; i < field.length; i++) {
            for (int j = 0; j < field[i].length; j++) {
                if (!field[i][j].equals("#") && !isChecked[i][j]) {
                    isChecked[i][j] = true;
                    seekAndHide(i, j);
                }
            }
        }
    }

    private void seekAndHide(int x, int y) {
        int wolves = 0;
        int sheep = 0;

        Queue<int[]> q = new ArrayDeque<>();
        q.offer(new int[]{x, y});

        while (!q.isEmpty()) {
            int[] cur = q.poll();
            int curX = cur[0];
            int curY = cur[1];

            if(field[curX][curY].equals("v")) wolves++;
            else if(field[curX][curY].equals("k")) sheep++;

            for (int[] direction : directions) {
                int nx = curX + direction[0];
                int ny = curY + direction[1];

                if (isWithinField(nx, ny) && !isChecked[nx][ny] && !field[nx][ny].equals("#")) {
                    isChecked[nx][ny] = true;
                    q.offer(new int[]{nx, ny});
                }
            }
        }

        if(sheep > wolves) sheepSurvived += sheep;
        else wolvesSurvived += wolves;
    }

    private boolean isWithinField(int x, int y) {
        return 0 <= x && x < field.length && 0 <= y && y < field[x].length;
    }
}
```
## ë…ì„œ ëª©ë¡

### ì„œí‰ ì™„ë£Œ ëª©ë¡
- [í˜¼ì ê³µë¶€í•˜ëŠ” ì»´í“¨í„° êµ¬ì¡° + ìš´ì˜ì²´ì œ](https://github.com/kimregular/DAILY_STUDY/blob/main/ë…ì„œ/1.%20ì„œí‰/01.%20í˜¼ì%20ê³µë¶€í•˜ëŠ”%20ì»´í“¨í„°%20êµ¬ì¡°%20%2B%20ìš´ì˜ì²´ì œ%20ë¥¼%20ì½ê³ %20ğŸ“.md)

###  ì„œí‰ ì˜ˆì • ëª©ë¡ (ì½ëŠ” ì¤‘)
- í”„ë¡œê·¸ë˜ë¨¸ì˜ ê¸¸, ë©˜í† ì—ê²Œ ë¬»ë‹¤
- í•¨ê»˜ ìë¼ê¸° ì• ìì¼ë¡œ ê°€ëŠ” ê¸¸

### ë…ì„œ ì˜ˆì • ëª©ë¡
#### ëª©ë¡ì€ ìš°ì„ ìˆœìœ„ íì´ë‹¤. ìƒë‹¨ì— ìˆë”ë¼ë„ ë” ì¤‘ìš”í•œ ì±…ì´ ë“¤ì–´ì˜¨ë‹¤ë©´ ìˆœìœ„ê°€ ë’¤ë¡œ ë°€ë¦´ ìˆ˜ ìˆë‹¤.
- ê°ì²´ì§€í–¥ì˜ ì‚¬ì‹¤ê³¼ ì˜¤í•´
- ì˜¤ë¸Œì íŠ¸
- íŒŒì´ë¸Œ ë¼ì¸ìŠ¤ ì˜¤ë¸Œ ì½”ë“œ
- HTTP ì™„ë²½ ê°€ì´ë“œ
- ìë°”/ìŠ¤í”„ë§ ê°œë°œìë¥¼ ìœ„í•œ ì‹¤ìš©ì£¼ì˜ í”„ë¡œê·¸ë˜ë°
- ëª¨ë˜ ìë°” ì¸ ì•¡ì…˜
- ìë°” ì„±ëŠ¥ íŠœë‹ ì´ì•¼ê¸° 
- ìë°” ê°œë°œìì™€ ì‹œìŠ¤í…œ ìš´ì˜ìë¥¼ ìœ„í•œ íŠ¸ëŸ¬ë¸” ìŠˆíŒ… ì´ì•¼ê¸° / scouterë¥¼ í™œìš©í•œ ì‹œìŠ¤í…œ ì¥ì•  ì§„ë‹¨ ë° í•´ê²° ë…¸í•˜ìš° ìë°” íŠ¸ëŸ¬ë¸”ìŠˆíŒ…
- í—¤ë“œ í¼ìŠ¤íŠ¸ ì„œë¸”ë¦¿
- Hello Coding ê·¸ë¦¼ìœ¼ë¡œ ê°œë…ì„ ì´í•´í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
